import java.util.List;

// Faking the log4j Logger
class Logger
{
    protected Class clazz_;
    
    public Logger(Class c)
    {
    	clazz_ = c;
    }
    
    public static Logger getLogger(Class c)
    {
    	return new Logger(c);
    }
    
    public boolean isDebugEnabled() { return true; }
    
    public void debug(String s)
    {
    	System.out.println(s);
    }
}

public class PS2PLEXILPair 
{	  
    public int m_nPlanStructureID; /** The plan structure identifier */
	public String m_sPlexilID; /** The plexil node identifier */
	  
	public PS2PLEXILPair(int nPlanStructureID, String sPlexilID)
	{
	    m_nPlanStructureID = nPlanStructureID;
	    m_sPlexilID = sPlexilID;
	} 
}

public class PlanStructureToPlexilConverter 
{
    private static int nodeCounter = 0;
    private static final String SCHEMA_DECLARATION =  "xsi:noNamespaceSchemaLocation=\"schema_060503.xsd\"";
    private final static Logger LOGGER = Logger.getLogger(PlanStructureToPlexilConverter.class);

    /**
     * Converts the specified PlanStructute to PLEXIL.
     *
     * @param ps the PlanStructure to be converted
     * @param mappings the mappings of PlanStructure identifiers to PLEXIL node identifiers.
     * @return String the resulting PLEXIL plan
     */
    public static String convertToPlexil(PlanStructure ps, List mappings) {
	int indent = 0; // Used to make XML indented correctly
	String xmlStr = new String();

	// Output the main PLEXIL Nodes. Just the standard stuff.
	xmlStr += "<!-- DSA Plan Structure Converteed to PLEXIL -->\n";

	// Iterate over the actions. We assume their time bounds are grounded and they are all peers. Planner
	// should have ensured required orderings are maintained when grounding, so no need to worry about any of that.
	ActionStructure[] actions = ps.actions;
	xmlStr += indentation(indent++) +"<PlexilPlan " + SCHEMA_DECLARATION + ">\n";

	// Allocate a master node
	xmlStr += indentation(indent++) + "<Node type=\"NodeList\">\n";

	// Allocate a nodeId for the plan identifier.
	xmlStr += indentation(indent) + " <NodeId>DSA_Plan_Structure</NodeId>\n";

	// Allocate a node body and node list to wrap individual action nodes.
	xmlStr += indentation(indent++) + "<NodeBody>\n";
	xmlStr += indentation(indent++) + "<NodeList>\n";

	boolean hasEffects = false;

	// By default, last node will block on action completion
	String lastNodeId = "ActionNode_" + nodeCounter;

	// Now we iterate over the actions and output a node for each
	for(int i=0; i<actions.length;i++){
	    ActionStructure action = actions[i];
	    int id = action.temporal_object.entity.id;

	    // Allocate the node for this action
	    xmlStr += indentation(indent++) + "<Node type=\"Command\">\n";

	    // Allocate the NodeId for this action
	    String nodeId = "ActionNode_" + nodeCounter++;
	    xmlStr += indentation(indent) + "<NodeId>" + nodeId + "</NodeId>\n";
	    mappings.add(new PS2PLEXILPair(id, nodeId));

	    // Add the start condition. Time == end time
	    int startTick = getTick(action.temporal_object.start_time_id, ps);
	    xmlStr += makeStartCondition(indent, startTick ) + "\n";

	    // Add the end condition. Time == end time
	    int endTick = getTick(action.temporal_object.end_time_id, ps);
	    xmlStr += makeInvariantCondition(indent, endTick) + "\n";

	    // Output the command
	    xmlStr += indentation(indent++) + " <NodeBody>\n";
	    xmlStr += makeCommand(indent, action, ps);
	    xmlStr += indentation(--indent) + " </NodeBody>\n";

	    // Complete the action node
	    xmlStr += indentation(--indent) + "</Node>\n";

	    // If the action has effects, then for each effect we must create an update node
	    if(action.effect_ids.length > 0){
		hasEffects = true;
		String updateNodeId = "EffectsNode_" + nodeCounter++;
		mappings.add(new PS2PLEXILPair(id, updateNodeId));
		xmlStr += makeUpdateNode(indent, nodeId, action, ps, updateNodeId);
	    }
	}

	// Deallocate a node body and node list to wrap individual action nodes.
	xmlStr += indentation(--indent) + "</NodeList>\n";
	xmlStr += indentation(--indent) + "</NodeBody>\n";

	// If there are effects, wait till the last node (update node) ends.
	if(hasEffects)
	    lastNodeId = "EffectsNode_" + (nodeCounter - 1);

	// Allocate an end condition to ensure the overall plan does not end until the last node executes. Note that this will have to be done more carefully
	// for plans with more than one action since we will have identify some possible sub-sets of actions that have to execute in order to finish.
	xmlStr += makePlanTerminationCondition(indent, lastNodeId);

	// close master node
	xmlStr += indentation(--indent) + "</Node>";

	// Close PlexilPlan
	xmlStr += indentation(--indent) + "</PlexilPlan>";

	return xmlStr;
    } // convertToPlexil

    private static String indentation(int indent){
	String indentStr = new String();
	for(int i=0;i<indent;i++){
	    indentStr += "  ";
	}

	return indentStr;
    }

    /**
     * @brief Generate an update node XML
     * @param indent The indentation offset
     * @param actionNodeId The action node id. Required to set the start condition
     * @param action The action details. Used to obtain the effects which drive update.
     * @param ps The PlanStructure. Used to obtain the propositions for the effects.
     * @param updateNodeId The update node id to use.
     * @return The xml string
     */
    private static String makeUpdateNode(int indent, String actionNodeId, ActionStructure action, PlanStructure ps, String updateNodeId){
      String xmlStr = new String();
	xmlStr += indentation(indent++) + "<Node type=\"Update\">\n";
	xmlStr += indentation(indent) + "<NodeId>" + updateNodeId + "</NodeId>\n";
	xmlStr += indentation(indent) + "<StartCondition><EQInternal><NodeStateVariable><NodeId>" + actionNodeId + "</NodeId></NodeStateVariable><NodeStateValue>FINISHED</NodeStateValue></EQInternal></StartCondition>\n";

	// Now output all the pairs, one for each effect, in the node body
	xmlStr += indentation(indent++) + "<NodeBody><Update>\n";
	for(int j=0; j<action.effect_ids.length; j++){
	    PropositionStructure prop = getProposition(action.effect_ids[j], ps);
	    if (prop.entity_ids.length > 0) {
		    xmlStr += indentation(indent) +
		    	"<Pair><Name>" + prop.entity_ids[0] + "</Name><LookupNow><StateName>" + getParameterStringValueByName(prop.parameter_ids, "attribute_name", ps) + "</StateName></LookupNow></Pair>\n";
	    } // end if
	}

	xmlStr += indentation(--indent) + "</Update></NodeBody>\n";
	xmlStr += indentation(--indent) + "</Node>\n";
	return xmlStr;
    }

    /**
     * @brief Generates and end condiition so that the plan will execute all nodes before terminating.
     * @todo Will have to look more carefully at this as we get into complex plans
     */
    private static String makePlanTerminationCondition(int indent, String lastNodeId){
	String resultStr = new String();
	resultStr += indentation(indent++) + "<EndCondition> \n";
	resultStr += indentation(indent++) + "<EQInternal>\n";
	resultStr += indentation(indent) + "<NodeStateVariable><NodeId>" + lastNodeId + "</NodeId> </NodeStateVariable>\n";
	resultStr += indentation(indent) + "<NodeStateValue>FINISHED</NodeStateValue> \n";
	resultStr += indentation(--indent) + "</EQInternal>\n";
	resultStr += indentation(--indent) + "</EndCondition>\n";
	return resultStr;
    }

    /**
     * @brief The start condition indicates criteria for when an action may be executed. Once true, it is up to the executive to dispatch it.
     * The only start condition we care about is the start time.
     * @param ident The indentation to use.
     * @param startTime The end time of the action
     * @return an xml string containing a start condition.
     * @todo Investigate if other conditions need to come into play for start conditions.
     */
    private static String makeStartCondition(int indent, int startTime){
	String resultStr = new String();
	resultStr += indentation(indent++) + "<StartCondition> <GE> \n";
	resultStr += indentation(indent++) + "<LookupOnChange><StateName>time</StateName><Tolerance><RealValue>1.0</RealValue> </Tolerance> </LookupOnChange>\n";
	resultStr += indentation(indent) + "<RealValue>" + startTime + "</RealValue> \n";
	resultStr += indentation(--indent) + "</GE></StartCondition>\n";
	return resultStr;
    }

    /**
     * @brief The invariant condition is used to monitor invariants during node execution. Note that for now, we only monitor
     * time. However, in the future, conditions of an action should also lead to invariants for monitoring.
     * @param ident The indentation to use.
     * @param endTime The end time of the action
     * @return an xml string containing an invariant condition.
     * @todo See how we should handle temporally scoped conditions, which may not be required for the full duration of the action
     */
    private static String makeInvariantCondition(int indent, int endTime){
	String resultStr = new String();
	resultStr += indentation(indent++) + "<InvariantCondition> <LE> \n";
	resultStr += indentation(indent) + "<LookupOnChange><StateName>time</StateName><Tolerance><RealValue>1.0</RealValue> </Tolerance> </LookupOnChange>\n";
	resultStr += indentation(indent) + "<RealValue>" + (endTime + 10) + "</RealValue> \n";
	resultStr += indentation(--indent) + "</LE></InvariantCondition>\n";
	return resultStr;
    }

    private static String makeCommand(int indent, ActionStructure action, PlanStructure ps){
	String resultStr = new String();
	int[] parameters = action.parameter_ids;
	resultStr += indentation(indent++) + "<Command>\n";
	resultStr += indentation(indent) + "<CommandName>" + getParameterStringValueByName(parameters, "action_name", ps) + "</CommandName>\n";

	if(parameters.length > 0){
	    resultStr += indentation(indent++) + "<Arguments>\n";
	    for(int i=0;i<parameters.length;i++){
		ParameterStructure parameter = getParameter(parameters[i], ps);
		String argTag = "BadTag<MeansThatWeCouldNoptMatchTheType with string, long or double>";
		String argValue = new String();

		ParameterType paramType = parameter.value.discriminator();

		if(paramType == ParameterType.STRING_TYPE){
		    argTag = "StringValue";
		    argValue += "\"" + parameter.value.string_value() + "\"";
		}
		else if(paramType == ParameterType.LONG_TYPE){
		    argTag = "IntegerValue";
		    argValue += parameter.value.long_value();
		}
		else if(paramType == ParameterType.DOUBLE_TYPE){
		    argTag = "RealValue";
		    argValue += parameter.value.double_value();
		}
		else {
		    if(LOGGER.isDebugEnabled())
			LOGGER.debug("No parameter type match for " + parameter.name + " with type " + paramType.value());
        continue; /* per cmcgann email to srschaff dated 2006.07.28 */
		}

		resultStr += indentation(indent) + "<" + argTag + ">" + argValue + "</" + argTag + ">\n";
	    }

	    resultStr += indentation(--indent) + "</Arguments>\n";
	}

	resultStr += indentation(--indent) + "</Command>\n";
	return resultStr;
    }

    static private ParameterStructure getParameter(int id, PlanStructure ps){
	if (LOGGER.isDebugEnabled())
	    LOGGER.debug("Looking for " + id);

	for(int i=0;i<ps.parameters.length;i++){
	    ParameterStructure param = ps.parameters[i];

	    if (LOGGER.isDebugEnabled())
		LOGGER.debug("Evaluating id: " + param.entity.id + " and value " +  param.name);

	    if(param.entity.id == id)
		return param;
	}

	if (LOGGER.isDebugEnabled())
	    LOGGER.debug("No parameter found for id: " + id);

	return null; // Should throw an exception here
    }

    static private PropositionStructure getProposition(int id, PlanStructure ps){

	for(int i=0;i<ps.parameters.length;i++){
	    PropositionStructure prop= ps.propositions[i];
	    if(prop.temporal_object.entity.id == id)
		return prop;
	}

	if (LOGGER.isDebugEnabled())
	    LOGGER.debug("No proposition found for id: " + id);

	return null; // Should throw an exception here
    }

    static private String getParameterStringValueByName(int[] parameters, String paramName, PlanStructure ps){

	for(int i=0; i<parameters.length; i++){
	    ParameterStructure param = getParameter(parameters[i], ps);
	    if(param.name.equals(paramName)){
		ParameterValue value = param.value;

		// TODO: Add test on type and throw exception if not a string
		return value.string_value();
	    }
	}

	if (LOGGER.isDebugEnabled())
	    LOGGER.debug(paramName + " not found");

	return null;  // Should throw an exception here
    }

  static private int getTick(int id, PlanStructure ps)
  {
	  ParameterStructure paramStruct = getParameter(id, ps);

	  // Should assert that the type of this parameter is a Time type
	  DSATime timeValue = paramStruct.value.time_value();
	  return timeValue.seconds;
  } // getTick

} // PlanStructureToPlexilConverter

