// Light.bsh

import psengine.*;
import java.util.List;
import java.util.Vector;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

source("PlanStructure.bsh");
source("PlanStructureToPlexilConverter.bsh");

public class LibraryLoader {
  // This class only contains static functions.
  private LibraryLoader() {}

  public static String mapLibraryName(String libname) {
    String osname = System.getProperty("os.name");
    String localName = System.mapLibraryName(libname);
    if(osname.equals("Mac OS X"))
      localName = localName.replaceAll("jnilib$", "dylib");
    return localName;
  }

  public static void loadLibrary(String libname) {
    String localName = mapLibraryName(libname);
    String[]libpath = System.getProperty("java.library.path").split(File.pathSeparator);
    for(int i=0; i<libpath.length; ++i) {
      File lib = new File(libpath[i], localName);
      if(lib.exists()) {
        String resolvedLibName = null;
        try {
          resolvedLibName = lib.getCanonicalPath();
        }
        catch(IOException ex) {
          resolvedLibName = lib.getAbsolutePath();
        }
        System.load(resolvedLibName);
        return;
      }
    }
    throw new UnsatisfiedLinkError("no " + libname + " in java.library.path");
  }
}

// Pascal : in your program the variable psengine is not available, so the method getPSEngine() provided below
// should be called instead to initialize europa
PSEngine europa = psengine;

public PSEngine getPSEngine()
{
	if (europa == null) {
        LibraryLoader.loadLibrary("System_o"); // use System_g if you wnat to run the debug version
        europa = new PSEngine();
        europa.start();
	}

	return europa;
}

void loadModel()
{
	cwd = bsh.cwd;
    String nddlModel = cwd+"/Light.nddl";
    getPSEngine().executeScript("nddl",new FileReader(nddlModel));
}

void createPlan()
{
	solver = desktop.makeSolver("PlannerConfig.xml", 0, 50);

	while (solver.hasFlaws())
		solver.step();
}

void showPlan()
{
    desktop.showTokens(getPSEngine().getObjectsByType("LightMgr").get(0));
}

PlanStructure makePlanStructure()
{
	return EUROPAtoPlanStructure.translate(getPSEngine().getTokens());	
}

String planStructureToPlexil(PlanStructure ps, List mappings)
{
	return PlanStructureToPlexilConverter.convertToPlexil(ps,mappings);
}

// Pascal : This is what you need to move to your CI component
void realTest()
{
    // Run when component starts :
	loadModel();
    createPlan();
	
	// Run when getPlan is invoked :
	PlanStructure ps = makePlanStructure();
	System.out.println(ps.toString()); // Real test doesn't need this
}

void debugTest()
{
	loadModel();
    createPlan();
	showPlan(); 
	PlanStructure ps = makePlanStructure();
	System.out.println(ps.toString()); 
	Vector mappings = new Vector();    
	String plexil = planStructureToPlexil(ps,mappings); 
	System.out.println(plexil); 	
}

void main()
{
    //realTest();
    debugTest();
}


main();

