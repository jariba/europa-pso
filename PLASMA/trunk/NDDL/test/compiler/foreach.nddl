//////////////////////////////////////////////////////////////
// Test introduction of foreach construct. Our motivation is to
// track all targets that can be acquired on a given path. However,
// we do not know the targets or the paths at model time. They are
// added dynamically. It would be too brittle to enumerate specific ones,
// as well as too cumbersome, even if feasible.
//////////////////////////////////////////////////////////////

#include "../../core/Plasma.nddl"

class Location {
 string description;
 Location(string _description){
  description = _description;
 }
}

class Path {
 Location from;
 Location to;
 Path(Location _from, Location _to){
  from = _from;
  to = _to;
 }
}

class Target {
 predicate Tracking{}
}

// This class provides the many-many relation required between
// Path and target
class Trackable {
 Path path;
 Target target;
 Trackable(Path _path, Target _target){
  path = _path;
  target = _target;
 }
}


// Will use this to test that foreach over an empty set will not be a problem
class NotTrackable extends Trackable {
 NotTrackable(Path _path, Target _target){
  super(_path, _target);
 }
}

class Rover {
 predicate Navigate{
  Path path;
  Location from;
  Location to;
  neq(from, to);
 }
}

Rover::Navigate{
 Path p: {
	eq(from, p.from);
	eq(to, p.to);
 };

 eq(path, p);

 if(path){
 	Trackable trackable : {
		eq(trackable.path, p);
 	};

 	NotTrackable notTrackable : {
		eq(notTrackable.path, p);
 	};

 	foreach (t in trackable) {
                Trackable t_local_0;
		contains(Target.Tracking target);
		eq(target.object, t.target);
                eq(t, t_local_0);
 	};

 	foreach (t in notTrackable) {
                Trackable t_local_1;
		contains(Target.Tracking target);
		eq(target.object, t.target);
                neq(t, t_local_1);
 	};
 }
}
