enum Locations {Hill, Rock, Lander};

class Foo {
 predicate Bar{}
}

class Rover{
 Foo foo;
 predicate At{
  Locations _location;
  Foo _foo;
 }

 predicate Going{
  Locations _from, _to;
 }

 Rover(){
  foo = new Foo();
 }
}

Rover::At{
 meets(object.Going to);
 eq(to._from, _location);

 meets(Going from);
 eq(from._to, _location);

 // Test that we can reference other objects. Has semantics of posting
 // an equality constraint on the object variable
 meets(_foo.Bar bar);
 Foo localFoo;
 meets(localFoo.Bar baz);
}

Rover::Going{
 neq(_from, _to);
}

// Defines the initial state for the problem.
class World {
 Rover rover;

 predicate initialState{}

 World(){
  rover = new Rover();
 }
}

World::initialState{
 // Enumerate all supported temporal relations
 contains(Rover.At s0);
 contained_by(Rover.At s1);
 meets(Rover.At s2);
 met_by(Rover.At s3);
 before(Rover.At s4);
 after(Rover.At s5);
 starts(Rover.At s6);
 ends(Rover.At s7);
 any(Rover.At s8);
 
 // Subgoal and bind
 contains(Rover.At a);
 eq(a._location, Lander);

 contains(Rover.At b);
 eq(b._location, Rock);

 leq(a.end, b.start);

 // Test rule to use local variables
 Rover r1;
 Rover r2;
 eq(r1, r2);

 // Test use of binary temporal relation
 b after (Rover.At c);
 a meets c;

 // test use of starts
 c starts (Rover.At d);
}

// Transactions
World world = new World();
close();

goal(World.initialState t0);
t0.activate();

goal(Rover.Going t1);
t1.activate();
goal(Rover.Going t2);
t2.merge(t1);
