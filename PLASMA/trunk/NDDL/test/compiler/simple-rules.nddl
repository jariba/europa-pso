enum Locations {Hill, Rock, Lander};

class Rover{
 predicate At{
  Locations _location;
 }

 predicate Going{
  Locations _from, _to;
 }
}

Rover::At{
 meets(object.Going to);
 eq(to._from, _location);

 meets(Going from);
 eq(from._to, _location);
}

Rover::Going{
 neq(_from, _to);
}

// Defines the initial state for the problem.
class World {
 Rover rover;

 predicate initialState{}
 World(){
  rover = new Rover();
 }
}

World::initialState{
 // Enumerate all supported temporal relations
 contains(Rover.At s0);
 contained_by(Rover.At s1);
 meets(Rover.At s2);
 met_by(Rover.At s3);
 before(Rover.At s4);
 after(Rover.At s5);
 starts(Rover.At s6);
 ends(Rover.At s7);
 any(Rover.At s8);
 
 // Subgoal and bind
 contains(Rover.At a);
 eq(a._location, Lander);

 contains(Rover.At b);
 eq(b._location, Rock);

 leq(a.end, b.start);

 // Test rule to use local variables
 Rover r1;
 Rover r2;
 eq(r1, r2);

 // Test use of binary temporal relation
 b after (Rover.At c);
 a meets c;

 //test use of starts
 c starts (Rover.At d);

}
