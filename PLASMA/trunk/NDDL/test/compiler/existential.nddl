class Location{
 string name;
 Location(string _name){
  name = _name;
 }
}

class Path{
 Location from, to;
 Path(Location _from, Location _to){
  from = _from;
  to = _to;
 }
}

class World{
 Location rock;
 Location hill;
 Location lander;
 Location martianCity;

 Path p1;
 Path p2;
 Path p3;
 Path p4;

 predicate Going{
  Location from;
  Location to;
  neq(from, to);
 }

 predicate initialState{}
 World(){
  rock = new Location("ROCK");
  hill = new Location("HILL");
  lander = new Location("LANDER");
  martianCity = new Location("MARTIAN_CITY");
  p1 = new Path(rock, hill);
  p2 = new Path(lander, hill);
  p3 = new Path(martianCity, hill);
  p4 = new Path(hill, lander);
 }
}

World::Going{
 Path path : {
  eq(path.from, from);
  eq(path.to, to);
 };

 Path p1: {};
}

World::initialState{
 any(Going going);
 eq(going.from, object.rock);
 eq(going.to, object.hill);

 Path p1 : {
  eq(p1.from, going.from);
  eq(p1.to, going.to);
 };

 Path p2 : {
  eq(p2.from, going.from);
  eq(p2.to, going.to);
 };

 Path p3 : {};

 // Now create a filter that will remove all values
 // but verify that no inconsistency is triggered. Note that if
 // the keyword 'filterOnly' is ommitted, then it will cause an inconsistency
 Location loc1;
 Location loc2;
 eq(loc1, object.rock);
 eq(loc2, object.rock);

 Path p4 filterOnly : {
  eq(p4.from, loc1);
  eq(p4.to, loc2);
 };

 // Make sure that the model compiles if the filter
 // variable name is a substring of the constraint argument
  Path g : {
    eq(g.from, going.from);
  };
}

World world = new World();
close();
goal(World.initialState g0);
