/** \file
 *  This C source file was generated by $ANTLR version 3.1.2
 *
 *     -  From the grammar source file : NDDL/base/antlr/NDDL3Tree.g
 *     -                            On : 2011-08-23 11:37:25
 *     -           for the tree parser : NDDL3TreeTreeParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "NDDL3Tree.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pNDDL3Tree_##scope##_SCOPE
#define SCOPE_STACK(scope)  pNDDL3Tree_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pNDDL3Tree_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO		
#undef		SEEK    
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   NDDL3TreeTokenNames[103+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "CONSTRAINT_INSTANTIATION",
        (pANTLR3_UINT8) "CONSTRUCTOR",
        (pANTLR3_UINT8) "CONSTRUCTOR_INVOCATION",
        (pANTLR3_UINT8) "METHOD_CALL",
        (pANTLR3_UINT8) "NDDL",
        (pANTLR3_UINT8) "PREDICATE_INSTANCE",
        (pANTLR3_UINT8) "TOKEN_RELATION",
        (pANTLR3_UINT8) "VARIABLE",
        (pANTLR3_UINT8) "EXPRESSION_ENFORCE",
        (pANTLR3_UINT8) "EXPRESSION_RETURN",
        (pANTLR3_UINT8) "FUNCTION_CALL",
        (pANTLR3_UINT8) "CLOSE",
        (pANTLR3_UINT8) "IDENT",
        (pANTLR3_UINT8) "INT",
        (pANTLR3_UINT8) "FLOAT",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "INCLUDE",
        (pANTLR3_UINT8) "ESCAPE_SEQUENCE",
        (pANTLR3_UINT8) "UNICODE_ESC",
        (pANTLR3_UINT8) "OCTAL_ESC",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "INT_SUFFIX",
        (pANTLR3_UINT8) "EXPONENT",
        (pANTLR3_UINT8) "FLOAT_SUFFIX",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "LINE_COMMENT",
        (pANTLR3_UINT8) "'enum'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'}'",
        (pANTLR3_UINT8) "'typedef'",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'filter'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'new'",
        (pANTLR3_UINT8) "'this'",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'in'",
        (pANTLR3_UINT8) "'class'",
        (pANTLR3_UINT8) "'extends'",
        (pANTLR3_UINT8) "'predicate'",
        (pANTLR3_UINT8) "'action'",
        (pANTLR3_UINT8) "'::'",
        (pANTLR3_UINT8) "'int'",
        (pANTLR3_UINT8) "'float'",
        (pANTLR3_UINT8) "'bool'",
        (pANTLR3_UINT8) "'string'",
        (pANTLR3_UINT8) "'rejectable'",
        (pANTLR3_UINT8) "'goal'",
        (pANTLR3_UINT8) "'fact'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "'enforce'",
        (pANTLR3_UINT8) "'||'",
        (pANTLR3_UINT8) "'&&'",
        (pANTLR3_UINT8) "'=='",
        (pANTLR3_UINT8) "'!='",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'>='",
        (pANTLR3_UINT8) "'<='",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'super'",
        (pANTLR3_UINT8) "'if'",
        (pANTLR3_UINT8) "'else'",
        (pANTLR3_UINT8) "'foreach'",
        (pANTLR3_UINT8) "'after'",
        (pANTLR3_UINT8) "'any'",
        (pANTLR3_UINT8) "'before'",
        (pANTLR3_UINT8) "'contained_by'",
        (pANTLR3_UINT8) "'contains'",
        (pANTLR3_UINT8) "'contains_end'",
        (pANTLR3_UINT8) "'contains_start'",
        (pANTLR3_UINT8) "'ends'",
        (pANTLR3_UINT8) "'ends_after'",
        (pANTLR3_UINT8) "'ends_after_start'",
        (pANTLR3_UINT8) "'ends_before'",
        (pANTLR3_UINT8) "'ends_during'",
        (pANTLR3_UINT8) "'equal'",
        (pANTLR3_UINT8) "'equals'",
        (pANTLR3_UINT8) "'meets'",
        (pANTLR3_UINT8) "'met_by'",
        (pANTLR3_UINT8) "'parallels'",
        (pANTLR3_UINT8) "'paralleled_by'",
        (pANTLR3_UINT8) "'starts'",
        (pANTLR3_UINT8) "'starts_after'",
        (pANTLR3_UINT8) "'starts_before'",
        (pANTLR3_UINT8) "'starts_before_end'",
        (pANTLR3_UINT8) "'starts_during'",
        (pANTLR3_UINT8) "'true'",
        (pANTLR3_UINT8) "'false'",
        (pANTLR3_UINT8) "'inf'",
        (pANTLR3_UINT8) "'inff'",
        (pANTLR3_UINT8) "'-inf'",
        (pANTLR3_UINT8) "'-inff'",
        (pANTLR3_UINT8) "'close'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static void	nddl    (pNDDL3Tree ctx);
static Expr*	enumDefinition    (pNDDL3Tree ctx);
static void	enumValues    (pNDDL3Tree ctx, std::vector<std::string>& values);
static Expr*	typeDefinition    (pNDDL3Tree ctx);
static DataType*	type    (pNDDL3Tree ctx);
static Domain*	baseDomain    (pNDDL3Tree ctx, const DataType* baseType);
static Expr*	baseDomainValues    (pNDDL3Tree ctx);
static ExprList*	variableDeclarations    (pNDDL3Tree ctx);
static Expr*	variableInitialization    (pNDDL3Tree ctx, const DataTypeId& dataType);
static Expr*	initializer    (pNDDL3Tree ctx, const char* varName);
static Expr*	anyValue    (pNDDL3Tree ctx);
static Expr*	setElement    (pNDDL3Tree ctx);
static Expr*	valueSet    (pNDDL3Tree ctx);
static Expr*	literalValue    (pNDDL3Tree ctx);
static Domain*	booleanLiteral    (pNDDL3Tree ctx);
static Domain*	stringLiteral    (pNDDL3Tree ctx);
static Domain*	numericLiteral    (pNDDL3Tree ctx);
static NDDL3Tree_floatLiteral_return	floatLiteral    (pNDDL3Tree ctx);
static NDDL3Tree_intLiteral_return	intLiteral    (pNDDL3Tree ctx);
static Expr*	numericInterval    (pNDDL3Tree ctx);
static Expr*	allocation    (pNDDL3Tree ctx, const char* name);
static void	variableArgumentList    (pNDDL3Tree ctx, std::vector<Expr*>& result);
static NDDL3Tree_identifier_return	identifier    (pNDDL3Tree ctx);
static ExprConstraint*	constraintInstantiation    (pNDDL3Tree ctx);
static void	violationMsg    (pNDDL3Tree ctx, std::string& result);
static Expr*	classDeclaration    (pNDDL3Tree ctx);
static void	classBlock    (pNDDL3Tree ctx, ObjectType* objType);
static void	componentTypeEntry    (pNDDL3Tree ctx, ObjectType* objType);
static void	classVariable    (pNDDL3Tree ctx, ObjectType* objType);
static void	constructor    (pNDDL3Tree ctx, ObjectType* objType);
static void	constructorArgument    (pNDDL3Tree ctx, std::vector<std::string>& argNames, std::vector<std::string>& argTypes);
static ExprConstructorSuperCall*	constructorSuper    (pNDDL3Tree ctx, ObjectType* objType);
static ExprAssignment*	assignment    (pNDDL3Tree ctx);
static void	tokenType    (pNDDL3Tree ctx, ObjectType* objType);
static void	tokenStatements    (pNDDL3Tree ctx, InterpretedTokenType* tokenType);
static Expr*	tokenParameter    (pNDDL3Tree ctx, InterpretedTokenType* tokenType);
static Expr*	tokenParameterAssignment    (pNDDL3Tree ctx);
static Expr*	standardConstraint    (pNDDL3Tree ctx);
static Expr*	rule    (pNDDL3Tree ctx);
static void	ruleBlock    (pNDDL3Tree ctx, std::vector<Expr*>& ruleBody);
static Expr*	ruleStatement    (pNDDL3Tree ctx);
static Expr*	ifStatement    (pNDDL3Tree ctx);
static ExprIfGuard*	guardExpression    (pNDDL3Tree ctx);
static NDDL3Tree_guardRelop_return	guardRelop    (pNDDL3Tree ctx);
static Expr*	loopStatement    (pNDDL3Tree ctx);
static Expr*	problemStmt    (pNDDL3Tree ctx);
static NDDL3Tree_problemStmtType_return	problemStmtType    (pNDDL3Tree ctx);
static Expr*	relation    (pNDDL3Tree ctx);
static void	predicateInstanceList    (pNDDL3Tree ctx, std::vector<PredicateInstanceRef*>& instances);
static PredicateInstanceRef*	predicateInstance    (pNDDL3Tree ctx);
static void	qualifiedString    (pNDDL3Tree ctx, std::string& result);
static Expr*	qualified    (pNDDL3Tree ctx);
static void	qualifiedToken    (pNDDL3Tree ctx, std::string& tokenStr, TokenTypeId& tokenType);
static NDDL3Tree_temporalRelation_return	temporalRelation    (pNDDL3Tree ctx);
static Expr*	methodInvocation    (pNDDL3Tree ctx);
static NDDL3Tree_methodName_return	methodName    (pNDDL3Tree ctx);
static void	cexpressionList    (pNDDL3Tree ctx, std::vector<CExpr*> &args);
static CExpr*	cexpression    (pNDDL3Tree ctx);
static NDDL3Tree_cexprOp_return	cexprOp    (pNDDL3Tree ctx);
static Expr*	enforceExpression    (pNDDL3Tree ctx);
static Expr*	expressionCleanReturn    (pNDDL3Tree ctx);
static void	NDDL3TreeFree(pNDDL3Tree ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "NDDL/base/antlr/NDDL3Tree.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new NDDL3Tree parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pNDDL3Tree
NDDL3TreeNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return NDDL3TreeNewSSD(instream, NULL);
}

/** \brief Create a new NDDL3Tree parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pNDDL3Tree
NDDL3TreeNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pNDDL3Tree ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pNDDL3Tree) ANTLR3_CALLOC(1, sizeof(NDDL3Tree));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in NDDL3Tree.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);
    /* Install the implementation of our NDDL3Tree interface
     */
    ctx->nddl	= nddl;
    ctx->enumDefinition	= enumDefinition;
    ctx->enumValues	= enumValues;
    ctx->typeDefinition	= typeDefinition;
    ctx->type	= type;
    ctx->baseDomain	= baseDomain;
    ctx->baseDomainValues	= baseDomainValues;
    ctx->variableDeclarations	= variableDeclarations;
    ctx->variableInitialization	= variableInitialization;
    ctx->initializer	= initializer;
    ctx->anyValue	= anyValue;
    ctx->setElement	= setElement;
    ctx->valueSet	= valueSet;
    ctx->literalValue	= literalValue;
    ctx->booleanLiteral	= booleanLiteral;
    ctx->stringLiteral	= stringLiteral;
    ctx->numericLiteral	= numericLiteral;
    ctx->floatLiteral	= floatLiteral;
    ctx->intLiteral	= intLiteral;
    ctx->numericInterval	= numericInterval;
    ctx->allocation	= allocation;
    ctx->variableArgumentList	= variableArgumentList;
    ctx->identifier	= identifier;
    ctx->constraintInstantiation	= constraintInstantiation;
    ctx->violationMsg	= violationMsg;
    ctx->classDeclaration	= classDeclaration;
    ctx->classBlock	= classBlock;
    ctx->componentTypeEntry	= componentTypeEntry;
    ctx->classVariable	= classVariable;
    ctx->constructor	= constructor;
    ctx->constructorArgument	= constructorArgument;
    ctx->constructorSuper	= constructorSuper;
    ctx->assignment	= assignment;
    ctx->tokenType	= tokenType;
    ctx->tokenStatements	= tokenStatements;
    ctx->tokenParameter	= tokenParameter;
    ctx->tokenParameterAssignment	= tokenParameterAssignment;
    ctx->standardConstraint	= standardConstraint;
    ctx->rule	= rule;
    ctx->ruleBlock	= ruleBlock;
    ctx->ruleStatement	= ruleStatement;
    ctx->ifStatement	= ifStatement;
    ctx->guardExpression	= guardExpression;
    ctx->guardRelop	= guardRelop;
    ctx->loopStatement	= loopStatement;
    ctx->problemStmt	= problemStmt;
    ctx->problemStmtType	= problemStmtType;
    ctx->relation	= relation;
    ctx->predicateInstanceList	= predicateInstanceList;
    ctx->predicateInstance	= predicateInstance;
    ctx->qualifiedString	= qualifiedString;
    ctx->qualified	= qualified;
    ctx->qualifiedToken	= qualifiedToken;
    ctx->temporalRelation	= temporalRelation;
    ctx->methodInvocation	= methodInvocation;
    ctx->methodName	= methodName;
    ctx->cexpressionList	= cexpressionList;
    ctx->cexpression	= cexpression;
    ctx->cexprOp	= cexprOp;
    ctx->enforceExpression	= enforceExpression;
    ctx->expressionCleanReturn	= expressionCleanReturn;
    ctx->free			= NDDL3TreeFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    


        // TODO: Install custom error message display that gathers them in CTX->SymbolTable
        //RECOGNIZER->displayRecognitionError = reportAntlrError;

        // Add a function with the following signature:
        // void reportAntlrError(pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_UINT8 *tokenNames);    
        // use the meat from displayRecognitionError() in antlr3baserecognizer.c

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = NDDL3TreeTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 NDDL3TreeFree(pNDDL3Tree ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this tree parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return NDDL3TreeTokenNames; 
}



    static const char* c_str(pANTLR3_UINT8 chars)
    {
        // TODO: what's the best way to do this?
        return (const char*)chars;
    }

    // TODO: make sure we also get ANTLR errors, see apifuncs below
    static void reportSemanticError(pNDDL3Tree treeWalker, const std::string& msg)
    {
        treeWalker->SymbolTable->reportError(treeWalker,msg);
        // TODO: make sure cleanup is done correctly
        throw msg;
    }

    static std::string getAutoLabel(const char* prefix)
    {
        static int idx = 0;
        std::ostringstream os;
        os << prefix << "_" << idx++;
        
        return os.str();   
    }

    static DataRef evalExpr(pNDDL3Tree treeWalker,Expr* expr)
    {
        return expr->eval(*(treeWalker->SymbolTable));
    }

    static void pushContext(pNDDL3Tree treeWalker, NddlSymbolTable* st)
    {
        treeWalker->SymbolTable = st; 
    }

    static void popContext(pNDDL3Tree treeWalker)
    {
        NddlSymbolTable* st = treeWalker->SymbolTable; 
        treeWalker->SymbolTable = st->getParentST();
        delete st;                                  
        check_error(treeWalker->SymbolTable != NULL);
    }


    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_NDDL_in_nddl70  */
static	ANTLR3_BITWORD FOLLOW_NDDL_in_nddl70_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NDDL_in_nddl70	= { FOLLOW_NDDL_in_nddl70_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_classDeclaration_in_nddl86  */
static	ANTLR3_BITWORD FOLLOW_classDeclaration_in_nddl86_bits[]	= { ANTLR3_UINT64_LIT(0x0E11081100009CD8) };
static  ANTLR3_BITSET_LIST FOLLOW_classDeclaration_in_nddl86	= { FOLLOW_classDeclaration_in_nddl86_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumDefinition_in_nddl102  */
static	ANTLR3_BITWORD FOLLOW_enumDefinition_in_nddl102_bits[]	= { ANTLR3_UINT64_LIT(0x0E11081100009CD8) };
static  ANTLR3_BITSET_LIST FOLLOW_enumDefinition_in_nddl102	= { FOLLOW_enumDefinition_in_nddl102_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeDefinition_in_nddl112  */
static	ANTLR3_BITWORD FOLLOW_typeDefinition_in_nddl112_bits[]	= { ANTLR3_UINT64_LIT(0x0E11081100009CD8) };
static  ANTLR3_BITSET_LIST FOLLOW_typeDefinition_in_nddl112	= { FOLLOW_typeDefinition_in_nddl112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableDeclarations_in_nddl122  */
static	ANTLR3_BITWORD FOLLOW_variableDeclarations_in_nddl122_bits[]	= { ANTLR3_UINT64_LIT(0x0E11081100009CD8) };
static  ANTLR3_BITSET_LIST FOLLOW_variableDeclarations_in_nddl122	= { FOLLOW_variableDeclarations_in_nddl122_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_in_nddl132  */
static	ANTLR3_BITWORD FOLLOW_assignment_in_nddl132_bits[]	= { ANTLR3_UINT64_LIT(0x0E11081100009CD8) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_in_nddl132	= { FOLLOW_assignment_in_nddl132_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraintInstantiation_in_nddl142  */
static	ANTLR3_BITWORD FOLLOW_constraintInstantiation_in_nddl142_bits[]	= { ANTLR3_UINT64_LIT(0x0E11081100009CD8) };
static  ANTLR3_BITSET_LIST FOLLOW_constraintInstantiation_in_nddl142	= { FOLLOW_constraintInstantiation_in_nddl142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enforceExpression_in_nddl152  */
static	ANTLR3_BITWORD FOLLOW_enforceExpression_in_nddl152_bits[]	= { ANTLR3_UINT64_LIT(0x0E11081100009CD8) };
static  ANTLR3_BITSET_LIST FOLLOW_enforceExpression_in_nddl152	= { FOLLOW_enforceExpression_in_nddl152_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_allocation_in_nddl162  */
static	ANTLR3_BITWORD FOLLOW_allocation_in_nddl162_bits[]	= { ANTLR3_UINT64_LIT(0x0E11081100009CD8) };
static  ANTLR3_BITSET_LIST FOLLOW_allocation_in_nddl162	= { FOLLOW_allocation_in_nddl162_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rule_in_nddl173  */
static	ANTLR3_BITWORD FOLLOW_rule_in_nddl173_bits[]	= { ANTLR3_UINT64_LIT(0x0E11081100009CD8) };
static  ANTLR3_BITSET_LIST FOLLOW_rule_in_nddl173	= { FOLLOW_rule_in_nddl173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_problemStmt_in_nddl183  */
static	ANTLR3_BITWORD FOLLOW_problemStmt_in_nddl183_bits[]	= { ANTLR3_UINT64_LIT(0x0E11081100009CD8) };
static  ANTLR3_BITSET_LIST FOLLOW_problemStmt_in_nddl183	= { FOLLOW_problemStmt_in_nddl183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_relation_in_nddl193  */
static	ANTLR3_BITWORD FOLLOW_relation_in_nddl193_bits[]	= { ANTLR3_UINT64_LIT(0x0E11081100009CD8) };
static  ANTLR3_BITSET_LIST FOLLOW_relation_in_nddl193	= { FOLLOW_relation_in_nddl193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_methodInvocation_in_nddl203  */
static	ANTLR3_BITWORD FOLLOW_methodInvocation_in_nddl203_bits[]	= { ANTLR3_UINT64_LIT(0x0E11081100009CD8) };
static  ANTLR3_BITSET_LIST FOLLOW_methodInvocation_in_nddl203	= { FOLLOW_methodInvocation_in_nddl203_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_enumDefinition255  */
static	ANTLR3_BITWORD FOLLOW_32_in_enumDefinition255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_enumDefinition255	= { FOLLOW_32_in_enumDefinition255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_enumDefinition259  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_enumDefinition259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_enumDefinition259	= { FOLLOW_IDENT_in_enumDefinition259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumValues_in_enumDefinition261  */
static	ANTLR3_BITWORD FOLLOW_enumValues_in_enumDefinition261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_enumValues_in_enumDefinition261	= { FOLLOW_enumValues_in_enumDefinition261_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_enumValues298  */
static	ANTLR3_BITWORD FOLLOW_33_in_enumValues298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_enumValues298	= { FOLLOW_33_in_enumValues298_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_enumValues303  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_enumValues303_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_enumValues303	= { FOLLOW_IDENT_in_enumValues303_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_typeDefinition351  */
static	ANTLR3_BITWORD FOLLOW_36_in_typeDefinition351_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_typeDefinition351	= { FOLLOW_36_in_typeDefinition351_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_typeDefinition367  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_typeDefinition367_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_typeDefinition367	= { FOLLOW_IDENT_in_typeDefinition367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_typeDefinition383  */
static	ANTLR3_BITWORD FOLLOW_type_in_typeDefinition383_bits[]	= { ANTLR3_UINT64_LIT(0x0000004200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_typeDefinition383	= { FOLLOW_type_in_typeDefinition383_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_baseDomain_in_typeDefinition390  */
static	ANTLR3_BITWORD FOLLOW_baseDomain_in_typeDefinition390_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_baseDomain_in_typeDefinition390	= { FOLLOW_baseDomain_in_typeDefinition390_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_53_in_type438  */
static	ANTLR3_BITWORD FOLLOW_53_in_type438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_53_in_type438	= { FOLLOW_53_in_type438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_type454  */
static	ANTLR3_BITWORD FOLLOW_54_in_type454_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_54_in_type454	= { FOLLOW_54_in_type454_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_55_in_type470  */
static	ANTLR3_BITWORD FOLLOW_55_in_type470_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_55_in_type470	= { FOLLOW_55_in_type470_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_type486  */
static	ANTLR3_BITWORD FOLLOW_56_in_type486_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_56_in_type486	= { FOLLOW_56_in_type486_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_type502  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_type502_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_type502	= { FOLLOW_IDENT_in_type502_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_baseDomainValues_in_baseDomain556  */
static	ANTLR3_BITWORD FOLLOW_baseDomainValues_in_baseDomain556_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_baseDomainValues_in_baseDomain556	= { FOLLOW_baseDomainValues_in_baseDomain556_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericInterval_in_baseDomainValues604  */
static	ANTLR3_BITWORD FOLLOW_numericInterval_in_baseDomainValues604_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numericInterval_in_baseDomainValues604	= { FOLLOW_numericInterval_in_baseDomainValues604_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSet_in_baseDomainValues618  */
static	ANTLR3_BITWORD FOLLOW_valueSet_in_baseDomainValues618_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSet_in_baseDomainValues618	= { FOLLOW_valueSet_in_baseDomainValues618_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARIABLE_in_variableDeclarations672  */
static	ANTLR3_BITWORD FOLLOW_VARIABLE_in_variableDeclarations672_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VARIABLE_in_variableDeclarations672	= { FOLLOW_VARIABLE_in_variableDeclarations672_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_variableDeclarations689  */
static	ANTLR3_BITWORD FOLLOW_type_in_variableDeclarations689_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_variableDeclarations689	= { FOLLOW_type_in_variableDeclarations689_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableInitialization_in_variableDeclarations707  */
static	ANTLR3_BITWORD FOLLOW_variableInitialization_in_variableDeclarations707_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000010008) };
static  ANTLR3_BITSET_LIST FOLLOW_variableInitialization_in_variableDeclarations707	= { FOLLOW_variableInitialization_in_variableDeclarations707_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_variableInitialization790  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_variableInitialization790_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_variableInitialization790	= { FOLLOW_IDENT_in_variableInitialization790_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_variableInitialization807  */
static	ANTLR3_BITWORD FOLLOW_43_in_variableInitialization807_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_variableInitialization807	= { FOLLOW_43_in_variableInitialization807_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_variableInitialization811  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_variableInitialization811_bits[]	= { ANTLR3_UINT64_LIT(0x00006042000F0040), ANTLR3_UINT64_LIT(0x000003F000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_variableInitialization811	= { FOLLOW_IDENT_in_variableInitialization811_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initializer_in_variableInitialization818  */
static	ANTLR3_BITWORD FOLLOW_initializer_in_variableInitialization818_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_initializer_in_variableInitialization818	= { FOLLOW_initializer_in_variableInitialization818_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anyValue_in_initializer881  */
static	ANTLR3_BITWORD FOLLOW_anyValue_in_initializer881_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_anyValue_in_initializer881	= { FOLLOW_anyValue_in_initializer881_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_allocation_in_initializer898  */
static	ANTLR3_BITWORD FOLLOW_allocation_in_initializer898_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_allocation_in_initializer898	= { FOLLOW_allocation_in_initializer898_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literalValue_in_anyValue948  */
static	ANTLR3_BITWORD FOLLOW_literalValue_in_anyValue948_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literalValue_in_anyValue948	= { FOLLOW_literalValue_in_anyValue948_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_baseDomainValues_in_anyValue964  */
static	ANTLR3_BITWORD FOLLOW_baseDomainValues_in_anyValue964_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_baseDomainValues_in_anyValue964	= { FOLLOW_baseDomainValues_in_anyValue964_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_in_anyValue980  */
static	ANTLR3_BITWORD FOLLOW_qualified_in_anyValue980_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_in_anyValue980	= { FOLLOW_qualified_in_anyValue980_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literalValue_in_setElement1029  */
static	ANTLR3_BITWORD FOLLOW_literalValue_in_setElement1029_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literalValue_in_setElement1029	= { FOLLOW_literalValue_in_setElement1029_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_in_setElement1045  */
static	ANTLR3_BITWORD FOLLOW_qualified_in_setElement1045_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_in_setElement1045	= { FOLLOW_qualified_in_setElement1045_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_valueSet1094  */
static	ANTLR3_BITWORD FOLLOW_33_in_valueSet1094_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_valueSet1094	= { FOLLOW_33_in_valueSet1094_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_setElement_in_valueSet1111  */
static	ANTLR3_BITWORD FOLLOW_setElement_in_valueSet1111_bits[]	= { ANTLR3_UINT64_LIT(0x00006042000F0008), ANTLR3_UINT64_LIT(0x000003F000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_setElement_in_valueSet1111	= { FOLLOW_setElement_in_valueSet1111_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_booleanLiteral_in_literalValue1189  */
static	ANTLR3_BITWORD FOLLOW_booleanLiteral_in_literalValue1189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_booleanLiteral_in_literalValue1189	= { FOLLOW_booleanLiteral_in_literalValue1189_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericLiteral_in_literalValue1205  */
static	ANTLR3_BITWORD FOLLOW_numericLiteral_in_literalValue1205_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numericLiteral_in_literalValue1205	= { FOLLOW_numericLiteral_in_literalValue1205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stringLiteral_in_literalValue1221  */
static	ANTLR3_BITWORD FOLLOW_stringLiteral_in_literalValue1221_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stringLiteral_in_literalValue1221	= { FOLLOW_stringLiteral_in_literalValue1221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_100_in_booleanLiteral1268  */
static	ANTLR3_BITWORD FOLLOW_100_in_booleanLiteral1268_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_100_in_booleanLiteral1268	= { FOLLOW_100_in_booleanLiteral1268_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_101_in_booleanLiteral1293  */
static	ANTLR3_BITWORD FOLLOW_101_in_booleanLiteral1293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_101_in_booleanLiteral1293	= { FOLLOW_101_in_booleanLiteral1293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_stringLiteral1323  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_stringLiteral1323_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_stringLiteral1323	= { FOLLOW_STRING_in_stringLiteral1323_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_floatLiteral_in_numericLiteral1361  */
static	ANTLR3_BITWORD FOLLOW_floatLiteral_in_numericLiteral1361_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_floatLiteral_in_numericLiteral1361	= { FOLLOW_floatLiteral_in_numericLiteral1361_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_intLiteral_in_numericLiteral1376  */
static	ANTLR3_BITWORD FOLLOW_intLiteral_in_numericLiteral1376_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_intLiteral_in_numericLiteral1376	= { FOLLOW_intLiteral_in_numericLiteral1376_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_floatLiteral0  */
static	ANTLR3_BITWORD FOLLOW_set_in_floatLiteral0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_floatLiteral0	= { FOLLOW_set_in_floatLiteral0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_intLiteral0  */
static	ANTLR3_BITWORD FOLLOW_set_in_intLiteral0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_intLiteral0	= { FOLLOW_set_in_intLiteral0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_numericInterval1483  */
static	ANTLR3_BITWORD FOLLOW_38_in_numericInterval1483_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_numericInterval1483	= { FOLLOW_38_in_numericInterval1483_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericLiteral_in_numericInterval1502  */
static	ANTLR3_BITWORD FOLLOW_numericLiteral_in_numericInterval1502_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000060000), ANTLR3_UINT64_LIT(0x000003C000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_numericLiteral_in_numericInterval1502	= { FOLLOW_numericLiteral_in_numericInterval1502_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericLiteral_in_numericInterval1518  */
static	ANTLR3_BITWORD FOLLOW_numericLiteral_in_numericInterval1518_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_numericLiteral_in_numericInterval1518	= { FOLLOW_numericLiteral_in_numericInterval1518_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTRUCTOR_INVOCATION_in_allocation1576  */
static	ANTLR3_BITWORD FOLLOW_CONSTRUCTOR_INVOCATION_in_allocation1576_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTRUCTOR_INVOCATION_in_allocation1576	= { FOLLOW_CONSTRUCTOR_INVOCATION_in_allocation1576_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_allocation1604  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_allocation1604_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_allocation1604	= { FOLLOW_IDENT_in_allocation1604_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableArgumentList_in_allocation1631  */
static	ANTLR3_BITWORD FOLLOW_variableArgumentList_in_allocation1631_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_variableArgumentList_in_allocation1631	= { FOLLOW_variableArgumentList_in_allocation1631_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_variableArgumentList1701  */
static	ANTLR3_BITWORD FOLLOW_41_in_variableArgumentList1701_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_variableArgumentList1701	= { FOLLOW_41_in_variableArgumentList1701_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_variableArgumentList1720  */
static	ANTLR3_BITWORD FOLLOW_41_in_variableArgumentList1720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_variableArgumentList1720	= { FOLLOW_41_in_variableArgumentList1720_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initializer_in_variableArgumentList1749  */
static	ANTLR3_BITWORD FOLLOW_initializer_in_variableArgumentList1749_bits[]	= { ANTLR3_UINT64_LIT(0x00006042000F0048), ANTLR3_UINT64_LIT(0x000003F000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_initializer_in_variableArgumentList1749	= { FOLLOW_initializer_in_variableArgumentList1749_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_identifier0  */
static	ANTLR3_BITWORD FOLLOW_set_in_identifier0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_identifier0	= { FOLLOW_set_in_identifier0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTRAINT_INSTANTIATION_in_constraintInstantiation1866  */
static	ANTLR3_BITWORD FOLLOW_CONSTRAINT_INSTANTIATION_in_constraintInstantiation1866_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTRAINT_INSTANTIATION_in_constraintInstantiation1866	= { FOLLOW_CONSTRAINT_INSTANTIATION_in_constraintInstantiation1866_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_constraintInstantiation1894  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_constraintInstantiation1894_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_constraintInstantiation1894	= { FOLLOW_IDENT_in_constraintInstantiation1894_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableArgumentList_in_constraintInstantiation1920  */
static	ANTLR3_BITWORD FOLLOW_variableArgumentList_in_constraintInstantiation1920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080008) };
static  ANTLR3_BITSET_LIST FOLLOW_variableArgumentList_in_constraintInstantiation1920	= { FOLLOW_variableArgumentList_in_constraintInstantiation1920_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_violationMsg_in_constraintInstantiation1948  */
static	ANTLR3_BITWORD FOLLOW_violationMsg_in_constraintInstantiation1948_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_violationMsg_in_constraintInstantiation1948	= { FOLLOW_violationMsg_in_constraintInstantiation1948_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_violationMsg2034  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_violationMsg2034_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_violationMsg2034	= { FOLLOW_STRING_in_violationMsg2034_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_48_in_classDeclaration2069  */
static	ANTLR3_BITWORD FOLLOW_48_in_classDeclaration2069_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_48_in_classDeclaration2069	= { FOLLOW_48_in_classDeclaration2069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_classDeclaration2084  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_classDeclaration2084_bits[]	= { ANTLR3_UINT64_LIT(0x0002002200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_classDeclaration2084	= { FOLLOW_IDENT_in_classDeclaration2084_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_49_in_classDeclaration2115  */
static	ANTLR3_BITWORD FOLLOW_49_in_classDeclaration2115_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_49_in_classDeclaration2115	= { FOLLOW_49_in_classDeclaration2115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_classDeclaration2119  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_classDeclaration2119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_classDeclaration2119	= { FOLLOW_IDENT_in_classDeclaration2119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_classBlock_in_classDeclaration2181  */
static	ANTLR3_BITWORD FOLLOW_classBlock_in_classDeclaration2181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_classBlock_in_classDeclaration2181	= { FOLLOW_classBlock_in_classDeclaration2181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_classDeclaration2208  */
static	ANTLR3_BITWORD FOLLOW_37_in_classDeclaration2208_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_classDeclaration2208	= { FOLLOW_37_in_classDeclaration2208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_classBlock2258  */
static	ANTLR3_BITWORD FOLLOW_33_in_classBlock2258_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_classBlock2258	= { FOLLOW_33_in_classBlock2258_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_classBlock2264  */
static	ANTLR3_BITWORD FOLLOW_33_in_classBlock2264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_classBlock2264	= { FOLLOW_33_in_classBlock2264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_componentTypeEntry_in_classBlock2266  */
static	ANTLR3_BITWORD FOLLOW_componentTypeEntry_in_classBlock2266_bits[]	= { ANTLR3_UINT64_LIT(0x000C000000000828) };
static  ANTLR3_BITSET_LIST FOLLOW_componentTypeEntry_in_classBlock2266	= { FOLLOW_componentTypeEntry_in_classBlock2266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_classVariable_in_componentTypeEntry2282  */
static	ANTLR3_BITWORD FOLLOW_classVariable_in_componentTypeEntry2282_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_classVariable_in_componentTypeEntry2282	= { FOLLOW_classVariable_in_componentTypeEntry2282_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructor_in_componentTypeEntry2288  */
static	ANTLR3_BITWORD FOLLOW_constructor_in_componentTypeEntry2288_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructor_in_componentTypeEntry2288	= { FOLLOW_constructor_in_componentTypeEntry2288_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tokenType_in_componentTypeEntry2294  */
static	ANTLR3_BITWORD FOLLOW_tokenType_in_componentTypeEntry2294_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tokenType_in_componentTypeEntry2294	= { FOLLOW_tokenType_in_componentTypeEntry2294_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARIABLE_in_classVariable2321  */
static	ANTLR3_BITWORD FOLLOW_VARIABLE_in_classVariable2321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VARIABLE_in_classVariable2321	= { FOLLOW_VARIABLE_in_classVariable2321_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_classVariable2344  */
static	ANTLR3_BITWORD FOLLOW_type_in_classVariable2344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_classVariable2344	= { FOLLOW_type_in_classVariable2344_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_classVariable2368  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_classVariable2368_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_classVariable2368	= { FOLLOW_IDENT_in_classVariable2368_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTRUCTOR_in_constructor2461  */
static	ANTLR3_BITWORD FOLLOW_CONSTRUCTOR_in_constructor2461_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTRUCTOR_in_constructor2461	= { FOLLOW_CONSTRUCTOR_in_constructor2461_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_constructor2468  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_constructor2468_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_constructor2468	= { FOLLOW_IDENT_in_constructor2468_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_constructor2474  */
static	ANTLR3_BITWORD FOLLOW_41_in_constructor2474_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_constructor2474	= { FOLLOW_41_in_constructor2474_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructorArgument_in_constructor2476  */
static	ANTLR3_BITWORD FOLLOW_constructorArgument_in_constructor2476_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000808) };
static  ANTLR3_BITSET_LIST FOLLOW_constructorArgument_in_constructor2476	= { FOLLOW_constructorArgument_in_constructor2476_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_constructor2485  */
static	ANTLR3_BITWORD FOLLOW_33_in_constructor2485_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_constructor2485	= { FOLLOW_33_in_constructor2485_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructorSuper_in_constructor2489  */
static	ANTLR3_BITWORD FOLLOW_constructorSuper_in_constructor2489_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_constructorSuper_in_constructor2489	= { FOLLOW_constructorSuper_in_constructor2489_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_in_constructor2505  */
static	ANTLR3_BITWORD FOLLOW_assignment_in_constructor2505_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_in_constructor2505	= { FOLLOW_assignment_in_constructor2505_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARIABLE_in_constructorArgument2531  */
static	ANTLR3_BITWORD FOLLOW_VARIABLE_in_constructorArgument2531_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VARIABLE_in_constructorArgument2531	= { FOLLOW_VARIABLE_in_constructorArgument2531_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_constructorArgument2538  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_constructorArgument2538_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_constructorArgument2538	= { FOLLOW_IDENT_in_constructorArgument2538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_constructorArgument2545  */
static	ANTLR3_BITWORD FOLLOW_type_in_constructorArgument2545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_constructorArgument2545	= { FOLLOW_type_in_constructorArgument2545_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_constructorSuper2575  */
static	ANTLR3_BITWORD FOLLOW_73_in_constructorSuper2575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_73_in_constructorSuper2575	= { FOLLOW_73_in_constructorSuper2575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableArgumentList_in_constructorSuper2580  */
static	ANTLR3_BITWORD FOLLOW_variableArgumentList_in_constructorSuper2580_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_variableArgumentList_in_constructorSuper2580	= { FOLLOW_variableArgumentList_in_constructorSuper2580_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_assignment2607  */
static	ANTLR3_BITWORD FOLLOW_43_in_assignment2607_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_assignment2607	= { FOLLOW_43_in_assignment2607_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_in_assignment2614  */
static	ANTLR3_BITWORD FOLLOW_qualified_in_assignment2614_bits[]	= { ANTLR3_UINT64_LIT(0x00006042000F0040), ANTLR3_UINT64_LIT(0x000003F000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_in_assignment2614	= { FOLLOW_qualified_in_assignment2614_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initializer_in_assignment2621  */
static	ANTLR3_BITWORD FOLLOW_initializer_in_assignment2621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_initializer_in_assignment2621	= { FOLLOW_initializer_in_assignment2621_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_tokenType2650  */
static	ANTLR3_BITWORD FOLLOW_set_in_tokenType2650_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_tokenType2650	= { FOLLOW_set_in_tokenType2650_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_tokenType2663  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_tokenType2663_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_tokenType2663	= { FOLLOW_IDENT_in_tokenType2663_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tokenStatements_in_tokenType2674  */
static	ANTLR3_BITWORD FOLLOW_tokenStatements_in_tokenType2674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_tokenStatements_in_tokenType2674	= { FOLLOW_tokenStatements_in_tokenType2674_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_tokenStatements2697  */
static	ANTLR3_BITWORD FOLLOW_33_in_tokenStatements2697_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_tokenStatements2697	= { FOLLOW_33_in_tokenStatements2697_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tokenParameter_in_tokenStatements2733  */
static	ANTLR3_BITWORD FOLLOW_tokenParameter_in_tokenStatements2733_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000001818) };
static  ANTLR3_BITSET_LIST FOLLOW_tokenParameter_in_tokenStatements2733	= { FOLLOW_tokenParameter_in_tokenStatements2733_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tokenParameterAssignment_in_tokenStatements2757  */
static	ANTLR3_BITWORD FOLLOW_tokenParameterAssignment_in_tokenStatements2757_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000001818) };
static  ANTLR3_BITSET_LIST FOLLOW_tokenParameterAssignment_in_tokenStatements2757	= { FOLLOW_tokenParameterAssignment_in_tokenStatements2757_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_standardConstraint_in_tokenStatements2779  */
static	ANTLR3_BITWORD FOLLOW_standardConstraint_in_tokenStatements2779_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000001818) };
static  ANTLR3_BITSET_LIST FOLLOW_standardConstraint_in_tokenStatements2779	= { FOLLOW_standardConstraint_in_tokenStatements2779_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enforceExpression_in_tokenStatements2802  */
static	ANTLR3_BITWORD FOLLOW_enforceExpression_in_tokenStatements2802_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000001818) };
static  ANTLR3_BITSET_LIST FOLLOW_enforceExpression_in_tokenStatements2802	= { FOLLOW_enforceExpression_in_tokenStatements2802_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableDeclarations_in_tokenParameter2886  */
static	ANTLR3_BITWORD FOLLOW_variableDeclarations_in_tokenParameter2886_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variableDeclarations_in_tokenParameter2886	= { FOLLOW_variableDeclarations_in_tokenParameter2886_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_in_tokenParameterAssignment2943  */
static	ANTLR3_BITWORD FOLLOW_assignment_in_tokenParameterAssignment2943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_in_tokenParameterAssignment2943	= { FOLLOW_assignment_in_tokenParameterAssignment2943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraintInstantiation_in_standardConstraint2995  */
static	ANTLR3_BITWORD FOLLOW_constraintInstantiation_in_standardConstraint2995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constraintInstantiation_in_standardConstraint2995	= { FOLLOW_constraintInstantiation_in_standardConstraint2995_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_52_in_rule3036  */
static	ANTLR3_BITWORD FOLLOW_52_in_rule3036_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_52_in_rule3036	= { FOLLOW_52_in_rule3036_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_rule3043  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_rule3043_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_rule3043	= { FOLLOW_IDENT_in_rule3043_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_rule3050  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_rule3050_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_rule3050	= { FOLLOW_IDENT_in_rule3050_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ruleBlock_in_rule3060  */
static	ANTLR3_BITWORD FOLLOW_ruleBlock_in_rule3060_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ruleBlock_in_rule3060	= { FOLLOW_ruleBlock_in_rule3060_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_ruleBlock3082  */
static	ANTLR3_BITWORD FOLLOW_33_in_ruleBlock3082_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_ruleBlock3082	= { FOLLOW_33_in_ruleBlock3082_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ruleStatement_in_ruleBlock3090  */
static	ANTLR3_BITWORD FOLLOW_ruleStatement_in_ruleBlock3090_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000001C18), ANTLR3_UINT64_LIT(0x0000000000001400) };
static  ANTLR3_BITSET_LIST FOLLOW_ruleStatement_in_ruleBlock3090	= { FOLLOW_ruleStatement_in_ruleBlock3090_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraintInstantiation_in_ruleStatement3117  */
static	ANTLR3_BITWORD FOLLOW_constraintInstantiation_in_ruleStatement3117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constraintInstantiation_in_ruleStatement3117	= { FOLLOW_constraintInstantiation_in_ruleStatement3117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enforceExpression_in_ruleStatement3129  */
static	ANTLR3_BITWORD FOLLOW_enforceExpression_in_ruleStatement3129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enforceExpression_in_ruleStatement3129	= { FOLLOW_enforceExpression_in_ruleStatement3129_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_in_ruleStatement3138  */
static	ANTLR3_BITWORD FOLLOW_assignment_in_ruleStatement3138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_in_ruleStatement3138	= { FOLLOW_assignment_in_ruleStatement3138_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableDeclarations_in_ruleStatement3147  */
static	ANTLR3_BITWORD FOLLOW_variableDeclarations_in_ruleStatement3147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variableDeclarations_in_ruleStatement3147	= { FOLLOW_variableDeclarations_in_ruleStatement3147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifStatement_in_ruleStatement3156  */
static	ANTLR3_BITWORD FOLLOW_ifStatement_in_ruleStatement3156_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ifStatement_in_ruleStatement3156	= { FOLLOW_ifStatement_in_ruleStatement3156_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_loopStatement_in_ruleStatement3165  */
static	ANTLR3_BITWORD FOLLOW_loopStatement_in_ruleStatement3165_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_loopStatement_in_ruleStatement3165	= { FOLLOW_loopStatement_in_ruleStatement3165_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_relation_in_ruleStatement3178  */
static	ANTLR3_BITWORD FOLLOW_relation_in_ruleStatement3178_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_relation_in_ruleStatement3178	= { FOLLOW_relation_in_ruleStatement3178_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_74_in_ifStatement3210  */
static	ANTLR3_BITWORD FOLLOW_74_in_ifStatement3210_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_74_in_ifStatement3210	= { FOLLOW_74_in_ifStatement3210_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guardExpression_in_ifStatement3217  */
static	ANTLR3_BITWORD FOLLOW_guardExpression_in_ifStatement3217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_guardExpression_in_ifStatement3217	= { FOLLOW_guardExpression_in_ifStatement3217_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ruleBlock_in_ifStatement3222  */
static	ANTLR3_BITWORD FOLLOW_ruleBlock_in_ifStatement3222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ruleBlock_in_ifStatement3222	= { FOLLOW_ruleBlock_in_ifStatement3222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ruleBlock_in_ifStatement3228  */
static	ANTLR3_BITWORD FOLLOW_ruleBlock_in_ifStatement3228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ruleBlock_in_ifStatement3228	= { FOLLOW_ruleBlock_in_ifStatement3228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guardRelop_in_guardExpression3273  */
static	ANTLR3_BITWORD FOLLOW_guardRelop_in_guardExpression3273_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_guardRelop_in_guardExpression3273	= { FOLLOW_guardRelop_in_guardExpression3273_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anyValue_in_guardExpression3279  */
static	ANTLR3_BITWORD FOLLOW_anyValue_in_guardExpression3279_bits[]	= { ANTLR3_UINT64_LIT(0x00006042000F0000), ANTLR3_UINT64_LIT(0x000003F000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_anyValue_in_guardExpression3279	= { FOLLOW_anyValue_in_guardExpression3279_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anyValue_in_guardExpression3283  */
static	ANTLR3_BITWORD FOLLOW_anyValue_in_guardExpression3283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_anyValue_in_guardExpression3283	= { FOLLOW_anyValue_in_guardExpression3283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anyValue_in_guardExpression3301  */
static	ANTLR3_BITWORD FOLLOW_anyValue_in_guardExpression3301_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_anyValue_in_guardExpression3301	= { FOLLOW_anyValue_in_guardExpression3301_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXPRESSION_RETURN_in_guardExpression3316  */
static	ANTLR3_BITWORD FOLLOW_EXPRESSION_RETURN_in_guardExpression3316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_EXPRESSION_RETURN_in_guardExpression3316	= { FOLLOW_EXPRESSION_RETURN_in_guardExpression3316_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expressionCleanReturn_in_guardExpression3320  */
static	ANTLR3_BITWORD FOLLOW_expressionCleanReturn_in_guardExpression3320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expressionCleanReturn_in_guardExpression3320	= { FOLLOW_expressionCleanReturn_in_guardExpression3320_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_guardRelop0  */
static	ANTLR3_BITWORD FOLLOW_set_in_guardRelop0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_guardRelop0	= { FOLLOW_set_in_guardRelop0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_76_in_loopStatement3410  */
static	ANTLR3_BITWORD FOLLOW_76_in_loopStatement3410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_76_in_loopStatement3410	= { FOLLOW_76_in_loopStatement3410_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_loopStatement3417  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_loopStatement3417_bits[]	= { ANTLR3_UINT64_LIT(0x00006042000F0000), ANTLR3_UINT64_LIT(0x000003F000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_loopStatement3417	= { FOLLOW_IDENT_in_loopStatement3417_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_in_loopStatement3424  */
static	ANTLR3_BITWORD FOLLOW_qualified_in_loopStatement3424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_in_loopStatement3424	= { FOLLOW_qualified_in_loopStatement3424_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ruleBlock_in_loopStatement3436  */
static	ANTLR3_BITWORD FOLLOW_ruleBlock_in_loopStatement3436_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ruleBlock_in_loopStatement3436	= { FOLLOW_ruleBlock_in_loopStatement3436_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_problemStmtType_in_problemStmt3483  */
static	ANTLR3_BITWORD FOLLOW_problemStmtType_in_problemStmt3483_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_problemStmtType_in_problemStmt3483	= { FOLLOW_problemStmtType_in_problemStmt3483_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicateInstanceList_in_problemStmt3485  */
static	ANTLR3_BITWORD FOLLOW_predicateInstanceList_in_problemStmt3485_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_predicateInstanceList_in_problemStmt3485	= { FOLLOW_predicateInstanceList_in_problemStmt3485_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_problemStmtType0  */
static	ANTLR3_BITWORD FOLLOW_set_in_problemStmtType0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_problemStmtType0	= { FOLLOW_set_in_problemStmtType0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TOKEN_RELATION_in_relation3620  */
static	ANTLR3_BITWORD FOLLOW_TOKEN_RELATION_in_relation3620_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TOKEN_RELATION_in_relation3620	= { FOLLOW_TOKEN_RELATION_in_relation3620_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_relation3628  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_relation3628_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000FFFFFE000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_relation3628	= { FOLLOW_IDENT_in_relation3628_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_temporalRelation_in_relation3639  */
static	ANTLR3_BITWORD FOLLOW_temporalRelation_in_relation3639_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_temporalRelation_in_relation3639	= { FOLLOW_temporalRelation_in_relation3639_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicateInstanceList_in_relation3647  */
static	ANTLR3_BITWORD FOLLOW_predicateInstanceList_in_relation3647_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_predicateInstanceList_in_relation3647	= { FOLLOW_predicateInstanceList_in_relation3647_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_predicateInstanceList3669  */
static	ANTLR3_BITWORD FOLLOW_41_in_predicateInstanceList3669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_predicateInstanceList3669	= { FOLLOW_41_in_predicateInstanceList3669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicateInstance_in_predicateInstanceList3677  */
static	ANTLR3_BITWORD FOLLOW_predicateInstance_in_predicateInstanceList3677_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000208) };
static  ANTLR3_BITSET_LIST FOLLOW_predicateInstance_in_predicateInstanceList3677	= { FOLLOW_predicateInstance_in_predicateInstanceList3677_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_predicateInstanceList3693  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_predicateInstanceList3693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_predicateInstanceList3693	= { FOLLOW_IDENT_in_predicateInstanceList3693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PREDICATE_INSTANCE_in_predicateInstance3728  */
static	ANTLR3_BITWORD FOLLOW_PREDICATE_INSTANCE_in_predicateInstance3728_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PREDICATE_INSTANCE_in_predicateInstance3728	= { FOLLOW_PREDICATE_INSTANCE_in_predicateInstance3728_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualifiedToken_in_predicateInstance3730  */
static	ANTLR3_BITWORD FOLLOW_qualifiedToken_in_predicateInstance3730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010008) };
static  ANTLR3_BITSET_LIST FOLLOW_qualifiedToken_in_predicateInstance3730	= { FOLLOW_qualifiedToken_in_predicateInstance3730_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_predicateInstance3736  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_predicateInstance3736_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_predicateInstance3736	= { FOLLOW_IDENT_in_predicateInstance3736_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_qualifiedString3779  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_qualifiedString3779_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_qualifiedString3779	= { FOLLOW_identifier_in_qualifiedString3779_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_qualifiedString3810  */
static	ANTLR3_BITWORD FOLLOW_46_in_qualifiedString3810_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_46_in_qualifiedString3810	= { FOLLOW_46_in_qualifiedString3810_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualifiedString_in_qualifiedString3814  */
static	ANTLR3_BITWORD FOLLOW_qualifiedString_in_qualifiedString3814_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_qualifiedString_in_qualifiedString3814	= { FOLLOW_qualifiedString_in_qualifiedString3814_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_qualifiedString3836  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_qualifiedString3836_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_qualifiedString3836	= { FOLLOW_IDENT_in_qualifiedString3836_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualifiedString_in_qualified3887  */
static	ANTLR3_BITWORD FOLLOW_qualifiedString_in_qualified3887_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qualifiedString_in_qualified3887	= { FOLLOW_qualifiedString_in_qualified3887_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualifiedString_in_qualifiedToken3926  */
static	ANTLR3_BITWORD FOLLOW_qualifiedString_in_qualifiedToken3926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qualifiedString_in_qualifiedToken3926	= { FOLLOW_qualifiedString_in_qualifiedToken3926_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_temporalRelation0  */
static	ANTLR3_BITWORD FOLLOW_set_in_temporalRelation0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_temporalRelation0	= { FOLLOW_set_in_temporalRelation0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_METHOD_CALL_in_methodInvocation4403  */
static	ANTLR3_BITWORD FOLLOW_METHOD_CALL_in_methodInvocation4403_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_METHOD_CALL_in_methodInvocation4403	= { FOLLOW_METHOD_CALL_in_methodInvocation4403_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_in_methodInvocation4407  */
static	ANTLR3_BITWORD FOLLOW_qualified_in_methodInvocation4407_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000), ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_in_methodInvocation4407	= { FOLLOW_qualified_in_methodInvocation4407_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_methodName_in_methodInvocation4411  */
static	ANTLR3_BITWORD FOLLOW_methodName_in_methodInvocation4411_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_methodName_in_methodInvocation4411	= { FOLLOW_methodName_in_methodInvocation4411_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableArgumentList_in_methodInvocation4413  */
static	ANTLR3_BITWORD FOLLOW_variableArgumentList_in_methodInvocation4413_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_variableArgumentList_in_methodInvocation4413	= { FOLLOW_variableArgumentList_in_methodInvocation4413_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSE_in_methodInvocation4431  */
static	ANTLR3_BITWORD FOLLOW_CLOSE_in_methodInvocation4431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSE_in_methodInvocation4431	= { FOLLOW_CLOSE_in_methodInvocation4431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSE_in_methodInvocation4433  */
static	ANTLR3_BITWORD FOLLOW_CLOSE_in_methodInvocation4433_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSE_in_methodInvocation4433	= { FOLLOW_CLOSE_in_methodInvocation4433_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_methodName0  */
static	ANTLR3_BITWORD FOLLOW_set_in_methodName0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_methodName0	= { FOLLOW_set_in_methodName0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cexpression_in_cexpressionList4473  */
static	ANTLR3_BITWORD FOLLOW_cexpression_in_cexpressionList4473_bits[]	= { ANTLR3_UINT64_LIT(0xC0006042000F4002), ANTLR3_UINT64_LIT(0x000003F0000001FF) };
static  ANTLR3_BITSET_LIST FOLLOW_cexpression_in_cexpressionList4473	= { FOLLOW_cexpression_in_cexpressionList4473_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cexprOp_in_cexpression4501  */
static	ANTLR3_BITWORD FOLLOW_cexprOp_in_cexpression4501_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_cexprOp_in_cexpression4501	= { FOLLOW_cexprOp_in_cexpression4501_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cexpression_in_cexpression4505  */
static	ANTLR3_BITWORD FOLLOW_cexpression_in_cexpression4505_bits[]	= { ANTLR3_UINT64_LIT(0xC0006042000F4008), ANTLR3_UINT64_LIT(0x000003F0000001FF) };
static  ANTLR3_BITSET_LIST FOLLOW_cexpression_in_cexpression4505	= { FOLLOW_cexpression_in_cexpression4505_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cexpression_in_cexpression4509  */
static	ANTLR3_BITWORD FOLLOW_cexpression_in_cexpression4509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_cexpression_in_cexpression4509	= { FOLLOW_cexpression_in_cexpression4509_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anyValue_in_cexpression4527  */
static	ANTLR3_BITWORD FOLLOW_anyValue_in_cexpression4527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_anyValue_in_cexpression4527	= { FOLLOW_anyValue_in_cexpression4527_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNCTION_CALL_in_cexpression4543  */
static	ANTLR3_BITWORD FOLLOW_FUNCTION_CALL_in_cexpression4543_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNCTION_CALL_in_cexpression4543	= { FOLLOW_FUNCTION_CALL_in_cexpression4543_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_cexpression4547  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_cexpression4547_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_cexpression4547	= { FOLLOW_IDENT_in_cexpression4547_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_cexpression4550  */
static	ANTLR3_BITWORD FOLLOW_41_in_cexpression4550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_cexpression4550	= { FOLLOW_41_in_cexpression4550_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cexpressionList_in_cexpression4552  */
static	ANTLR3_BITWORD FOLLOW_cexpressionList_in_cexpression4552_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_cexpressionList_in_cexpression4552	= { FOLLOW_cexpressionList_in_cexpression4552_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_cexprOp0  */
static	ANTLR3_BITWORD FOLLOW_set_in_cexprOp0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_cexprOp0	= { FOLLOW_set_in_cexprOp0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXPRESSION_ENFORCE_in_enforceExpression4647  */
static	ANTLR3_BITWORD FOLLOW_EXPRESSION_ENFORCE_in_enforceExpression4647_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_EXPRESSION_ENFORCE_in_enforceExpression4647	= { FOLLOW_EXPRESSION_ENFORCE_in_enforceExpression4647_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cexpression_in_enforceExpression4651  */
static	ANTLR3_BITWORD FOLLOW_cexpression_in_enforceExpression4651_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080008) };
static  ANTLR3_BITSET_LIST FOLLOW_cexpression_in_enforceExpression4651	= { FOLLOW_cexpression_in_enforceExpression4651_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_violationMsg_in_enforceExpression4653  */
static	ANTLR3_BITWORD FOLLOW_violationMsg_in_enforceExpression4653_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_violationMsg_in_enforceExpression4653	= { FOLLOW_violationMsg_in_enforceExpression4653_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cexpression_in_expressionCleanReturn4681  */
static	ANTLR3_BITWORD FOLLOW_cexpression_in_expressionCleanReturn4681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cexpression_in_expressionCleanReturn4681	= { FOLLOW_cexpression_in_expressionCleanReturn4681_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start nddl
 * NDDL/base/antlr/NDDL3Tree.g:81:1: nddl : ^( NDDL ( (child= classDeclaration | child= enumDefinition | child= typeDefinition | child= variableDeclarations | child= assignment | child= constraintInstantiation | child= enforceExpression | child= allocation[NULL] | child= rule | child= problemStmt | child= relation | child= methodInvocation ) )* ) ;
 */
static void
nddl(pNDDL3Tree ctx)
{   
    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:82:2: ( ^( NDDL ( (child= classDeclaration | child= enumDefinition | child= typeDefinition | child= variableDeclarations | child= assignment | child= constraintInstantiation | child= enforceExpression | child= allocation[NULL] | child= rule | child= problemStmt | child= relation | child= methodInvocation ) )* ) )
        // NDDL/base/antlr/NDDL3Tree.g:82:4: ^( NDDL ( (child= classDeclaration | child= enumDefinition | child= typeDefinition | child= variableDeclarations | child= assignment | child= constraintInstantiation | child= enforceExpression | child= allocation[NULL] | child= rule | child= problemStmt | child= relation | child= methodInvocation ) )* )
        {
             MATCHT(NDDL, &FOLLOW_NDDL_in_nddl70); 
            if  (HASEXCEPTION())
            {
                goto rulenddlEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulenddlEx;
                }


                // NDDL/base/antlr/NDDL3Tree.g:83:3: ( (child= classDeclaration | child= enumDefinition | child= typeDefinition | child= variableDeclarations | child= assignment | child= constraintInstantiation | child= enforceExpression | child= allocation[NULL] | child= rule | child= problemStmt | child= relation | child= methodInvocation ) )*

                for (;;)
                {
                    int alt2=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA2_0 = LA(1);
                        if ( (LA2_0 == CONSTRAINT_INSTANTIATION || ((LA2_0 >= CONSTRUCTOR_INVOCATION) && (LA2_0 <= METHOD_CALL)) || ((LA2_0 >= TOKEN_RELATION) && (LA2_0 <= EXPRESSION_ENFORCE)) || LA2_0 == CLOSE || LA2_0 == 32 || LA2_0 == 36 || LA2_0 == 43 || LA2_0 == 48 || LA2_0 == 52 || ((LA2_0 >= 57) && (LA2_0 <= 59))) ) 
                        {
                            alt2=1;
                        }

                    }
                    switch (alt2) 
                    {
                	case 1:
                	    // NDDL/base/antlr/NDDL3Tree.g:83:5: (child= classDeclaration | child= enumDefinition | child= typeDefinition | child= variableDeclarations | child= assignment | child= constraintInstantiation | child= enforceExpression | child= allocation[NULL] | child= rule | child= problemStmt | child= relation | child= methodInvocation )
                	    {
                	        {

                	            		     // debugMsg("NddlInterpreter:nddl","Line:" << LEXER->getLine(LEXER)); 
                	            		  
                	        }

                	        // NDDL/base/antlr/NDDL3Tree.g:86:5: (child= classDeclaration | child= enumDefinition | child= typeDefinition | child= variableDeclarations | child= assignment | child= constraintInstantiation | child= enforceExpression | child= allocation[NULL] | child= rule | child= problemStmt | child= relation | child= methodInvocation )
                	        {
                	            int alt1=12;
                	            switch ( LA(1) ) 
                	            {
                	            case 48:
                	            	{
                	            		alt1=1;
                	            	}
                	                break;
                	            case 32:
                	            	{
                	            		alt1=2;
                	            	}
                	                break;
                	            case 36:
                	            	{
                	            		alt1=3;
                	            	}
                	                break;
                	            case VARIABLE:
                	            	{
                	            		alt1=4;
                	            	}
                	                break;
                	            case 43:
                	            	{
                	            		alt1=5;
                	            	}
                	                break;
                	            case CONSTRAINT_INSTANTIATION:
                	            	{
                	            		alt1=6;
                	            	}
                	                break;
                	            case EXPRESSION_ENFORCE:
                	            	{
                	            		alt1=7;
                	            	}
                	                break;
                	            case CONSTRUCTOR_INVOCATION:
                	            	{
                	            		alt1=8;
                	            	}
                	                break;
                	            case 52:
                	            	{
                	            		alt1=9;
                	            	}
                	                break;
                	            case 57:
                	            case 58:
                	            case 59:
                	            	{
                	            		alt1=10;
                	            	}
                	                break;
                	            case TOKEN_RELATION:
                	            	{
                	            		alt1=11;
                	            	}
                	                break;
                	            case METHOD_CALL:
                	            case CLOSE:
                	            	{
                	            		alt1=12;
                	            	}
                	                break;

                	            default:
                	                CONSTRUCTEX();
                	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                	                EXCEPTION->message      = (void *)"";
                	                EXCEPTION->decisionNum  = 1;
                	                EXCEPTION->state        = 0;


                	                goto rulenddlEx;
                	            }

                	            switch (alt1) 
                	            {
                	        	case 1:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:86:7: child= classDeclaration
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_classDeclaration_in_nddl86);
                	        	        child=classDeclaration(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 2:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:87:13: child= enumDefinition
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_enumDefinition_in_nddl102);
                	        	        child=enumDefinition(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 3:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:88:7: child= typeDefinition
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_typeDefinition_in_nddl112);
                	        	        child=typeDefinition(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 4:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:89:7: child= variableDeclarations
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_variableDeclarations_in_nddl122);
                	        	        child=variableDeclarations(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 5:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:90:7: child= assignment
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_assignment_in_nddl132);
                	        	        child=assignment(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 6:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:91:7: child= constraintInstantiation
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_constraintInstantiation_in_nddl142);
                	        	        child=constraintInstantiation(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 7:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:92:7: child= enforceExpression
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_enforceExpression_in_nddl152);
                	        	        child=enforceExpression(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 8:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:93:7: child= allocation[NULL]
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_allocation_in_nddl162);
                	        	        child=allocation(ctx, NULL);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 9:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:94:7: child= rule
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_rule_in_nddl173);
                	        	        child=rule(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 10:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:95:7: child= problemStmt
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_problemStmt_in_nddl183);
                	        	        child=problemStmt(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 11:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:96:7: child= relation
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_relation_in_nddl193);
                	        	        child=relation(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 12:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:97:7: child= methodInvocation
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_methodInvocation_in_nddl203);
                	        	        child=methodInvocation(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;

                	            }
                	        }
                	        {

                	            		      if (child != NULL) { 
                	            		          debugMsg("NddlInterpreter:nddl","Evaluating:" << child->toString());
                	                              evalExpr(CTX,child);

                	            		          // TODO!!: systematically deal with memory mgmt for all Exprs.
                	            		          delete child;
                	            		          child = NULL; 
                	            		          
                	                              CTX->SymbolTable->getPlanDatabase()->getConstraintEngine()->propagate();
                	            		      }
                	                          CTX->SymbolTable->getPlanDatabase()->getConstraintEngine()->propagate();
                	                          
                	            		  
                	        }

                	    }
                	    break;

                	default:
                	    goto loop2;	/* break out of the loop */
                	    break;
                    }
                }
                loop2: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulenddlEx;
                }

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenddlEx; /* Prevent compiler warnings */
    rulenddlEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end nddl */

/** 
 * $ANTLR start enumDefinition
 * NDDL/base/antlr/NDDL3Tree.g:118:1: enumDefinition returns [Expr* result] : ^( 'enum' name= IDENT enumValues[values] ) ;
 */
static Expr*
enumDefinition(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    name;

    /* Initialize rule variables
     */



        std::vector<std::string> values;

    name       = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:122:5: ( ^( 'enum' name= IDENT enumValues[values] ) )
        // NDDL/base/antlr/NDDL3Tree.g:122:9: ^( 'enum' name= IDENT enumValues[values] )
        {
             MATCHT(32, &FOLLOW_32_in_enumDefinition255); 
            if  (HASEXCEPTION())
            {
                goto ruleenumDefinitionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleenumDefinitionEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_enumDefinition259); 
            if  (HASEXCEPTION())
            {
                goto ruleenumDefinitionEx;
            }

            FOLLOWPUSH(FOLLOW_enumValues_in_enumDefinition261);
            enumValues(ctx, values);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleenumDefinitionEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleenumDefinitionEx;
            }

            {

                            const char* enumName = c_str((name->getText(name))->chars);
                            result = new ExprEnumdef(enumName,values);
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleenumDefinitionEx; /* Prevent compiler warnings */
    ruleenumDefinitionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end enumDefinition */

/** 
 * $ANTLR start enumValues
 * NDDL/base/antlr/NDDL3Tree.g:129:1: enumValues[std::vector<std::string>& values] : ^( '{' (v= IDENT )+ ) ;
 */
static void
enumValues(pNDDL3Tree ctx, std::vector<std::string>& values)
{   
    pANTLR3_BASE_TREE    v;

    /* Initialize rule variables
     */


    v       = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:130:5: ( ^( '{' (v= IDENT )+ ) )
        // NDDL/base/antlr/NDDL3Tree.g:130:13: ^( '{' (v= IDENT )+ )
        {
             MATCHT(33, &FOLLOW_33_in_enumValues298); 
            if  (HASEXCEPTION())
            {
                goto ruleenumValuesEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleenumValuesEx;
            }

            // NDDL/base/antlr/NDDL3Tree.g:130:19: (v= IDENT )+
            {
                int cnt3=0;

                for (;;)
                {
                    int alt3=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA3_0 = LA(1);
            	    if ( (LA3_0 == IDENT) ) 
            	    {
            	        alt3=1;
            	    }

            	}
            	switch (alt3) 
            	{
            	    case 1:
            	        // NDDL/base/antlr/NDDL3Tree.g:130:20: v= IDENT
            	        {
            	            v = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_enumValues303); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleenumValuesEx;
            	            }

            	            {
            	                values.push_back(c_str((v->getText(v))->chars));
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt3 >= 1 )
            		{
            		    goto loop3;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleenumValuesEx;
            	}
            	cnt3++;
                }
                loop3: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleenumValuesEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleenumValuesEx; /* Prevent compiler warnings */
    ruleenumValuesEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end enumValues */

/** 
 * $ANTLR start typeDefinition
 * NDDL/base/antlr/NDDL3Tree.g:133:1: typeDefinition returns [Expr* result] : ^( 'typedef' name= IDENT dataType= type domain= baseDomain[dataType] ) ;
 */
static Expr*
typeDefinition(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    name;
    DataType* dataType;
    #undef	RETURN_TYPE_dataType
    #define	RETURN_TYPE_dataType DataType*

    Domain* domain;
    #undef	RETURN_TYPE_domain
    #define	RETURN_TYPE_domain Domain*

    /* Initialize rule variables
     */


    name       = NULL;
    dataType = NULL;
    domain = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:134:5: ( ^( 'typedef' name= IDENT dataType= type domain= baseDomain[dataType] ) )
        // NDDL/base/antlr/NDDL3Tree.g:134:9: ^( 'typedef' name= IDENT dataType= type domain= baseDomain[dataType] )
        {
             MATCHT(36, &FOLLOW_36_in_typeDefinition351); 
            if  (HASEXCEPTION())
            {
                goto ruletypeDefinitionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletypeDefinitionEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_typeDefinition367); 
            if  (HASEXCEPTION())
            {
                goto ruletypeDefinitionEx;
            }

            FOLLOWPUSH(FOLLOW_type_in_typeDefinition383);
            dataType=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletypeDefinitionEx;
            }

            FOLLOWPUSH(FOLLOW_baseDomain_in_typeDefinition390);
            domain=baseDomain(ctx, dataType);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletypeDefinitionEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletypeDefinitionEx;
            }

            {

                            const char* newName = c_str((name->getText(name))->chars);
                	        result = new ExprTypedef(dataType->getId(),newName,domain);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletypeDefinitionEx; /* Prevent compiler warnings */
    ruletypeDefinitionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end typeDefinition */

/** 
 * $ANTLR start type
 * NDDL/base/antlr/NDDL3Tree.g:145:1: type returns [DataType* result] : (name= 'int' | name= 'float' | name= 'bool' | name= 'string' | name= IDENT ) ;
 */
static DataType*
type(pNDDL3Tree ctx)
{   
    DataType* result = NULL;

    pANTLR3_BASE_TREE    name;

    /* Initialize rule variables
     */


    name       = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:146:5: ( (name= 'int' | name= 'float' | name= 'bool' | name= 'string' | name= IDENT ) )
        // NDDL/base/antlr/NDDL3Tree.g:146:9: (name= 'int' | name= 'float' | name= 'bool' | name= 'string' | name= IDENT )
        {

            // NDDL/base/antlr/NDDL3Tree.g:146:9: (name= 'int' | name= 'float' | name= 'bool' | name= 'string' | name= IDENT )
            {
                int alt4=5;
                switch ( LA(1) ) 
                {
                case 53:
                	{
                		alt4=1;
                	}
                    break;
                case 54:
                	{
                		alt4=2;
                	}
                    break;
                case 55:
                	{
                		alt4=3;
                	}
                    break;
                case 56:
                	{
                		alt4=4;
                	}
                    break;
                case IDENT:
                	{
                		alt4=5;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 4;
                    EXCEPTION->state        = 0;


                    goto ruletypeEx;
                }

                switch (alt4) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:146:13: name= 'int'
            	    {
            	        name = (pANTLR3_BASE_TREE) MATCHT(53, &FOLLOW_53_in_type438); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // NDDL/base/antlr/NDDL3Tree.g:147:13: name= 'float'
            	    {
            	        name = (pANTLR3_BASE_TREE) MATCHT(54, &FOLLOW_54_in_type454); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // NDDL/base/antlr/NDDL3Tree.g:148:13: name= 'bool'
            	    {
            	        name = (pANTLR3_BASE_TREE) MATCHT(55, &FOLLOW_55_in_type470); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeEx;
            	        }


            	    }
            	    break;
            	case 4:
            	    // NDDL/base/antlr/NDDL3Tree.g:149:13: name= 'string'
            	    {
            	        name = (pANTLR3_BASE_TREE) MATCHT(56, &FOLLOW_56_in_type486); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeEx;
            	        }


            	    }
            	    break;
            	case 5:
            	    // NDDL/base/antlr/NDDL3Tree.g:150:13: name= IDENT
            	    {
            	        name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_type502); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                            const char* nameStr = c_str((name->getText(name))->chars);
                            DataTypeId dt = CTX->SymbolTable->getDataType(nameStr);
                            
                            if (dt.isId()) 
                                result = (DataType*)dt;
                            else 
                                reportSemanticError(CTX,"Unknown data type:"+std::string(nameStr));           
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletypeEx; /* Prevent compiler warnings */
    ruletypeEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end type */

/** 
 * $ANTLR start baseDomain
 * NDDL/base/antlr/NDDL3Tree.g:163:1: baseDomain[const DataType* baseType] returns [Domain* result] : child= baseDomainValues ;
 */
static Domain*
baseDomain(pNDDL3Tree ctx, const DataType* baseType)
{   
    Domain* result = NULL;

    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:164:5: (child= baseDomainValues )
        // NDDL/base/antlr/NDDL3Tree.g:164:9: child= baseDomainValues
        {
            FOLLOWPUSH(FOLLOW_baseDomainValues_in_baseDomain556);
            child=baseDomainValues(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebaseDomainEx;
            }

            {

                        DataRef data=evalExpr(CTX,child); 
                        ConstrainedVariableId value = data.getValue();
                        if (!baseType->isAssignableFrom(value->getDataType())) {
                            reportSemanticError(CTX,
                                "Can't assign "+value->toString()+" to "+baseType->getName().toString());
                        }
                       
                        result = value->lastDomain().copy(); 
                        delete child;
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulebaseDomainEx; /* Prevent compiler warnings */
    rulebaseDomainEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end baseDomain */

/** 
 * $ANTLR start baseDomainValues
 * NDDL/base/antlr/NDDL3Tree.g:178:1: baseDomainValues returns [Expr* result] : (child= numericInterval | child= valueSet ) ;
 */
static Expr*
baseDomainValues(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:179:5: ( (child= numericInterval | child= valueSet ) )
        // NDDL/base/antlr/NDDL3Tree.g:179:9: (child= numericInterval | child= valueSet )
        {

            // NDDL/base/antlr/NDDL3Tree.g:179:9: (child= numericInterval | child= valueSet )
            {
                int alt5=2;

                {
                    int LA5_0 = LA(1);
                    if ( (LA5_0 == 38) ) 
                    {
                        alt5=1;
                    }
                    else if ( (LA5_0 == 33) ) 
                    {
                        alt5=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 5;
                        EXCEPTION->state        = 0;


                        goto rulebaseDomainValuesEx;
                    }
                }
                switch (alt5) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:179:11: child= numericInterval
            	    {
            	        FOLLOWPUSH(FOLLOW_numericInterval_in_baseDomainValues604);
            	        child=numericInterval(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebaseDomainValuesEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // NDDL/base/antlr/NDDL3Tree.g:180:11: child= valueSet
            	    {
            	        FOLLOWPUSH(FOLLOW_valueSet_in_baseDomainValues618);
            	        child=valueSet(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebaseDomainValuesEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                            result = child;
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulebaseDomainValuesEx; /* Prevent compiler warnings */
    rulebaseDomainValuesEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end baseDomainValues */

/** 
 * $ANTLR start variableDeclarations
 * NDDL/base/antlr/NDDL3Tree.g:187:1: variableDeclarations returns [ExprList* result] : ^( VARIABLE dataType= type (child= variableInitialization[dataType->getId()] )+ ) ;
 */
static ExprList*
variableDeclarations(pNDDL3Tree ctx)
{   
    ExprList* result = NULL;

    DataType* dataType;
    #undef	RETURN_TYPE_dataType
    #define	RETURN_TYPE_dataType DataType*

    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */



        result = new ExprList();    

    dataType = NULL;
    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:191:5: ( ^( VARIABLE dataType= type (child= variableInitialization[dataType->getId()] )+ ) )
        // NDDL/base/antlr/NDDL3Tree.g:191:9: ^( VARIABLE dataType= type (child= variableInitialization[dataType->getId()] )+ )
        {
             MATCHT(VARIABLE, &FOLLOW_VARIABLE_in_variableDeclarations672); 
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationsEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationsEx;
            }

            FOLLOWPUSH(FOLLOW_type_in_variableDeclarations689);
            dataType=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationsEx;
            }

            // NDDL/base/antlr/NDDL3Tree.g:193:13: (child= variableInitialization[dataType->getId()] )+
            {
                int cnt6=0;

                for (;;)
                {
                    int alt6=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA6_0 = LA(1);
            	    if ( (LA6_0 == IDENT || LA6_0 == 43) ) 
            	    {
            	        alt6=1;
            	    }

            	}
            	switch (alt6) 
            	{
            	    case 1:
            	        // NDDL/base/antlr/NDDL3Tree.g:193:14: child= variableInitialization[dataType->getId()]
            	        {
            	            FOLLOWPUSH(FOLLOW_variableInitialization_in_variableDeclarations707);
            	            child=variableInitialization(ctx, dataType->getId());

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulevariableDeclarationsEx;
            	            }

            	            {

            	                                result->addChild(child);
            	                            
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt6 >= 1 )
            		{
            		    goto loop6;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulevariableDeclarationsEx;
            	}
            	cnt6++;
                }
                loop6: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationsEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevariableDeclarationsEx; /* Prevent compiler warnings */
    rulevariableDeclarationsEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end variableDeclarations */

/** 
 * $ANTLR start variableInitialization
 * NDDL/base/antlr/NDDL3Tree.g:201:1: variableInitialization[const DataTypeId& dataType] returns [Expr* result] : (name= IDENT | ^( '=' name= IDENT initExpr= initializer[varName] ) ) ;
 */
static Expr*
variableInitialization(pNDDL3Tree ctx, const DataTypeId& dataType)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    name;
    Expr* initExpr;
    #undef	RETURN_TYPE_initExpr
    #define	RETURN_TYPE_initExpr Expr*

    /* Initialize rule variables
     */



       const char* varName; 

    name       = NULL;
    initExpr = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:205:5: ( (name= IDENT | ^( '=' name= IDENT initExpr= initializer[varName] ) ) )
        // NDDL/base/antlr/NDDL3Tree.g:205:9: (name= IDENT | ^( '=' name= IDENT initExpr= initializer[varName] ) )
        {

            // NDDL/base/antlr/NDDL3Tree.g:205:9: (name= IDENT | ^( '=' name= IDENT initExpr= initializer[varName] ) )
            {
                int alt7=2;

                {
                    int LA7_0 = LA(1);
                    if ( (LA7_0 == IDENT) ) 
                    {
                        alt7=1;
                    }
                    else if ( (LA7_0 == 43) ) 
                    {
                        alt7=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 7;
                        EXCEPTION->state        = 0;


                        goto rulevariableInitializationEx;
                    }
                }
                switch (alt7) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:205:13: name= IDENT
            	    {
            	        name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_variableInitialization790); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableInitializationEx;
            	        }

            	        {
            	             varName = c_str((name->getText(name))->chars); 
            	        }

            	    }
            	    break;
            	case 2:
            	    // NDDL/base/antlr/NDDL3Tree.g:206:13: ^( '=' name= IDENT initExpr= initializer[varName] )
            	    {
            	         MATCHT(43, &FOLLOW_43_in_variableInitialization807); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableInitializationEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableInitializationEx;
            	        }

            	        name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_variableInitialization811); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableInitializationEx;
            	        }

            	        {
            	             varName = c_str((name->getText(name))->chars); 
            	        }
            	        FOLLOWPUSH(FOLLOW_initializer_in_variableInitialization818);
            	        initExpr=initializer(ctx, varName);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableInitializationEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableInitializationEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                            // TODO: type check initExpr;
                            result = new ExprVarDeclaration(
                                 varName,
                                 dataType,
                                 initExpr,
                                 true // canBeSpecified
                            ); 
                            CTX->SymbolTable->addLocalVar(varName,dataType);
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevariableInitializationEx; /* Prevent compiler warnings */
    rulevariableInitializationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end variableInitialization */

/** 
 * $ANTLR start initializer
 * NDDL/base/antlr/NDDL3Tree.g:220:1: initializer[const char* varName] returns [Expr* result] : (child= anyValue | child= allocation[varName] ) ;
 */
static Expr*
initializer(pNDDL3Tree ctx, const char* varName)
{   
    Expr* result = NULL;

    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:221:5: ( (child= anyValue | child= allocation[varName] ) )
        // NDDL/base/antlr/NDDL3Tree.g:221:9: (child= anyValue | child= allocation[varName] )
        {

            // NDDL/base/antlr/NDDL3Tree.g:221:9: (child= anyValue | child= allocation[varName] )
            {
                int alt8=2;

                {
                    int LA8_0 = LA(1);
                    if ( (((LA8_0 >= IDENT) && (LA8_0 <= STRING)) || LA8_0 == 33 || LA8_0 == 38 || ((LA8_0 >= 45) && (LA8_0 <= 46)) || ((LA8_0 >= 100) && (LA8_0 <= 105))) ) 
                    {
                        alt8=1;
                    }
                    else if ( (LA8_0 == CONSTRUCTOR_INVOCATION) ) 
                    {
                        alt8=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 8;
                        EXCEPTION->state        = 0;


                        goto ruleinitializerEx;
                    }
                }
                switch (alt8) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:221:13: child= anyValue
            	    {
            	        FOLLOWPUSH(FOLLOW_anyValue_in_initializer881);
            	        child=anyValue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinitializerEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // NDDL/base/antlr/NDDL3Tree.g:222:13: child= allocation[varName]
            	    {
            	        FOLLOWPUSH(FOLLOW_allocation_in_initializer898);
            	        child=allocation(ctx, varName);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinitializerEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                            result = child;
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleinitializerEx; /* Prevent compiler warnings */
    ruleinitializerEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end initializer */

/** 
 * $ANTLR start anyValue
 * NDDL/base/antlr/NDDL3Tree.g:229:1: anyValue returns [Expr* result] : (child= literalValue | child= baseDomainValues | child= qualified ) ;
 */
static Expr*
anyValue(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:230:5: ( (child= literalValue | child= baseDomainValues | child= qualified ) )
        // NDDL/base/antlr/NDDL3Tree.g:230:9: (child= literalValue | child= baseDomainValues | child= qualified )
        {

            // NDDL/base/antlr/NDDL3Tree.g:230:9: (child= literalValue | child= baseDomainValues | child= qualified )
            {
                int alt9=3;
                switch ( LA(1) ) 
                {
                case INT:
                case FLOAT:
                case STRING:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                	{
                		alt9=1;
                	}
                    break;
                case 33:
                case 38:
                	{
                		alt9=2;
                	}
                    break;
                case IDENT:
                case 45:
                case 46:
                	{
                		alt9=3;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 9;
                    EXCEPTION->state        = 0;


                    goto ruleanyValueEx;
                }

                switch (alt9) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:230:13: child= literalValue
            	    {
            	        FOLLOWPUSH(FOLLOW_literalValue_in_anyValue948);
            	        child=literalValue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleanyValueEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // NDDL/base/antlr/NDDL3Tree.g:231:13: child= baseDomainValues
            	    {
            	        FOLLOWPUSH(FOLLOW_baseDomainValues_in_anyValue964);
            	        child=baseDomainValues(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleanyValueEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // NDDL/base/antlr/NDDL3Tree.g:232:13: child= qualified
            	    {
            	        FOLLOWPUSH(FOLLOW_qualified_in_anyValue980);
            	        child=qualified(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleanyValueEx;
            	        }


            	    }
            	    break;

                }
            }
            {
                 
                            result = child;
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleanyValueEx; /* Prevent compiler warnings */
    ruleanyValueEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end anyValue */

/** 
 * $ANTLR start setElement
 * NDDL/base/antlr/NDDL3Tree.g:239:1: setElement returns [Expr* result] : (child= literalValue | child= qualified ) ;
 */
static Expr*
setElement(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:240:5: ( (child= literalValue | child= qualified ) )
        // NDDL/base/antlr/NDDL3Tree.g:240:9: (child= literalValue | child= qualified )
        {

            // NDDL/base/antlr/NDDL3Tree.g:240:9: (child= literalValue | child= qualified )
            {
                int alt10=2;

                {
                    int LA10_0 = LA(1);
                    if ( (((LA10_0 >= INT) && (LA10_0 <= STRING)) || ((LA10_0 >= 100) && (LA10_0 <= 105))) ) 
                    {
                        alt10=1;
                    }
                    else if ( (LA10_0 == IDENT || ((LA10_0 >= 45) && (LA10_0 <= 46))) ) 
                    {
                        alt10=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 10;
                        EXCEPTION->state        = 0;


                        goto rulesetElementEx;
                    }
                }
                switch (alt10) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:240:13: child= literalValue
            	    {
            	        FOLLOWPUSH(FOLLOW_literalValue_in_setElement1029);
            	        child=literalValue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesetElementEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // NDDL/base/antlr/NDDL3Tree.g:241:13: child= qualified
            	    {
            	        FOLLOWPUSH(FOLLOW_qualified_in_setElement1045);
            	        child=qualified(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesetElementEx;
            	        }


            	    }
            	    break;

                }
            }
            {
                 
                            result = child;
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesetElementEx; /* Prevent compiler warnings */
    rulesetElementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end setElement */

/** 
 * $ANTLR start valueSet
 * NDDL/base/antlr/NDDL3Tree.g:248:1: valueSet returns [Expr* result] : ^( '{' (element= setElement )* ) ;
 */
static Expr*
valueSet(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Expr* element;
    #undef	RETURN_TYPE_element
    #define	RETURN_TYPE_element Expr*

    /* Initialize rule variables
     */



        std::list<edouble> values;
        DataTypeId elementType;

    element = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:253:5: ( ^( '{' (element= setElement )* ) )
        // NDDL/base/antlr/NDDL3Tree.g:253:9: ^( '{' (element= setElement )* )
        {
             MATCHT(33, &FOLLOW_33_in_valueSet1094); 
            if  (HASEXCEPTION())
            {
                goto rulevalueSetEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulevalueSetEx;
                }


                // NDDL/base/antlr/NDDL3Tree.g:254:13: (element= setElement )*

                for (;;)
                {
                    int alt11=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA11_0 = LA(1);
                        if ( (((LA11_0 >= IDENT) && (LA11_0 <= STRING)) || ((LA11_0 >= 45) && (LA11_0 <= 46)) || ((LA11_0 >= 100) && (LA11_0 <= 105))) ) 
                        {
                            alt11=1;
                        }

                    }
                    switch (alt11) 
                    {
                	case 1:
                	    // NDDL/base/antlr/NDDL3Tree.g:254:14: element= setElement
                	    {
                	        FOLLOWPUSH(FOLLOW_setElement_in_valueSet1111);
                	        element=setElement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulevalueSetEx;
                	        }

                	        {

                	                            DataRef elemValue = evalExpr(CTX,element);
                	                            const Domain& ev = elemValue.getValue()->lastDomain();
                	                            edouble v = ev.getSingletonValue();
                	                                          
                	                            delete element;
                	                                         
                	                            if (elementType.isNoId())
                	                                elementType = ev.getDataType();
                	                            else {
                	                                DataTypeId newElementType=ev.getDataType();
                	                                if (!newElementType->isAssignableFrom(elementType) &&
                	                                    !elementType->isAssignableFrom(newElementType)) {
                	                                    reportSemanticError(CTX,
                	                                        "Incompatible types in value set: "+
                	                                        elementType->toString(values.front())+"("+elementType->getName().toString()+") "+ 
                	                                        newElementType->toString(v)+"("+newElementType->getName().toString()+")" 
                	                                    );
                	                                }
                	                            }
                	                                         
                	                            values.push_back(v);
                	                        
                	        }

                	    }
                	    break;

                	default:
                	    goto loop11;	/* break out of the loop */
                	    break;
                    }
                }
                loop11: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulevalueSetEx;
                }

            }
            {

                            Domain* newDomain = new EnumeratedDomain(elementType,values); 
                            result = new ExprConstant(
                                elementType->getName().c_str(),
                                newDomain                       
                            );
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevalueSetEx; /* Prevent compiler warnings */
    rulevalueSetEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end valueSet */

/** 
 * $ANTLR start literalValue
 * NDDL/base/antlr/NDDL3Tree.g:289:1: literalValue returns [Expr* result] : (child= booleanLiteral | child= numericLiteral | child= stringLiteral ) ;
 */
static Expr*
literalValue(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Domain* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Domain*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:290:5: ( (child= booleanLiteral | child= numericLiteral | child= stringLiteral ) )
        // NDDL/base/antlr/NDDL3Tree.g:290:9: (child= booleanLiteral | child= numericLiteral | child= stringLiteral )
        {

            // NDDL/base/antlr/NDDL3Tree.g:290:9: (child= booleanLiteral | child= numericLiteral | child= stringLiteral )
            {
                int alt12=3;
                switch ( LA(1) ) 
                {
                case 100:
                case 101:
                	{
                		alt12=1;
                	}
                    break;
                case INT:
                case FLOAT:
                case 102:
                case 103:
                case 104:
                case 105:
                	{
                		alt12=2;
                	}
                    break;
                case STRING:
                	{
                		alt12=3;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 12;
                    EXCEPTION->state        = 0;


                    goto ruleliteralValueEx;
                }

                switch (alt12) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:290:13: child= booleanLiteral
            	    {
            	        FOLLOWPUSH(FOLLOW_booleanLiteral_in_literalValue1189);
            	        child=booleanLiteral(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleliteralValueEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // NDDL/base/antlr/NDDL3Tree.g:291:13: child= numericLiteral
            	    {
            	        FOLLOWPUSH(FOLLOW_numericLiteral_in_literalValue1205);
            	        child=numericLiteral(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleliteralValueEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // NDDL/base/antlr/NDDL3Tree.g:292:13: child= stringLiteral
            	    {
            	        FOLLOWPUSH(FOLLOW_stringLiteral_in_literalValue1221);
            	        child=stringLiteral(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleliteralValueEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                            result = new ExprConstant(
                                child->getTypeName().c_str(),
                                child
                            ); 
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleliteralValueEx; /* Prevent compiler warnings */
    ruleliteralValueEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end literalValue */

/** 
 * $ANTLR start booleanLiteral
 * NDDL/base/antlr/NDDL3Tree.g:302:1: booleanLiteral returns [Domain* result] : ( 'true' | 'false' );
 */
static Domain*
booleanLiteral(pNDDL3Tree ctx)
{   
    Domain* result = NULL;

    /* Initialize rule variables
     */


    {
        {
            //  NDDL/base/antlr/NDDL3Tree.g:303:5: ( 'true' | 'false' )
            
            ANTLR3_UINT32 alt13;

            alt13=2;


            {
                int LA13_0 = LA(1);
                if ( (LA13_0 == 100) ) 
                {
                    alt13=1;
                }
                else if ( (LA13_0 == 101) ) 
                {
                    alt13=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 13;
                    EXCEPTION->state        = 0;


                    goto rulebooleanLiteralEx;
                }
            }
            switch (alt13) 
            {
        	case 1:
        	    // NDDL/base/antlr/NDDL3Tree.g:303:9: 'true'
        	    {
        	         MATCHT(100, &FOLLOW_100_in_booleanLiteral1268); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebooleanLiteralEx;
        	        }

        	        {
        	             result = new BoolDomain(true); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // NDDL/base/antlr/NDDL3Tree.g:304:9: 'false'
        	    {
        	         MATCHT(101, &FOLLOW_101_in_booleanLiteral1293); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebooleanLiteralEx;
        	        }

        	        {
        	             result = new BoolDomain(false); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulebooleanLiteralEx; /* Prevent compiler warnings */
    rulebooleanLiteralEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end booleanLiteral */

/** 
 * $ANTLR start stringLiteral
 * NDDL/base/antlr/NDDL3Tree.g:307:1: stringLiteral returns [Domain* result] : str= STRING ;
 */
static Domain*
stringLiteral(pNDDL3Tree ctx)
{   
    Domain* result = NULL;

    pANTLR3_BASE_TREE    str;

    /* Initialize rule variables
     */


    str       = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:308:5: (str= STRING )
        // NDDL/base/antlr/NDDL3Tree.g:308:10: str= STRING
        {
            str = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_stringLiteral1323); 
            if  (HASEXCEPTION())
            {
                goto rulestringLiteralEx;
            }

            {
                 
                             // remove quotes
                             std::string s(c_str((str->getText(str))->chars));
                             s = s.substr(1,s.size()-2);
                                 
                             LabelStr value(s); 
                             result = new StringDomain(value,StringDT::instance());
                         
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestringLiteralEx; /* Prevent compiler warnings */
    rulestringLiteralEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end stringLiteral */

/** 
 * $ANTLR start numericLiteral
 * NDDL/base/antlr/NDDL3Tree.g:319:1: numericLiteral returns [Domain* result] : (floating= floatLiteral | integer= intLiteral );
 */
static Domain*
numericLiteral(pNDDL3Tree ctx)
{   
    Domain* result = NULL;

    NDDL3Tree_floatLiteral_return floating;
    #undef	RETURN_TYPE_floating
    #define	RETURN_TYPE_floating NDDL3Tree_floatLiteral_return

    NDDL3Tree_intLiteral_return integer;
    #undef	RETURN_TYPE_integer
    #define	RETURN_TYPE_integer NDDL3Tree_intLiteral_return

    /* Initialize rule variables
     */





    {
        {
            //  NDDL/base/antlr/NDDL3Tree.g:320:5: (floating= floatLiteral | integer= intLiteral )
            
            ANTLR3_UINT32 alt14;

            alt14=2;


            {
                int LA14_0 = LA(1);
                if ( (LA14_0 == FLOAT || LA14_0 == 103 || LA14_0 == 105) ) 
                {
                    alt14=1;
                }
                else if ( (LA14_0 == INT || LA14_0 == 102 || LA14_0 == 104) ) 
                {
                    alt14=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 14;
                    EXCEPTION->state        = 0;


                    goto rulenumericLiteralEx;
                }
            }
            switch (alt14) 
            {
        	case 1:
        	    // NDDL/base/antlr/NDDL3Tree.g:320:9: floating= floatLiteral
        	    {
        	        FOLLOWPUSH(FOLLOW_floatLiteral_in_numericLiteral1361);
        	        floating=floatLiteral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenumericLiteralEx;
        	        }

        	        {
        	             result = CTX->SymbolTable->makeNumericDomainFromLiteral("float",c_str((STRSTREAM->toStringSS(STRSTREAM, floating.start, floating.start))->chars)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // NDDL/base/antlr/NDDL3Tree.g:321:9: integer= intLiteral
        	    {
        	        FOLLOWPUSH(FOLLOW_intLiteral_in_numericLiteral1376);
        	        integer=intLiteral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenumericLiteralEx;
        	        }

        	        {
        	             result = CTX->SymbolTable->makeNumericDomainFromLiteral("int",c_str((STRSTREAM->toStringSS(STRSTREAM, integer.start, integer.start))->chars)); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulenumericLiteralEx; /* Prevent compiler warnings */
    rulenumericLiteralEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end numericLiteral */

/** 
 * $ANTLR start floatLiteral
 * NDDL/base/antlr/NDDL3Tree.g:324:1: floatLiteral : ( FLOAT | 'inff' | '-inff' );
 */
static NDDL3Tree_floatLiteral_return
floatLiteral(pNDDL3Tree ctx)
{   
    NDDL3Tree_floatLiteral_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // NDDL/base/antlr/NDDL3Tree.g:325:5: ( FLOAT | 'inff' | '-inff' )
        // NDDL/base/antlr/NDDL3Tree.g:
        {
            if ( LA(1) == FLOAT || LA(1) == 103 || LA(1) == 105 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_floatLiteral0);    goto rulefloatLiteralEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefloatLiteralEx; /* Prevent compiler warnings */
    rulefloatLiteralEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end floatLiteral */

/** 
 * $ANTLR start intLiteral
 * NDDL/base/antlr/NDDL3Tree.g:328:1: intLiteral : ( INT | 'inf' | '-inf' );
 */
static NDDL3Tree_intLiteral_return
intLiteral(pNDDL3Tree ctx)
{   
    NDDL3Tree_intLiteral_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // NDDL/base/antlr/NDDL3Tree.g:329:5: ( INT | 'inf' | '-inf' )
        // NDDL/base/antlr/NDDL3Tree.g:
        {
            if ( LA(1) == INT || LA(1) == 102 || LA(1) == 104 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_intLiteral0);    goto ruleintLiteralEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleintLiteralEx; /* Prevent compiler warnings */
    ruleintLiteralEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end intLiteral */

/** 
 * $ANTLR start numericInterval
 * NDDL/base/antlr/NDDL3Tree.g:332:1: numericInterval returns [Expr* result] : ^( '[' lower= numericLiteral upper= numericLiteral ) ;
 */
static Expr*
numericInterval(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Domain* lower;
    #undef	RETURN_TYPE_lower
    #define	RETURN_TYPE_lower Domain*

    Domain* upper;
    #undef	RETURN_TYPE_upper
    #define	RETURN_TYPE_upper Domain*

    /* Initialize rule variables
     */


    lower = NULL;
    upper = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:333:5: ( ^( '[' lower= numericLiteral upper= numericLiteral ) )
        // NDDL/base/antlr/NDDL3Tree.g:333:9: ^( '[' lower= numericLiteral upper= numericLiteral )
        {
             MATCHT(38, &FOLLOW_38_in_numericInterval1483); 
            if  (HASEXCEPTION())
            {
                goto rulenumericIntervalEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulenumericIntervalEx;
            }

            FOLLOWPUSH(FOLLOW_numericLiteral_in_numericInterval1502);
            lower=numericLiteral(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenumericIntervalEx;
            }

            FOLLOWPUSH(FOLLOW_numericLiteral_in_numericInterval1518);
            upper=numericLiteral(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenumericIntervalEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulenumericIntervalEx;
            }

            {
                      
                            edouble lb = lower->getSingletonValue();
                            edouble ub = upper->getSingletonValue();
                            Domain* baseDomain;
                                    
                            if (lower->getTypeName().toString()=="float" || 
                                upper->getTypeName().toString()=="float") 
                                baseDomain = new IntervalDomain(lb,ub);
                            else 
                                baseDomain = new IntervalIntDomain((eint)lb,(eint)ub);
                                                  
                            result = new ExprConstant(
                                        lower->getTypeName().c_str(),
                                        baseDomain
                                    );
                                    
                            delete lower;
                            delete upper;
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenumericIntervalEx; /* Prevent compiler warnings */
    rulenumericIntervalEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end numericInterval */

/** 
 * $ANTLR start allocation
 * NDDL/base/antlr/NDDL3Tree.g:358:1: allocation[const char* name] returns [Expr* result] : ^( CONSTRUCTOR_INVOCATION objType= IDENT ( variableArgumentList[args] )? ) ;
 */
static Expr*
allocation(pNDDL3Tree ctx, const char* name)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    objType;

    /* Initialize rule variables
     */



        std::vector<Expr*> args;

    objType       = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:362:9: ( ^( CONSTRUCTOR_INVOCATION objType= IDENT ( variableArgumentList[args] )? ) )
        // NDDL/base/antlr/NDDL3Tree.g:362:17: ^( CONSTRUCTOR_INVOCATION objType= IDENT ( variableArgumentList[args] )? )
        {
             MATCHT(CONSTRUCTOR_INVOCATION, &FOLLOW_CONSTRUCTOR_INVOCATION_in_allocation1576); 
            if  (HASEXCEPTION())
            {
                goto ruleallocationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleallocationEx;
            }

            objType = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_allocation1604); 
            if  (HASEXCEPTION())
            {
                goto ruleallocationEx;
            }


            // NDDL/base/antlr/NDDL3Tree.g:364:25: ( variableArgumentList[args] )?
            {
                int alt15=2;
                {
                    int LA15_0 = LA(1);
                    if ( (LA15_0 == 41) ) 
                    {
                        alt15=1;
                    }
                }
                switch (alt15) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:364:25: variableArgumentList[args]
            	    {
            	        FOLLOWPUSH(FOLLOW_variableArgumentList_in_allocation1631);
            	        variableArgumentList(ctx, args);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleallocationEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleallocationEx;
            }

            {

                                    std::string objName = (name != NULL ? name : getAutoLabel("__Object"));
                                    /*try {
                                        CTX->SymbolTable->checkObjectFactory(c_str((objType->getText(objType))->chars),args);
                                    }
                                    catch (const std::string& errorMsg) {
                                        reportSemanticError(CTX,errorMsg);
                                    }*/
                                    result = new ExprNewObject(
                                        c_str((objType->getText(objType))->chars), // objectType
                                        objName.c_str(),
                                        args
                                    );
                                
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleallocationEx; /* Prevent compiler warnings */
    ruleallocationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end allocation */

/** 
 * $ANTLR start variableArgumentList
 * NDDL/base/antlr/NDDL3Tree.g:382:1: variableArgumentList[std::vector<Expr*>& result] : ( '(' | ^( '(' (arg= initializer[NULL] )* ) );
 */
static void
variableArgumentList(pNDDL3Tree ctx, std::vector<Expr*>& result)
{   
    Expr* arg;
    #undef	RETURN_TYPE_arg
    #define	RETURN_TYPE_arg Expr*

    /* Initialize rule variables
     */


    arg = NULL;

    {
        {
            //  NDDL/base/antlr/NDDL3Tree.g:383:9: ( '(' | ^( '(' (arg= initializer[NULL] )* ) )
            
            ANTLR3_UINT32 alt17;

            alt17=2;


            {
                int LA17_0 = LA(1);
                if ( (LA17_0 == 41) ) 
                {

                    {
                        int LA17_1 = LA(2);
                        if ( (LA17_1 == DOWN) ) 
                        {
                            alt17=2;
                        }
                        else if ( (LA17_1 == UP || LA17_1 == STRING) ) 
                        {
                            alt17=1;
                        }
                        else 
                        {
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 17;
                            EXCEPTION->state        = 1;


                            goto rulevariableArgumentListEx;
                        }
                    }
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 17;
                    EXCEPTION->state        = 0;


                    goto rulevariableArgumentListEx;
                }
            }
            switch (alt17) 
            {
        	case 1:
        	    // NDDL/base/antlr/NDDL3Tree.g:383:17: '('
        	    {
        	         MATCHT(41, &FOLLOW_41_in_variableArgumentList1701); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevariableArgumentListEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // NDDL/base/antlr/NDDL3Tree.g:384:17: ^( '(' (arg= initializer[NULL] )* )
        	    {
        	         MATCHT(41, &FOLLOW_41_in_variableArgumentList1720); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevariableArgumentListEx;
        	        }


        	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulevariableArgumentListEx;
        	            }


        	            // NDDL/base/antlr/NDDL3Tree.g:385:25: (arg= initializer[NULL] )*

        	            for (;;)
        	            {
        	                int alt16=2;
        	                {
        	                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                    */
        	                    int LA16_0 = LA(1);
        	                    if ( (LA16_0 == CONSTRUCTOR_INVOCATION || ((LA16_0 >= IDENT) && (LA16_0 <= STRING)) || LA16_0 == 33 || LA16_0 == 38 || ((LA16_0 >= 45) && (LA16_0 <= 46)) || ((LA16_0 >= 100) && (LA16_0 <= 105))) ) 
        	                    {
        	                        alt16=1;
        	                    }

        	                }
        	                switch (alt16) 
        	                {
        	            	case 1:
        	            	    // NDDL/base/antlr/NDDL3Tree.g:385:26: arg= initializer[NULL]
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_initializer_in_variableArgumentList1749);
        	            	        arg=initializer(ctx, NULL);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulevariableArgumentListEx;
        	            	        }

        	            	        {
        	            	            result.push_back(arg);
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop16;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop16: ; /* Jump out to here if this rule does not match */


        	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulevariableArgumentListEx;
        	            }

        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulevariableArgumentListEx; /* Prevent compiler warnings */
    rulevariableArgumentListEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end variableArgumentList */

/** 
 * $ANTLR start identifier
 * NDDL/base/antlr/NDDL3Tree.g:389:1: identifier : ( IDENT | 'this' );
 */
static NDDL3Tree_identifier_return
identifier(pNDDL3Tree ctx)
{   
    NDDL3Tree_identifier_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // NDDL/base/antlr/NDDL3Tree.g:390:9: ( IDENT | 'this' )
        // NDDL/base/antlr/NDDL3Tree.g:
        {
            if ( LA(1) == IDENT || LA(1) == 45 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_identifier0);    goto ruleidentifierEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleidentifierEx; /* Prevent compiler warnings */
    ruleidentifierEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end identifier */

/** 
 * $ANTLR start constraintInstantiation
 * NDDL/base/antlr/NDDL3Tree.g:394:1: constraintInstantiation returns [ExprConstraint* result] : ^( CONSTRAINT_INSTANTIATION name= IDENT variableArgumentList[args] ( violationMsg[vmsg] )? ) ;
 */
static ExprConstraint*
constraintInstantiation(pNDDL3Tree ctx)
{   
    ExprConstraint* result = NULL;

    pANTLR3_BASE_TREE    name;

    /* Initialize rule variables
     */



        std::vector<Expr*> args;
        std::string vmsg;

    name       = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:399:9: ( ^( CONSTRAINT_INSTANTIATION name= IDENT variableArgumentList[args] ( violationMsg[vmsg] )? ) )
        // NDDL/base/antlr/NDDL3Tree.g:400:15: ^( CONSTRAINT_INSTANTIATION name= IDENT variableArgumentList[args] ( violationMsg[vmsg] )? )
        {
             MATCHT(CONSTRAINT_INSTANTIATION, &FOLLOW_CONSTRAINT_INSTANTIATION_in_constraintInstantiation1866); 
            if  (HASEXCEPTION())
            {
                goto ruleconstraintInstantiationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstraintInstantiationEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_constraintInstantiation1894); 
            if  (HASEXCEPTION())
            {
                goto ruleconstraintInstantiationEx;
            }

            FOLLOWPUSH(FOLLOW_variableArgumentList_in_constraintInstantiation1920);
            variableArgumentList(ctx, args);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconstraintInstantiationEx;
            }


            // NDDL/base/antlr/NDDL3Tree.g:403:25: ( violationMsg[vmsg] )?
            {
                int alt18=2;
                {
                    int LA18_0 = LA(1);
                    if ( (LA18_0 == STRING) ) 
                    {
                        alt18=1;
                    }
                }
                switch (alt18) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:403:26: violationMsg[vmsg]
            	    {
            	        FOLLOWPUSH(FOLLOW_violationMsg_in_constraintInstantiation1948);
            	        violationMsg(ctx, vmsg);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstraintInstantiationEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstraintInstantiationEx;
            }

            {

                                    const char* cname = c_str((name->getText(name))->chars);
                                    try {
                                        CTX->SymbolTable->checkConstraint(cname,args);
                                    }
                                    catch (const std::string& errorMsg) {
                                        reportSemanticError(CTX,errorMsg);
                                    }
                                    result = new ExprConstraint(cname,args,vmsg.c_str());
                                
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconstraintInstantiationEx; /* Prevent compiler warnings */
    ruleconstraintInstantiationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end constraintInstantiation */

/** 
 * $ANTLR start violationMsg
 * NDDL/base/antlr/NDDL3Tree.g:418:1: violationMsg[std::string& result] : str= STRING ;
 */
static void
violationMsg(pNDDL3Tree ctx, std::string& result)
{   
    pANTLR3_BASE_TREE    str;

    /* Initialize rule variables
     */


    str       = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:419:5: (str= STRING )
        // NDDL/base/antlr/NDDL3Tree.g:419:10: str= STRING
        {
            str = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_violationMsg2034); 
            if  (HASEXCEPTION())
            {
                goto ruleviolationMsgEx;
            }

            {
                 
                             // remove quotes
                             std::string s(c_str((str->getText(str))->chars));
                             result = s.substr(1,s.size()-2);
                         
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleviolationMsgEx; /* Prevent compiler warnings */
    ruleviolationMsgEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end violationMsg */

/** 
 * $ANTLR start classDeclaration
 * NDDL/base/antlr/NDDL3Tree.g:427:1: classDeclaration returns [Expr* result] : ^( 'class' className= IDENT ( ^( 'extends' superClass= IDENT ) )? ( classBlock[objType] | ';' ) ) ;
 */
static Expr*
classDeclaration(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    className;
    pANTLR3_BASE_TREE    superClass;

    /* Initialize rule variables
     */



    	const char* newClass = NULL;
    	const char* parentClass = "Object";
    	ObjectType* objType = NULL;

    className       = NULL;
    superClass       = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:433:2: ( ^( 'class' className= IDENT ( ^( 'extends' superClass= IDENT ) )? ( classBlock[objType] | ';' ) ) )
        // NDDL/base/antlr/NDDL3Tree.g:433:4: ^( 'class' className= IDENT ( ^( 'extends' superClass= IDENT ) )? ( classBlock[objType] | ';' ) )
        {
             MATCHT(48, &FOLLOW_48_in_classDeclaration2069); 
            if  (HASEXCEPTION())
            {
                goto ruleclassDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleclassDeclarationEx;
            }

            className = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_classDeclaration2084); 
            if  (HASEXCEPTION())
            {
                goto ruleclassDeclarationEx;
            }

            {
                 newClass = c_str((className->getText(className))->chars); 
            }

            // NDDL/base/antlr/NDDL3Tree.g:436:6: ( ^( 'extends' superClass= IDENT ) )?
            {
                int alt19=2;
                {
                    int LA19_0 = LA(1);
                    if ( (LA19_0 == 49) ) 
                    {
                        alt19=1;
                    }
                }
                switch (alt19) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:436:7: ^( 'extends' superClass= IDENT )
            	    {
            	         MATCHT(49, &FOLLOW_49_in_classDeclaration2115); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleclassDeclarationEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleclassDeclarationEx;
            	        }

            	        superClass = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_classDeclaration2119); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleclassDeclarationEx;
            	        }

            	        {
            	             parentClass = c_str((superClass->getText(superClass))->chars); 
            	        }

            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleclassDeclarationEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                		       ObjectTypeId parent = CTX->SymbolTable->getObjectType(parentClass);
                		       if (parent.isNoId())
                		          reportSemanticError(CTX,"class "+std::string(parentClass)+" is undefined");
                		           
                               objType = new ObjectType(newClass,parent);
                               // TODO: do this more cleanly. Needed to deal with self-reference inside class definition
                               CTX->SymbolTable->getPlanDatabase()->getSchema()->declareObjectType(newClass);
                               pushContext(CTX,new NddlClassSymbolTable(CTX->SymbolTable,objType));                       
                           
            }

            // NDDL/base/antlr/NDDL3Tree.g:449:12: ( classBlock[objType] | ';' )
            {
                int alt20=2;

                {
                    int LA20_0 = LA(1);
                    if ( (LA20_0 == 33) ) 
                    {
                        alt20=1;
                    }
                    else if ( (LA20_0 == 37) ) 
                    {
                        alt20=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 20;
                        EXCEPTION->state        = 0;


                        goto ruleclassDeclarationEx;
                    }
                }
                switch (alt20) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:450:10: classBlock[objType]
            	    {
            	        FOLLOWPUSH(FOLLOW_classBlock_in_classDeclaration2181);
            	        classBlock(ctx, objType);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleclassDeclarationEx;
            	        }

            	        {
            	             
            	            		           result = new ExprObjectTypeDefinition(objType->getId()); 
            	            		       
            	        }

            	    }
            	    break;
            	case 2:
            	    // NDDL/base/antlr/NDDL3Tree.g:454:12: ';'
            	    {
            	         MATCHT(37, &FOLLOW_37_in_classDeclaration2208); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleclassDeclarationEx;
            	        }

            	        {
            	             
            	            		             result = new ExprObjectTypeDeclaration(objType->getName());
            	            		             delete objType; 
            	            		         
            	        }

            	    }
            	    break;

                }
            }
            {

                               popContext(CTX);            
                	       
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleclassDeclarationEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleclassDeclarationEx; /* Prevent compiler warnings */
    ruleclassDeclarationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end classDeclaration */

/** 
 * $ANTLR start classBlock
 * NDDL/base/antlr/NDDL3Tree.g:466:1: classBlock[ObjectType* objType] : ( '{' | ^( '{' ( componentTypeEntry[objType] )* ) );
 */
static void
classBlock(pNDDL3Tree ctx, ObjectType* objType)
{   
    /* Initialize rule variables
     */


    {
        {
            //  NDDL/base/antlr/NDDL3Tree.g:467:2: ( '{' | ^( '{' ( componentTypeEntry[objType] )* ) )
            
            ANTLR3_UINT32 alt22;

            alt22=2;


            {
                int LA22_0 = LA(1);
                if ( (LA22_0 == 33) ) 
                {

                    {
                        int LA22_1 = LA(2);
                        if ( (LA22_1 == DOWN) ) 
                        {
                            alt22=2;
                        }
                        else if ( (LA22_1 == UP) ) 
                        {
                            alt22=1;
                        }
                        else 
                        {
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 22;
                            EXCEPTION->state        = 1;


                            goto ruleclassBlockEx;
                        }
                    }
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 22;
                    EXCEPTION->state        = 0;


                    goto ruleclassBlockEx;
                }
            }
            switch (alt22) 
            {
        	case 1:
        	    // NDDL/base/antlr/NDDL3Tree.g:467:4: '{'
        	    {
        	         MATCHT(33, &FOLLOW_33_in_classBlock2258); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleclassBlockEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // NDDL/base/antlr/NDDL3Tree.g:468:4: ^( '{' ( componentTypeEntry[objType] )* )
        	    {
        	         MATCHT(33, &FOLLOW_33_in_classBlock2264); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleclassBlockEx;
        	        }


        	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleclassBlockEx;
        	            }


        	            // NDDL/base/antlr/NDDL3Tree.g:468:10: ( componentTypeEntry[objType] )*

        	            for (;;)
        	            {
        	                int alt21=2;
        	                {
        	                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                    */
        	                    int LA21_0 = LA(1);
        	                    if ( (LA21_0 == CONSTRUCTOR || LA21_0 == VARIABLE || ((LA21_0 >= 50) && (LA21_0 <= 51))) ) 
        	                    {
        	                        alt21=1;
        	                    }

        	                }
        	                switch (alt21) 
        	                {
        	            	case 1:
        	            	    // NDDL/base/antlr/NDDL3Tree.g:468:10: componentTypeEntry[objType]
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_componentTypeEntry_in_classBlock2266);
        	            	        componentTypeEntry(ctx, objType);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruleclassBlockEx;
        	            	        }


        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop21;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop21: ; /* Jump out to here if this rule does not match */


        	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleclassBlockEx;
        	            }

        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleclassBlockEx; /* Prevent compiler warnings */
    ruleclassBlockEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end classBlock */

/** 
 * $ANTLR start componentTypeEntry
 * NDDL/base/antlr/NDDL3Tree.g:471:1: componentTypeEntry[ObjectType* objType] : ( classVariable[objType] | constructor[objType] | tokenType[objType] );
 */
static void
componentTypeEntry(pNDDL3Tree ctx, ObjectType* objType)
{   
    /* Initialize rule variables
     */


    {
        {
            //  NDDL/base/antlr/NDDL3Tree.g:472:2: ( classVariable[objType] | constructor[objType] | tokenType[objType] )
            
            ANTLR3_UINT32 alt23;

            alt23=3;

            switch ( LA(1) ) 
            {
            case VARIABLE:
            	{
            		alt23=1;
            	}
                break;
            case CONSTRUCTOR:
            	{
            		alt23=2;
            	}
                break;
            case 50:
            case 51:
            	{
            		alt23=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 23;
                EXCEPTION->state        = 0;


                goto rulecomponentTypeEntryEx;
            }

            switch (alt23) 
            {
        	case 1:
        	    // NDDL/base/antlr/NDDL3Tree.g:472:4: classVariable[objType]
        	    {
        	        FOLLOWPUSH(FOLLOW_classVariable_in_componentTypeEntry2282);
        	        classVariable(ctx, objType);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponentTypeEntryEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // NDDL/base/antlr/NDDL3Tree.g:473:4: constructor[objType]
        	    {
        	        FOLLOWPUSH(FOLLOW_constructor_in_componentTypeEntry2288);
        	        constructor(ctx, objType);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponentTypeEntryEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // NDDL/base/antlr/NDDL3Tree.g:474:4: tokenType[objType]
        	    {
        	        FOLLOWPUSH(FOLLOW_tokenType_in_componentTypeEntry2294);
        	        tokenType(ctx, objType);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponentTypeEntryEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecomponentTypeEntryEx; /* Prevent compiler warnings */
    rulecomponentTypeEntryEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end componentTypeEntry */

/** 
 * $ANTLR start classVariable
 * NDDL/base/antlr/NDDL3Tree.g:477:1: classVariable[ObjectType* objType] : ^( VARIABLE dataType= type (name= IDENT )+ ) ;
 */
static void
classVariable(pNDDL3Tree ctx, ObjectType* objType)
{   
    pANTLR3_BASE_TREE    name;
    DataType* dataType;
    #undef	RETURN_TYPE_dataType
    #define	RETURN_TYPE_dataType DataType*

    /* Initialize rule variables
     */


    name       = NULL;
    dataType = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:478:9: ( ^( VARIABLE dataType= type (name= IDENT )+ ) )
        // NDDL/base/antlr/NDDL3Tree.g:478:17: ^( VARIABLE dataType= type (name= IDENT )+ )
        {
             MATCHT(VARIABLE, &FOLLOW_VARIABLE_in_classVariable2321); 
            if  (HASEXCEPTION())
            {
                goto ruleclassVariableEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleclassVariableEx;
            }

            FOLLOWPUSH(FOLLOW_type_in_classVariable2344);
            dataType=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleclassVariableEx;
            }

            // NDDL/base/antlr/NDDL3Tree.g:480:19: (name= IDENT )+
            {
                int cnt24=0;

                for (;;)
                {
                    int alt24=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA24_0 = LA(1);
            	    if ( (LA24_0 == IDENT) ) 
            	    {
            	        alt24=1;
            	    }

            	}
            	switch (alt24) 
            	{
            	    case 1:
            	        // NDDL/base/antlr/NDDL3Tree.g:480:20: name= IDENT
            	        {
            	            name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_classVariable2368); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleclassVariableEx;
            	            }

            	            {

            	                                      objType->addMember(dataType->getId(),c_str((name->getText(name))->chars)); 
            	                                  
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt24 >= 1 )
            		{
            		    goto loop24;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleclassVariableEx;
            	}
            	cnt24++;
                }
                loop24: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleclassVariableEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleclassVariableEx; /* Prevent compiler warnings */
    ruleclassVariableEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end classVariable */

/** 
 * $ANTLR start constructor
 * NDDL/base/antlr/NDDL3Tree.g:488:1: constructor[ObjectType* objType] : ^( CONSTRUCTOR name= IDENT ^( '(' ( constructorArgument[argNames,argTypes] )* ) ^( '{' (superCallExpr= constructorSuper[objType] )? (child= assignment )* ) ) ;
 */
static void
constructor(pNDDL3Tree ctx, ObjectType* objType)
{   
    pANTLR3_BASE_TREE    name;
    ExprConstructorSuperCall* superCallExpr;
    #undef	RETURN_TYPE_superCallExpr
    #define	RETURN_TYPE_superCallExpr ExprConstructorSuperCall*

    ExprAssignment* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child ExprAssignment*

    /* Initialize rule variables
     */



        std::vector<std::string> argNames;
        std::vector<std::string> argTypes;
        std::vector<Expr*> body;
        pushContext(CTX,new NddlSymbolTable(CTX->SymbolTable));                       

    name       = NULL;
    superCallExpr = NULL;
    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:495:2: ( ^( CONSTRUCTOR name= IDENT ^( '(' ( constructorArgument[argNames,argTypes] )* ) ^( '{' (superCallExpr= constructorSuper[objType] )? (child= assignment )* ) ) )
        // NDDL/base/antlr/NDDL3Tree.g:495:4: ^( CONSTRUCTOR name= IDENT ^( '(' ( constructorArgument[argNames,argTypes] )* ) ^( '{' (superCallExpr= constructorSuper[objType] )? (child= assignment )* ) )
        {
             MATCHT(CONSTRUCTOR, &FOLLOW_CONSTRUCTOR_in_constructor2461); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_constructor2468); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorEx;
            }

             MATCHT(41, &FOLLOW_41_in_constructor2474); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleconstructorEx;
                }


                // NDDL/base/antlr/NDDL3Tree.g:497:10: ( constructorArgument[argNames,argTypes] )*

                for (;;)
                {
                    int alt25=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA25_0 = LA(1);
                        if ( (LA25_0 == VARIABLE) ) 
                        {
                            alt25=1;
                        }

                    }
                    switch (alt25) 
                    {
                	case 1:
                	    // NDDL/base/antlr/NDDL3Tree.g:497:10: constructorArgument[argNames,argTypes]
                	    {
                	        FOLLOWPUSH(FOLLOW_constructorArgument_in_constructor2476);
                	        constructorArgument(ctx, argNames, argTypes);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleconstructorEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop25;	/* break out of the loop */
                	    break;
                    }
                }
                loop25: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleconstructorEx;
                }

            }
             MATCHT(33, &FOLLOW_33_in_constructor2485); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleconstructorEx;
                }


                // NDDL/base/antlr/NDDL3Tree.g:498:23: (superCallExpr= constructorSuper[objType] )?
                {
                    int alt26=2;
                    {
                        int LA26_0 = LA(1);
                        if ( (LA26_0 == 73) ) 
                        {
                            alt26=1;
                        }
                    }
                    switch (alt26) 
                    {
                	case 1:
                	    // NDDL/base/antlr/NDDL3Tree.g:498:23: superCallExpr= constructorSuper[objType]
                	    {
                	        FOLLOWPUSH(FOLLOW_constructorSuper_in_constructor2489);
                	        superCallExpr=constructorSuper(ctx, objType);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleconstructorEx;
                	        }


                	    }
                	    break;

                    }
                }

                // NDDL/base/antlr/NDDL3Tree.g:499:10: (child= assignment )*

                for (;;)
                {
                    int alt27=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA27_0 = LA(1);
                        if ( (LA27_0 == 43) ) 
                        {
                            alt27=1;
                        }

                    }
                    switch (alt27) 
                    {
                	case 1:
                	    // NDDL/base/antlr/NDDL3Tree.g:499:11: child= assignment
                	    {
                	        FOLLOWPUSH(FOLLOW_assignment_in_constructor2505);
                	        child=assignment(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleconstructorEx;
                	        }

                	        {
                	            body.push_back(child);
                	        }

                	    }
                	    break;

                	default:
                	    goto loop27;	/* break out of the loop */
                	    break;
                    }
                }
                loop27: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleconstructorEx;
                }

            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorEx;
            }

            {

                		    std::ostringstream signature;
                		    signature << objType->getName().c_str();
                		    
                		    for (unsigned int i=0;i<argTypes.size();i++)
                		        signature << ":" << argTypes[i];
                		        
                            objType->addObjectFactory(
                                        (new InterpretedObjectFactory(
                                            objType->getId(),
                                            signature.str(),
                                            argNames,
                                            argTypes,
                                            superCallExpr,
                                            body)
                                        )->getId()
                                    );
                            
                            popContext(CTX);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconstructorEx; /* Prevent compiler warnings */
    ruleconstructorEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end constructor */

/** 
 * $ANTLR start constructorArgument
 * NDDL/base/antlr/NDDL3Tree.g:523:1: constructorArgument[std::vector<std::string>& argNames,std::vector<std::string>& argTypes] : ^( VARIABLE argName= IDENT argType= type ) ;
 */
static void
constructorArgument(pNDDL3Tree ctx, std::vector<std::string>& argNames, std::vector<std::string>& argTypes)
{   
    pANTLR3_BASE_TREE    argName;
    DataType* argType;
    #undef	RETURN_TYPE_argType
    #define	RETURN_TYPE_argType DataType*

    /* Initialize rule variables
     */


    argName       = NULL;
    argType = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:524:2: ( ^( VARIABLE argName= IDENT argType= type ) )
        // NDDL/base/antlr/NDDL3Tree.g:524:4: ^( VARIABLE argName= IDENT argType= type )
        {
             MATCHT(VARIABLE, &FOLLOW_VARIABLE_in_constructorArgument2531); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorArgumentEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorArgumentEx;
            }

            argName = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_constructorArgument2538); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorArgumentEx;
            }

            FOLLOWPUSH(FOLLOW_type_in_constructorArgument2545);
            argType=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconstructorArgumentEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorArgumentEx;
            }

            {

                		    const char* varName = c_str((argName->getText(argName))->chars);
                		    argNames.push_back(varName);
                		    argTypes.push_back(argType->getName().toString());
                		    CTX->SymbolTable->addLocalVar(varName,argType->getId());
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconstructorArgumentEx; /* Prevent compiler warnings */
    ruleconstructorArgumentEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end constructorArgument */

/** 
 * $ANTLR start constructorSuper
 * NDDL/base/antlr/NDDL3Tree.g:536:1: constructorSuper[ObjectType* objType] returns [ExprConstructorSuperCall* result] : ^( 'super' variableArgumentList[args] ) ;
 */
static ExprConstructorSuperCall*
constructorSuper(pNDDL3Tree ctx, ObjectType* objType)
{   
    ExprConstructorSuperCall* result = NULL;

    /* Initialize rule variables
     */



        std::vector<Expr*> args;

    {
        // NDDL/base/antlr/NDDL3Tree.g:540:2: ( ^( 'super' variableArgumentList[args] ) )
        // NDDL/base/antlr/NDDL3Tree.g:540:4: ^( 'super' variableArgumentList[args] )
        {
             MATCHT(73, &FOLLOW_73_in_constructorSuper2575); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorSuperEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorSuperEx;
            }

            FOLLOWPUSH(FOLLOW_variableArgumentList_in_constructorSuper2580);
            variableArgumentList(ctx, args);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconstructorSuperEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorSuperEx;
            }

            {

                		    result = new ExprConstructorSuperCall(objType->getParent()->getName(),args);  
                            /*try {
                                CTX->SymbolTable->checkObjectFactory(objType->getParent()->getName().c_str(),args);
                            }
                            catch (const std::string& errorMsg) {
                                reportSemanticError(CTX,errorMsg);
                            }*/
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconstructorSuperEx; /* Prevent compiler warnings */
    ruleconstructorSuperEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end constructorSuper */

/** 
 * $ANTLR start assignment
 * NDDL/base/antlr/NDDL3Tree.g:554:1: assignment returns [ExprAssignment* result] : ^( '=' lhs= qualified rhs= initializer[lhs->toString().c_str()] ) ;
 */
static ExprAssignment*
assignment(pNDDL3Tree ctx)
{   
    ExprAssignment* result = NULL;

    Expr* lhs;
    #undef	RETURN_TYPE_lhs
    #define	RETURN_TYPE_lhs Expr*

    Expr* rhs;
    #undef	RETURN_TYPE_rhs
    #define	RETURN_TYPE_rhs Expr*

    /* Initialize rule variables
     */


    lhs = NULL;
    rhs = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:555:2: ( ^( '=' lhs= qualified rhs= initializer[lhs->toString().c_str()] ) )
        // NDDL/base/antlr/NDDL3Tree.g:555:4: ^( '=' lhs= qualified rhs= initializer[lhs->toString().c_str()] )
        {
             MATCHT(43, &FOLLOW_43_in_assignment2607); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }

            FOLLOWPUSH(FOLLOW_qualified_in_assignment2614);
            lhs=qualified(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }

            FOLLOWPUSH(FOLLOW_initializer_in_assignment2621);
            rhs=initializer(ctx, lhs->toString().c_str());

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }

            {

                		    result = new ExprAssignment(lhs,rhs);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleassignmentEx; /* Prevent compiler warnings */
    ruleassignmentEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end assignment */

/** 
 * $ANTLR start tokenType
 * NDDL/base/antlr/NDDL3Tree.g:564:1: tokenType[ObjectType* objType] : ^(kind= ( 'predicate' | 'action' ) ttName= IDENT tokenStatements[tokenType] ) ;
 */
static void
tokenType(pNDDL3Tree ctx, ObjectType* objType)
{   
    pANTLR3_BASE_TREE    kind;
    pANTLR3_BASE_TREE    ttName;

    /* Initialize rule variables
     */



        InterpretedTokenType* tokenType;
        std::string tokenTypeName;

    kind       = NULL;
    ttName       = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:569:2: ( ^(kind= ( 'predicate' | 'action' ) ttName= IDENT tokenStatements[tokenType] ) )
        // NDDL/base/antlr/NDDL3Tree.g:569:4: ^(kind= ( 'predicate' | 'action' ) ttName= IDENT tokenStatements[tokenType] )
        {
            kind=(pANTLR3_BASE_TREE)LT(1);
            if ( ((LA(1) >= 50) && (LA(1) <= 51)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_tokenType2650);    goto ruletokenTypeEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletokenTypeEx;
            }

            ttName = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_tokenType2663); 
            if  (HASEXCEPTION())
            {
                goto ruletokenTypeEx;
            }

            {
                 
                			    tokenTypeName = objType->getName().toString() + "." + c_str((ttName->getText(ttName))->chars);   
                			    tokenType = new InterpretedTokenType(objType->getId(),tokenTypeName,c_str((kind->getText(kind))->chars));
                			    pushContext(CTX,new NddlTokenSymbolTable(CTX->SymbolTable,tokenType->getId(),objType->getId())); 
                			
            }
            FOLLOWPUSH(FOLLOW_tokenStatements_in_tokenType2674);
            tokenStatements(ctx, tokenType);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletokenTypeEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletokenTypeEx;
            }

            {

                            objType->addTokenType(tokenType->getId());
                            popContext(CTX);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletokenTypeEx; /* Prevent compiler warnings */
    ruletokenTypeEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end tokenType */

/** 
 * $ANTLR start tokenStatements
 * NDDL/base/antlr/NDDL3Tree.g:585:1: tokenStatements[InterpretedTokenType* tokenType] : ^( '{' ( (child= tokenParameter[tokenType] | child= tokenParameterAssignment | child= standardConstraint | child= enforceExpression ) )* ) ;
 */
static void
tokenStatements(pNDDL3Tree ctx, InterpretedTokenType* tokenType)
{   
    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:586:2: ( ^( '{' ( (child= tokenParameter[tokenType] | child= tokenParameterAssignment | child= standardConstraint | child= enforceExpression ) )* ) )
        // NDDL/base/antlr/NDDL3Tree.g:586:4: ^( '{' ( (child= tokenParameter[tokenType] | child= tokenParameterAssignment | child= standardConstraint | child= enforceExpression ) )* )
        {
             MATCHT(33, &FOLLOW_33_in_tokenStatements2697); 
            if  (HASEXCEPTION())
            {
                goto ruletokenStatementsEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruletokenStatementsEx;
                }


                // NDDL/base/antlr/NDDL3Tree.g:587:13: ( (child= tokenParameter[tokenType] | child= tokenParameterAssignment | child= standardConstraint | child= enforceExpression ) )*

                for (;;)
                {
                    int alt29=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA29_0 = LA(1);
                        if ( (LA29_0 == CONSTRAINT_INSTANTIATION || ((LA29_0 >= VARIABLE) && (LA29_0 <= EXPRESSION_ENFORCE)) || LA29_0 == 43) ) 
                        {
                            alt29=1;
                        }

                    }
                    switch (alt29) 
                    {
                	case 1:
                	    // NDDL/base/antlr/NDDL3Tree.g:588:17: (child= tokenParameter[tokenType] | child= tokenParameterAssignment | child= standardConstraint | child= enforceExpression )
                	    {

                	        // NDDL/base/antlr/NDDL3Tree.g:588:17: (child= tokenParameter[tokenType] | child= tokenParameterAssignment | child= standardConstraint | child= enforceExpression )
                	        {
                	            int alt28=4;
                	            switch ( LA(1) ) 
                	            {
                	            case VARIABLE:
                	            	{
                	            		alt28=1;
                	            	}
                	                break;
                	            case 43:
                	            	{
                	            		alt28=2;
                	            	}
                	                break;
                	            case CONSTRAINT_INSTANTIATION:
                	            	{
                	            		alt28=3;
                	            	}
                	                break;
                	            case EXPRESSION_ENFORCE:
                	            	{
                	            		alt28=4;
                	            	}
                	                break;

                	            default:
                	                CONSTRUCTEX();
                	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                	                EXCEPTION->message      = (void *)"";
                	                EXCEPTION->decisionNum  = 28;
                	                EXCEPTION->state        = 0;


                	                goto ruletokenStatementsEx;
                	            }

                	            switch (alt28) 
                	            {
                	        	case 1:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:588:19: child= tokenParameter[tokenType]
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_tokenParameter_in_tokenStatements2733);
                	        	        child=tokenParameter(ctx, tokenType);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto ruletokenStatementsEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 2:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:589:19: child= tokenParameterAssignment
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_tokenParameterAssignment_in_tokenStatements2757);
                	        	        child=tokenParameterAssignment(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto ruletokenStatementsEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 3:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:590:19: child= standardConstraint
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_standardConstraint_in_tokenStatements2779);
                	        	        child=standardConstraint(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto ruletokenStatementsEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 4:
                	        	    // NDDL/base/antlr/NDDL3Tree.g:591:19: child= enforceExpression
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_enforceExpression_in_tokenStatements2802);
                	        	        child=enforceExpression(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto ruletokenStatementsEx;
                	        	        }


                	        	    }
                	        	    break;

                	            }
                	        }
                	        {

                	                                tokenType->addBodyExpr(child);
                	                            
                	        }

                	    }
                	    break;

                	default:
                	    goto loop29;	/* break out of the loop */
                	    break;
                    }
                }
                loop29: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruletokenStatementsEx;
                }

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletokenStatementsEx; /* Prevent compiler warnings */
    ruletokenStatementsEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end tokenStatements */

/** 
 * $ANTLR start tokenParameter
 * NDDL/base/antlr/NDDL3Tree.g:601:1: tokenParameter[InterpretedTokenType* tokenType] returns [Expr* result] : child= variableDeclarations ;
 */
static Expr*
tokenParameter(pNDDL3Tree ctx, InterpretedTokenType* tokenType)
{   
    Expr* result = NULL;

    ExprList* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child ExprList*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:602:9: (child= variableDeclarations )
        // NDDL/base/antlr/NDDL3Tree.g:603:9: child= variableDeclarations
        {
            FOLLOWPUSH(FOLLOW_variableDeclarations_in_tokenParameter2886);
            child=variableDeclarations(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletokenParameterEx;
            }

            {
                 
                            const std::vector<Expr*>& vars=child->getChildren();
                            for (unsigned int i=0;i<vars.size();i++) {
                                ExprVarDeclaration* vd = dynamic_cast<ExprVarDeclaration*>(vars[i]);
                                tokenType->addArg(vd->getDataType(),vd->getName());
                            }
                            result = child;            
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletokenParameterEx; /* Prevent compiler warnings */
    ruletokenParameterEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end tokenParameter */

/** 
 * $ANTLR start tokenParameterAssignment
 * NDDL/base/antlr/NDDL3Tree.g:614:1: tokenParameterAssignment returns [Expr* result] : child= assignment ;
 */
static Expr*
tokenParameterAssignment(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    ExprAssignment* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child ExprAssignment*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:615:9: (child= assignment )
        // NDDL/base/antlr/NDDL3Tree.g:616:9: child= assignment
        {
            FOLLOWPUSH(FOLLOW_assignment_in_tokenParameterAssignment2943);
            child=assignment(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletokenParameterAssignmentEx;
            }

            {
                 
                            result = child; 
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletokenParameterAssignmentEx; /* Prevent compiler warnings */
    ruletokenParameterAssignmentEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end tokenParameterAssignment */

/** 
 * $ANTLR start standardConstraint
 * NDDL/base/antlr/NDDL3Tree.g:622:1: standardConstraint returns [Expr* result] : child= constraintInstantiation ;
 */
static Expr*
standardConstraint(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    ExprConstraint* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child ExprConstraint*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:623:9: (child= constraintInstantiation )
        // NDDL/base/antlr/NDDL3Tree.g:624:9: child= constraintInstantiation
        {
            FOLLOWPUSH(FOLLOW_constraintInstantiation_in_standardConstraint2995);
            child=constraintInstantiation(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestandardConstraintEx;
            }

            {
                 
                            result = child; 
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestandardConstraintEx; /* Prevent compiler warnings */
    rulestandardConstraintEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end standardConstraint */

/** 
 * $ANTLR start rule
 * NDDL/base/antlr/NDDL3Tree.g:630:1: rule returns [Expr* result] : ^( '::' className= IDENT predicateName= IDENT ruleBlock[ruleBody] ) ;
 */
static Expr*
rule(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    className;
    pANTLR3_BASE_TREE    predicateName;

    /* Initialize rule variables
     */



        std::vector<Expr*> ruleBody;
        std::string predName;

    className       = NULL;
    predicateName       = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:635:3: ( ^( '::' className= IDENT predicateName= IDENT ruleBlock[ruleBody] ) )
        // NDDL/base/antlr/NDDL3Tree.g:635:5: ^( '::' className= IDENT predicateName= IDENT ruleBlock[ruleBody] )
        {
             MATCHT(52, &FOLLOW_52_in_rule3036); 
            if  (HASEXCEPTION())
            {
                goto ruleruleEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleruleEx;
            }

            className = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_rule3043); 
            if  (HASEXCEPTION())
            {
                goto ruleruleEx;
            }

            predicateName = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_rule3050); 
            if  (HASEXCEPTION())
            {
                goto ruleruleEx;
            }

            {

                		        std::string clazz = c_str((className->getText(className))->chars);
                			    ObjectTypeId ot = CTX->SymbolTable->getObjectType(clazz.c_str());
                			    if (ot.isNoId())
                			        reportSemanticError(CTX,"class "+clazz+" has not been declared");
                			        
                                predName = clazz + "." + std::string(c_str((predicateName->getText(predicateName))->chars));
                                debugMsg("NddlInterpreter","Parsing rule for:" << predName);
                                TokenTypeId tt = CTX->SymbolTable->getTokenType(predName.c_str());
                                if (tt.isNoId())
                                    reportSemanticError(CTX,predName+" has not been declared");            
                                
                                pushContext(CTX,new NddlTokenSymbolTable(CTX->SymbolTable,tt,ot));    
                			
            }
            FOLLOWPUSH(FOLLOW_ruleBlock_in_rule3060);
            ruleBlock(ctx, ruleBody);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleruleEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleruleEx;
            }

            {

                            char buff[10];
                            sprintf(buff, "%u", className->getLine(className));
                            std::string filename = "UNKNOWN";
                            if (className->getToken(className)) {
                                if (className->getToken(className)->input) {
                                    if (className->getToken(className)->input->fileName) {
                                        filename = c_str(className->getToken(className)->input->fileName->chars);
                                    }
                                }
                            }
                		    std::string source="\"" + filename + "," + std::string(buff) + "\"";
                		    result = new ExprRuleTypeDefinition((new InterpretedRuleFactory(predName,source,ruleBody))->getId());
                		    popContext(CTX);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleruleEx; /* Prevent compiler warnings */
    ruleruleEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end rule */

/** 
 * $ANTLR start ruleBlock
 * NDDL/base/antlr/NDDL3Tree.g:671:1: ruleBlock[std::vector<Expr*>& ruleBody] : ^( '{' (child= ruleStatement )* ) ;
 */
static void
ruleBlock(pNDDL3Tree ctx, std::vector<Expr*>& ruleBody)
{   
    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:672:2: ( ^( '{' (child= ruleStatement )* ) )
        // NDDL/base/antlr/NDDL3Tree.g:672:4: ^( '{' (child= ruleStatement )* )
        {
             MATCHT(33, &FOLLOW_33_in_ruleBlock3082); 
            if  (HASEXCEPTION())
            {
                goto ruleruleBlockEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleruleBlockEx;
                }


                // NDDL/base/antlr/NDDL3Tree.g:673:4: (child= ruleStatement )*

                for (;;)
                {
                    int alt30=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA30_0 = LA(1);
                        if ( (LA30_0 == CONSTRAINT_INSTANTIATION || ((LA30_0 >= TOKEN_RELATION) && (LA30_0 <= EXPRESSION_ENFORCE)) || LA30_0 == 43 || LA30_0 == 74 || LA30_0 == 76) ) 
                        {
                            alt30=1;
                        }

                    }
                    switch (alt30) 
                    {
                	case 1:
                	    // NDDL/base/antlr/NDDL3Tree.g:673:5: child= ruleStatement
                	    {
                	        FOLLOWPUSH(FOLLOW_ruleStatement_in_ruleBlock3090);
                	        child=ruleStatement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleruleBlockEx;
                	        }

                	        {
                	             ruleBody.push_back(child); 
                	        }

                	    }
                	    break;

                	default:
                	    goto loop30;	/* break out of the loop */
                	    break;
                    }
                }
                loop30: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleruleBlockEx;
                }

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleruleBlockEx; /* Prevent compiler warnings */
    ruleruleBlockEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end ruleBlock */

/** 
 * $ANTLR start ruleStatement
 * NDDL/base/antlr/NDDL3Tree.g:677:1: ruleStatement returns [Expr* result] : (child= constraintInstantiation | child= enforceExpression | child= assignment | child= variableDeclarations | child= ifStatement | child= loopStatement | child= relation ) ;
 */
static Expr*
ruleStatement(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:678:2: ( (child= constraintInstantiation | child= enforceExpression | child= assignment | child= variableDeclarations | child= ifStatement | child= loopStatement | child= relation ) )
        // NDDL/base/antlr/NDDL3Tree.g:678:4: (child= constraintInstantiation | child= enforceExpression | child= assignment | child= variableDeclarations | child= ifStatement | child= loopStatement | child= relation )
        {

            // NDDL/base/antlr/NDDL3Tree.g:678:4: (child= constraintInstantiation | child= enforceExpression | child= assignment | child= variableDeclarations | child= ifStatement | child= loopStatement | child= relation )
            {
                int alt31=7;
                switch ( LA(1) ) 
                {
                case CONSTRAINT_INSTANTIATION:
                	{
                		alt31=1;
                	}
                    break;
                case EXPRESSION_ENFORCE:
                	{
                		alt31=2;
                	}
                    break;
                case 43:
                	{
                		alt31=3;
                	}
                    break;
                case VARIABLE:
                	{
                		alt31=4;
                	}
                    break;
                case 74:
                	{
                		alt31=5;
                	}
                    break;
                case 76:
                	{
                		alt31=6;
                	}
                    break;
                case TOKEN_RELATION:
                	{
                		alt31=7;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 31;
                    EXCEPTION->state        = 0;


                    goto ruleruleStatementEx;
                }

                switch (alt31) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:678:6: child= constraintInstantiation
            	    {
            	        FOLLOWPUSH(FOLLOW_constraintInstantiation_in_ruleStatement3117);
            	        child=constraintInstantiation(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleStatementEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // NDDL/base/antlr/NDDL3Tree.g:679:9: child= enforceExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_enforceExpression_in_ruleStatement3129);
            	        child=enforceExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleStatementEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // NDDL/base/antlr/NDDL3Tree.g:680:6: child= assignment
            	    {
            	        FOLLOWPUSH(FOLLOW_assignment_in_ruleStatement3138);
            	        child=assignment(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleStatementEx;
            	        }


            	    }
            	    break;
            	case 4:
            	    // NDDL/base/antlr/NDDL3Tree.g:681:6: child= variableDeclarations
            	    {
            	        FOLLOWPUSH(FOLLOW_variableDeclarations_in_ruleStatement3147);
            	        child=variableDeclarations(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleStatementEx;
            	        }


            	    }
            	    break;
            	case 5:
            	    // NDDL/base/antlr/NDDL3Tree.g:682:6: child= ifStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_ifStatement_in_ruleStatement3156);
            	        child=ifStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleStatementEx;
            	        }


            	    }
            	    break;
            	case 6:
            	    // NDDL/base/antlr/NDDL3Tree.g:683:6: child= loopStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_loopStatement_in_ruleStatement3165);
            	        child=loopStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleStatementEx;
            	        }


            	    }
            	    break;
            	case 7:
            	    // NDDL/base/antlr/NDDL3Tree.g:684:10: child= relation
            	    {
            	        FOLLOWPUSH(FOLLOW_relation_in_ruleStatement3178);
            	        child=relation(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleStatementEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                	      result = child;
                	  
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleruleStatementEx; /* Prevent compiler warnings */
    ruleruleStatementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end ruleStatement */

/** 
 * $ANTLR start ifStatement
 * NDDL/base/antlr/NDDL3Tree.g:692:1: ifStatement returns [Expr* result] : ^( 'if' guard= guardExpression ruleBlock[ifBody] ( ruleBlock[elseBody] )? ) ;
 */
static Expr*
ifStatement(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    ExprIfGuard* guard;
    #undef	RETURN_TYPE_guard
    #define	RETURN_TYPE_guard ExprIfGuard*

    /* Initialize rule variables
     */



    std::vector<Expr*> ifBody;
    std::vector<Expr*> elseBody;

    guard = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:697:2: ( ^( 'if' guard= guardExpression ruleBlock[ifBody] ( ruleBlock[elseBody] )? ) )
        // NDDL/base/antlr/NDDL3Tree.g:697:4: ^( 'if' guard= guardExpression ruleBlock[ifBody] ( ruleBlock[elseBody] )? )
        {
             MATCHT(74, &FOLLOW_74_in_ifStatement3210); 
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }

            FOLLOWPUSH(FOLLOW_guardExpression_in_ifStatement3217);
            guard=guardExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }

            FOLLOWPUSH(FOLLOW_ruleBlock_in_ifStatement3222);
            ruleBlock(ctx, ifBody);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            // NDDL/base/antlr/NDDL3Tree.g:700:4: ( ruleBlock[elseBody] )?
            {
                int alt32=2;
                {
                    int LA32_0 = LA(1);
                    if ( (LA32_0 == 33) ) 
                    {
                        alt32=1;
                    }
                }
                switch (alt32) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:700:4: ruleBlock[elseBody]
            	    {
            	        FOLLOWPUSH(FOLLOW_ruleBlock_in_ifStatement3228);
            	        ruleBlock(ctx, elseBody);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }

            {

                		    result = new ExprIf(guard,ifBody,elseBody);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleifStatementEx; /* Prevent compiler warnings */
    ruleifStatementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end ifStatement */

/** 
 * $ANTLR start guardExpression
 * NDDL/base/antlr/NDDL3Tree.g:709:1: guardExpression returns [ExprIfGuard* result] : ( ^(relop= guardRelop lhs= anyValue rhs= anyValue ) | lhs= anyValue | ^( EXPRESSION_RETURN lhs= expressionCleanReturn ) ) ;
 */
static ExprIfGuard*
guardExpression(pNDDL3Tree ctx)
{   
    ExprIfGuard* result = NULL;

    NDDL3Tree_guardRelop_return relop;
    #undef	RETURN_TYPE_relop
    #define	RETURN_TYPE_relop NDDL3Tree_guardRelop_return

    Expr* lhs;
    #undef	RETURN_TYPE_lhs
    #define	RETURN_TYPE_lhs Expr*

    Expr* rhs;
    #undef	RETURN_TYPE_rhs
    #define	RETURN_TYPE_rhs Expr*

    /* Initialize rule variables
     */



        const char* relopStr = "==";
        BoolDomain *dom = NULL;


    lhs = NULL;
    rhs = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:715:9: ( ( ^(relop= guardRelop lhs= anyValue rhs= anyValue ) | lhs= anyValue | ^( EXPRESSION_RETURN lhs= expressionCleanReturn ) ) )
        // NDDL/base/antlr/NDDL3Tree.g:715:11: ( ^(relop= guardRelop lhs= anyValue rhs= anyValue ) | lhs= anyValue | ^( EXPRESSION_RETURN lhs= expressionCleanReturn ) )
        {

            // NDDL/base/antlr/NDDL3Tree.g:715:11: ( ^(relop= guardRelop lhs= anyValue rhs= anyValue ) | lhs= anyValue | ^( EXPRESSION_RETURN lhs= expressionCleanReturn ) )
            {
                int alt33=3;
                switch ( LA(1) ) 
                {
                case 64:
                case 65:
                	{
                		alt33=1;
                	}
                    break;
                case IDENT:
                case INT:
                case FLOAT:
                case STRING:
                case 33:
                case 38:
                case 45:
                case 46:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                	{
                		alt33=2;
                	}
                    break;
                case EXPRESSION_RETURN:
                	{
                		alt33=3;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 33;
                    EXCEPTION->state        = 0;


                    goto ruleguardExpressionEx;
                }

                switch (alt33) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:715:13: ^(relop= guardRelop lhs= anyValue rhs= anyValue )
            	    {
            	        FOLLOWPUSH(FOLLOW_guardRelop_in_guardExpression3273);
            	        relop=guardRelop(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }


            	        {
            	            relopStr=c_str((STRSTREAM->toStringSS(STRSTREAM, relop.start, relop.start))->chars);
            	        }

            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_anyValue_in_guardExpression3279);
            	        lhs=anyValue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_anyValue_in_guardExpression3283);
            	        rhs=anyValue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // NDDL/base/antlr/NDDL3Tree.g:716:13: lhs= anyValue
            	    {
            	        FOLLOWPUSH(FOLLOW_anyValue_in_guardExpression3301);
            	        lhs=anyValue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // NDDL/base/antlr/NDDL3Tree.g:717:13: ^( EXPRESSION_RETURN lhs= expressionCleanReturn )
            	    {
            	         MATCHT(EXPRESSION_RETURN, &FOLLOW_EXPRESSION_RETURN_in_guardExpression3316); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_expressionCleanReturn_in_guardExpression3320);
            	        lhs=expressionCleanReturn(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }

            	        {
            	             dom = new BoolDomain(true); 
            	                              rhs = new ExprConstant(dom->getTypeName().c_str(), dom); 
            	                            
            	        }

            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                              result = new ExprIfGuard(relopStr,lhs,rhs);
                          
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleguardExpressionEx; /* Prevent compiler warnings */
    ruleguardExpressionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end guardExpression */

/** 
 * $ANTLR start guardRelop
 * NDDL/base/antlr/NDDL3Tree.g:727:1: guardRelop : ( '==' | '!=' );
 */
static NDDL3Tree_guardRelop_return
guardRelop(pNDDL3Tree ctx)
{   
    NDDL3Tree_guardRelop_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // NDDL/base/antlr/NDDL3Tree.g:728:5: ( '==' | '!=' )
        // NDDL/base/antlr/NDDL3Tree.g:
        {
            if ( ((LA(1) >= 64) && (LA(1) <= 65)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_guardRelop0);    goto ruleguardRelopEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleguardRelopEx; /* Prevent compiler warnings */
    ruleguardRelopEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end guardRelop */

/** 
 * $ANTLR start loopStatement
 * NDDL/base/antlr/NDDL3Tree.g:731:1: loopStatement returns [Expr* result] : ^( 'foreach' name= IDENT val= qualified ruleBlock[loopBody] ) ;
 */
static Expr*
loopStatement(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    name;
    Expr* val;
    #undef	RETURN_TYPE_val
    #define	RETURN_TYPE_val Expr*

    /* Initialize rule variables
     */



        std::vector<Expr*> loopBody;
        const char* loopVarName = NULL;

    name       = NULL;
    val = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:736:2: ( ^( 'foreach' name= IDENT val= qualified ruleBlock[loopBody] ) )
        // NDDL/base/antlr/NDDL3Tree.g:736:4: ^( 'foreach' name= IDENT val= qualified ruleBlock[loopBody] )
        {
             MATCHT(76, &FOLLOW_76_in_loopStatement3410); 
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_loopStatement3417); 
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }

            FOLLOWPUSH(FOLLOW_qualified_in_loopStatement3424);
            val=qualified(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }

            {

                               loopVarName =  c_str((name->getText(name))->chars);
                               CTX->SymbolTable->addLocalVar(loopVarName,val->getDataType());
                			
            }
            FOLLOWPUSH(FOLLOW_ruleBlock_in_loopStatement3436);
            ruleBlock(ctx, loopBody);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }

            {

                		    // TODO : modify ExprLoop to take val Expr instead, otherwise delete val.
                		    result = new ExprLoop(loopVarName,val->toString().c_str(),loopBody); 
                		    delete val;
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleloopStatementEx; /* Prevent compiler warnings */
    ruleloopStatementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end loopStatement */

/** 
 * $ANTLR start problemStmt
 * NDDL/base/antlr/NDDL3Tree.g:752:1: problemStmt returns [Expr* result] : ^(t= problemStmtType predicateInstanceList[tokens] ) ;
 */
static Expr*
problemStmt(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    NDDL3Tree_problemStmtType_return t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t NDDL3Tree_problemStmtType_return

    /* Initialize rule variables
     */



        std::vector<PredicateInstanceRef*> tokens;    

    {
        // NDDL/base/antlr/NDDL3Tree.g:757:9: ( ^(t= problemStmtType predicateInstanceList[tokens] ) )
        // NDDL/base/antlr/NDDL3Tree.g:757:17: ^(t= problemStmtType predicateInstanceList[tokens] )
        {
            FOLLOWPUSH(FOLLOW_problemStmtType_in_problemStmt3483);
            t=problemStmtType(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproblemStmtEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleproblemStmtEx;
            }

            FOLLOWPUSH(FOLLOW_predicateInstanceList_in_problemStmt3485);
            predicateInstanceList(ctx, tokens);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproblemStmtEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleproblemStmtEx;
            }

            {

                                    result = new ExprProblemStmt(c_str((STRSTREAM->toStringSS(STRSTREAM, t.start, t.start))->chars),tokens);
                                
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleproblemStmtEx; /* Prevent compiler warnings */
    ruleproblemStmtEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end problemStmt */

/** 
 * $ANTLR start problemStmtType
 * NDDL/base/antlr/NDDL3Tree.g:763:1: problemStmtType : ( 'goal' | 'rejectable' | 'fact' );
 */
static NDDL3Tree_problemStmtType_return
problemStmtType(pNDDL3Tree ctx)
{   
    NDDL3Tree_problemStmtType_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // NDDL/base/antlr/NDDL3Tree.g:764:9: ( 'goal' | 'rejectable' | 'fact' )
        // NDDL/base/antlr/NDDL3Tree.g:
        {
            if ( ((LA(1) >= 57) && (LA(1) <= 59)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_problemStmtType0);    goto ruleproblemStmtTypeEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleproblemStmtTypeEx; /* Prevent compiler warnings */
    ruleproblemStmtTypeEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end problemStmtType */

/** 
 * $ANTLR start relation
 * NDDL/base/antlr/NDDL3Tree.g:769:1: relation returns [Expr* result] : ^( TOKEN_RELATION (i= IDENT )? tr= temporalRelation predicateInstanceList[targets] ) ;
 */
static Expr*
relation(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    i;
    NDDL3Tree_temporalRelation_return tr;
    #undef	RETURN_TYPE_tr
    #define	RETURN_TYPE_tr NDDL3Tree_temporalRelation_return

    /* Initialize rule variables
     */



        const char* relationType=NULL;
        PredicateInstanceRef* source=NULL;
        std::vector<PredicateInstanceRef*> targets;    

    i       = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:775:2: ( ^( TOKEN_RELATION (i= IDENT )? tr= temporalRelation predicateInstanceList[targets] ) )
        // NDDL/base/antlr/NDDL3Tree.g:775:4: ^( TOKEN_RELATION (i= IDENT )? tr= temporalRelation predicateInstanceList[targets] )
        {
             MATCHT(TOKEN_RELATION, &FOLLOW_TOKEN_RELATION_in_relation3620); 
            if  (HASEXCEPTION())
            {
                goto rulerelationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerelationEx;
            }


            // NDDL/base/antlr/NDDL3Tree.g:776:4: (i= IDENT )?
            {
                int alt34=2;
                {
                    int LA34_0 = LA(1);
                    if ( (LA34_0 == IDENT) ) 
                    {
                        alt34=1;
                    }
                }
                switch (alt34) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:776:5: i= IDENT
            	    {
            	        i = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_relation3628); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerelationEx;
            	        }

            	        {
            	             source = new PredicateInstanceRef(NULL,c_str((i->getText(i))->chars)); 
            	        }

            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_temporalRelation_in_relation3639);
            tr=temporalRelation(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerelationEx;
            }

            {
                 relationType = c_str((STRSTREAM->toStringSS(STRSTREAM, tr.start, tr.start))->chars); 
            }
            FOLLOWPUSH(FOLLOW_predicateInstanceList_in_relation3647);
            predicateInstanceList(ctx, targets);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerelationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerelationEx;
            }

            {
                		   
                		    result = new ExprRelation(relationType,source,targets);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerelationEx; /* Prevent compiler warnings */
    rulerelationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end relation */

/** 
 * $ANTLR start predicateInstanceList
 * NDDL/base/antlr/NDDL3Tree.g:785:1: predicateInstanceList[std::vector<PredicateInstanceRef*>& instances] : ( ^( '(' (child= predicateInstance )* ) | i= IDENT );
 */
static void
predicateInstanceList(pNDDL3Tree ctx, std::vector<PredicateInstanceRef*>& instances)
{   
    pANTLR3_BASE_TREE    i;
    PredicateInstanceRef* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child PredicateInstanceRef*

    /* Initialize rule variables
     */


    i       = NULL;
    child = NULL;

    {
        {
            //  NDDL/base/antlr/NDDL3Tree.g:786:2: ( ^( '(' (child= predicateInstance )* ) | i= IDENT )
            
            ANTLR3_UINT32 alt36;

            alt36=2;


            {
                int LA36_0 = LA(1);
                if ( (LA36_0 == 41) ) 
                {
                    alt36=1;
                }
                else if ( (LA36_0 == IDENT) ) 
                {
                    alt36=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 36;
                    EXCEPTION->state        = 0;


                    goto rulepredicateInstanceListEx;
                }
            }
            switch (alt36) 
            {
        	case 1:
        	    // NDDL/base/antlr/NDDL3Tree.g:786:4: ^( '(' (child= predicateInstance )* )
        	    {
        	         MATCHT(41, &FOLLOW_41_in_predicateInstanceList3669); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepredicateInstanceListEx;
        	        }


        	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulepredicateInstanceListEx;
        	            }


        	            // NDDL/base/antlr/NDDL3Tree.g:787:4: (child= predicateInstance )*

        	            for (;;)
        	            {
        	                int alt35=2;
        	                {
        	                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                    */
        	                    int LA35_0 = LA(1);
        	                    if ( (LA35_0 == PREDICATE_INSTANCE) ) 
        	                    {
        	                        alt35=1;
        	                    }

        	                }
        	                switch (alt35) 
        	                {
        	            	case 1:
        	            	    // NDDL/base/antlr/NDDL3Tree.g:787:5: child= predicateInstance
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_predicateInstance_in_predicateInstanceList3677);
        	            	        child=predicateInstance(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulepredicateInstanceListEx;
        	            	        }

        	            	        {
        	            	             instances.push_back(child); 
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop35;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop35: ; /* Jump out to here if this rule does not match */


        	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulepredicateInstanceListEx;
        	            }

        	        }

        	    }
        	    break;
        	case 2:
        	    // NDDL/base/antlr/NDDL3Tree.g:789:5: i= IDENT
        	    {
        	        i = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_predicateInstanceList3693); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepredicateInstanceListEx;
        	        }

        	        {
        	             instances.push_back(new PredicateInstanceRef(NULL,c_str((i->getText(i))->chars))); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulepredicateInstanceListEx; /* Prevent compiler warnings */
    rulepredicateInstanceListEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end predicateInstanceList */

/** 
 * $ANTLR start predicateInstance
 * NDDL/base/antlr/NDDL3Tree.g:793:1: predicateInstance returns [PredicateInstanceRef* pi] : ^( PREDICATE_INSTANCE qualifiedToken[tokenStr,tokenType] (i= IDENT )? ) ;
 */
static PredicateInstanceRef*
predicateInstance(pNDDL3Tree ctx)
{   
    PredicateInstanceRef* pi = NULL;

    pANTLR3_BASE_TREE    i;

    /* Initialize rule variables
     */



        const char* name = NULL;
        std::string tokenStr;
        TokenTypeId tokenType;

    i       = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:799:2: ( ^( PREDICATE_INSTANCE qualifiedToken[tokenStr,tokenType] (i= IDENT )? ) )
        // NDDL/base/antlr/NDDL3Tree.g:799:4: ^( PREDICATE_INSTANCE qualifiedToken[tokenStr,tokenType] (i= IDENT )? )
        {
             MATCHT(PREDICATE_INSTANCE, &FOLLOW_PREDICATE_INSTANCE_in_predicateInstance3728); 
            if  (HASEXCEPTION())
            {
                goto rulepredicateInstanceEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepredicateInstanceEx;
            }

            FOLLOWPUSH(FOLLOW_qualifiedToken_in_predicateInstance3730);
            qualifiedToken(ctx, tokenStr, tokenType);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepredicateInstanceEx;
            }


            // NDDL/base/antlr/NDDL3Tree.g:799:60: (i= IDENT )?
            {
                int alt37=2;
                {
                    int LA37_0 = LA(1);
                    if ( (LA37_0 == IDENT) ) 
                    {
                        alt37=1;
                    }
                }
                switch (alt37) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:799:61: i= IDENT
            	    {
            	        i = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_predicateInstance3736); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepredicateInstanceEx;
            	        }

            	        {
            	             name = c_str((i->getText(i))->chars); 
            	        }

            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepredicateInstanceEx;
            }

            {

                	            pi = new PredicateInstanceRef(tokenStr.c_str(),name);
                	            if (name != NULL)
                	                CTX->SymbolTable->addLocalToken(name,tokenType);
                	        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepredicateInstanceEx; /* Prevent compiler warnings */
    rulepredicateInstanceEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return pi;
}
/* $ANTLR end predicateInstance */

/** 
 * $ANTLR start qualifiedString
 * NDDL/base/antlr/NDDL3Tree.g:807:1: qualifiedString[std::string& result] : (name= identifier | ^( '.' prefix= qualifiedString[result] (q= IDENT )+ ) ) ;
 */
static void
qualifiedString(pNDDL3Tree ctx, std::string& result)
{   
    pANTLR3_BASE_TREE    q;
    NDDL3Tree_identifier_return name;
    #undef	RETURN_TYPE_name
    #define	RETURN_TYPE_name NDDL3Tree_identifier_return

    /* Initialize rule variables
     */


    q       = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:808:5: ( (name= identifier | ^( '.' prefix= qualifiedString[result] (q= IDENT )+ ) ) )
        // NDDL/base/antlr/NDDL3Tree.g:809:5: (name= identifier | ^( '.' prefix= qualifiedString[result] (q= IDENT )+ ) )
        {

            // NDDL/base/antlr/NDDL3Tree.g:809:5: (name= identifier | ^( '.' prefix= qualifiedString[result] (q= IDENT )+ ) )
            {
                int alt39=2;

                {
                    int LA39_0 = LA(1);
                    if ( (LA39_0 == IDENT || LA39_0 == 45) ) 
                    {
                        alt39=1;
                    }
                    else if ( (LA39_0 == 46) ) 
                    {
                        alt39=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 39;
                        EXCEPTION->state        = 0;


                        goto rulequalifiedStringEx;
                    }
                }
                switch (alt39) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:809:10: name= identifier
            	    {
            	        FOLLOWPUSH(FOLLOW_identifier_in_qualifiedString3779);
            	        name=identifier(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequalifiedStringEx;
            	        }

            	        {
            	             result+=c_str((STRSTREAM->toStringSS(STRSTREAM, name.start, name.start))->chars); 
            	        }

            	    }
            	    break;
            	case 2:
            	    // NDDL/base/antlr/NDDL3Tree.g:810:10: ^( '.' prefix= qualifiedString[result] (q= IDENT )+ )
            	    {
            	         MATCHT(46, &FOLLOW_46_in_qualifiedString3810); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequalifiedStringEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequalifiedStringEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_qualifiedString_in_qualifiedString3814);
            	        qualifiedString(ctx, result);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequalifiedStringEx;
            	        }

            	        // NDDL/base/antlr/NDDL3Tree.g:811:16: (q= IDENT )+
            	        {
            	            int cnt38=0;

            	            for (;;)
            	            {
            	                int alt38=2;
            	        	{
            	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	        	    */
            	        	    int LA38_0 = LA(1);
            	        	    if ( (LA38_0 == IDENT) ) 
            	        	    {
            	        	        alt38=1;
            	        	    }

            	        	}
            	        	switch (alt38) 
            	        	{
            	        	    case 1:
            	        	        // NDDL/base/antlr/NDDL3Tree.g:811:17: q= IDENT
            	        	        {
            	        	            q = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_qualifiedString3836); 
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto rulequalifiedStringEx;
            	        	            }

            	        	            {
            	        	                 result += std::string(".") + c_str((q->getText(q))->chars); 
            	        	            }

            	        	        }
            	        	        break;

            	        	    default:
            	        	    
            	        		if ( cnt38 >= 1 )
            	        		{
            	        		    goto loop38;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto rulequalifiedStringEx;
            	        	}
            	        	cnt38++;
            	            }
            	            loop38: ;	/* Jump to here if this rule does not match */
            	        }

            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequalifiedStringEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulequalifiedStringEx; /* Prevent compiler warnings */
    rulequalifiedStringEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end qualifiedString */

/** 
 * $ANTLR start qualified
 * NDDL/base/antlr/NDDL3Tree.g:815:1: qualified returns [Expr* result] : qualifiedString[varName] ;
 */
static Expr*
qualified(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    /* Initialize rule variables
     */



        std::string varName;

    {
        // NDDL/base/antlr/NDDL3Tree.g:819:5: ( qualifiedString[varName] )
        // NDDL/base/antlr/NDDL3Tree.g:819:9: qualifiedString[varName]
        {
            FOLLOWPUSH(FOLLOW_qualifiedString_in_qualified3887);
            qualifiedString(ctx, varName);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulequalifiedEx;
            }

            {

                                bool isEnum = false;
                  
                                //My guess is that there is a better way to do this. First check if it is an enum.
                                std::string secondPart = "";
                                if (varName.rfind(".") != std::string::npos) {
                                   secondPart = varName.substr(varName.rfind(".") + 1, std::string::npos);
                                }

                                if (CTX->SymbolTable->isEnumValue(varName.c_str())) {
                                   result = CTX->SymbolTable->makeEnumRef(varName.c_str());
                                   isEnum = true;
                                } else if (secondPart != "") {
                                   if (CTX->SymbolTable->isEnumValue(secondPart.c_str())) {
                                      result = CTX->SymbolTable->makeEnumRef(secondPart.c_str());
                                      isEnum = true;
                                   }
                                }
                  
                  				// TODO: should check for classes last, since this won't be common
                		        ObjectTypeId ot = CTX->SymbolTable->getObjectType(varName.c_str()); // Hack!
                        		if (ot.isId())  { // is a class reference
                            		LabelStr value(varName);
                            		result = new ExprConstant("string",new StringDomain((edouble)value,StringDT::instance()));
                        		}        		
                                else if (!isEnum) {
                                	std::string errorMsg;
                                	DataTypeId dt = CTX->SymbolTable->getTypeForVar(varName.c_str(),errorMsg);  
                                	// TODO!!: do type checking at each "."
                                	if (dt.isNoId())
                                    	reportSemanticError(CTX,errorMsg);
                                   	result = new ExprVarRef(varName.c_str(),dt);
                                }
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulequalifiedEx; /* Prevent compiler warnings */
    rulequalifiedEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end qualified */

/** 
 * $ANTLR start qualifiedToken
 * NDDL/base/antlr/NDDL3Tree.g:856:1: qualifiedToken[std::string& tokenStr, TokenTypeId& tokenType] : qualifiedString[tokenStr] ;
 */
static void
qualifiedToken(pNDDL3Tree ctx, std::string& tokenStr, TokenTypeId& tokenType)
{   
    /* Initialize rule variables
     */


    {
        // NDDL/base/antlr/NDDL3Tree.g:857:5: ( qualifiedString[tokenStr] )
        // NDDL/base/antlr/NDDL3Tree.g:857:9: qualifiedString[tokenStr]
        {
            FOLLOWPUSH(FOLLOW_qualifiedString_in_qualifiedToken3926);
            qualifiedString(ctx, tokenStr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulequalifiedTokenEx;
            }

            {

                            std::string errorMsg;
                            tokenType = CTX->SymbolTable->getTypeForToken(tokenStr.c_str(),errorMsg);  
                            if (tokenType.isNoId())
                               reportSemanticError(CTX,errorMsg);
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulequalifiedTokenEx; /* Prevent compiler warnings */
    rulequalifiedTokenEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end qualifiedToken */

/** 
 * $ANTLR start temporalRelation
 * NDDL/base/antlr/NDDL3Tree.g:866:1: temporalRelation : ( 'after' | 'any' | 'before' | 'contained_by' | 'contains' | 'contains_end' | 'contains_start' | 'ends' | 'ends_after' | 'ends_after_start' | 'ends_before' | 'ends_during' | 'equal' | 'equals' | 'meets' | 'met_by' | 'parallels' | 'paralleled_by' | 'starts' | 'starts_after' | 'starts_before' | 'starts_before_end' | 'starts_during' );
 */
static NDDL3Tree_temporalRelation_return
temporalRelation(pNDDL3Tree ctx)
{   
    NDDL3Tree_temporalRelation_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // NDDL/base/antlr/NDDL3Tree.g:867:9: ( 'after' | 'any' | 'before' | 'contained_by' | 'contains' | 'contains_end' | 'contains_start' | 'ends' | 'ends_after' | 'ends_after_start' | 'ends_before' | 'ends_during' | 'equal' | 'equals' | 'meets' | 'met_by' | 'parallels' | 'paralleled_by' | 'starts' | 'starts_after' | 'starts_before' | 'starts_before_end' | 'starts_during' )
        // NDDL/base/antlr/NDDL3Tree.g:
        {
            if ( ((LA(1) >= 77) && (LA(1) <= 99)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_temporalRelation0);    goto ruletemporalRelationEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletemporalRelationEx; /* Prevent compiler warnings */
    ruletemporalRelationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end temporalRelation */

/** 
 * $ANTLR start methodInvocation
 * NDDL/base/antlr/NDDL3Tree.g:892:1: methodInvocation returns [Expr* result] : ( ^( METHOD_CALL v= qualified op= methodName ( variableArgumentList[args] )? ) | ^( CLOSE CLOSE ) );
 */
static Expr*
methodInvocation(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Expr* v;
    #undef	RETURN_TYPE_v
    #define	RETURN_TYPE_v Expr*

    NDDL3Tree_methodName_return op;
    #undef	RETURN_TYPE_op
    #define	RETURN_TYPE_op NDDL3Tree_methodName_return

    /* Initialize rule variables
     */



        std::vector<Expr*> args;

    v = NULL;


    {
        {
            //  NDDL/base/antlr/NDDL3Tree.g:896:2: ( ^( METHOD_CALL v= qualified op= methodName ( variableArgumentList[args] )? ) | ^( CLOSE CLOSE ) )
            
            ANTLR3_UINT32 alt41;

            alt41=2;


            {
                int LA41_0 = LA(1);
                if ( (LA41_0 == METHOD_CALL) ) 
                {
                    alt41=1;
                }
                else if ( (LA41_0 == CLOSE) ) 
                {
                    alt41=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 41;
                    EXCEPTION->state        = 0;


                    goto rulemethodInvocationEx;
                }
            }
            switch (alt41) 
            {
        	case 1:
        	    // NDDL/base/antlr/NDDL3Tree.g:896:4: ^( METHOD_CALL v= qualified op= methodName ( variableArgumentList[args] )? )
        	    {
        	         MATCHT(METHOD_CALL, &FOLLOW_METHOD_CALL_in_methodInvocation4403); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemethodInvocationEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemethodInvocationEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_qualified_in_methodInvocation4407);
        	        v=qualified(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemethodInvocationEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_methodName_in_methodInvocation4411);
        	        op=methodName(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemethodInvocationEx;
        	        }


        	        // NDDL/base/antlr/NDDL3Tree.g:896:44: ( variableArgumentList[args] )?
        	        {
        	            int alt40=2;
        	            {
        	                int LA40_0 = LA(1);
        	                if ( (LA40_0 == 41) ) 
        	                {
        	                    alt40=1;
        	                }
        	            }
        	            switch (alt40) 
        	            {
        	        	case 1:
        	        	    // NDDL/base/antlr/NDDL3Tree.g:896:44: variableArgumentList[args]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_variableArgumentList_in_methodInvocation4413);
        	        	        variableArgumentList(ctx, args);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemethodInvocationEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemethodInvocationEx;
        	        }

        	        {

        	                    std::string mName = c_str((STRSTREAM->toStringSS(STRSTREAM, op.start, op.start))->chars);

        	                    // Hack! data type for v should tell us whether we're dealing with a class
        	                    ExprConstant* classNameExpr = dynamic_cast<ExprConstant*>(v);
        	                    if (classNameExpr != NULL) {
        	                        std::string className = classNameExpr->getConstantValue();
        	                        debugMsg("NddlInterpreter:method","Trying class:"+className);
        	                        ObjectTypeId ot = CTX->SymbolTable->getObjectType(className.c_str()); 
        	                        if (ot.isId())  { // is a class method
        	                            LabelStr value(mName);
        	                            mName = "class__"+mName;    
        	                        }
        	                    }
        	                        
        	                    MethodId method = CTX->SymbolTable->getMethod(mName.c_str(),v,args);
        	                    if (method.isNoId())
        	                        reportSemanticError(CTX,"Method "+mName+" is not defined");
        	                    result = new ExprMethodCall(method,v,args);
        	                
        	        }

        	    }
        	    break;
        	case 2:
        	    // NDDL/base/antlr/NDDL3Tree.g:917:7: ^( CLOSE CLOSE )
        	    {
        	         MATCHT(CLOSE, &FOLLOW_CLOSE_in_methodInvocation4431); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemethodInvocationEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemethodInvocationEx;
        	        }

        	         MATCHT(CLOSE, &FOLLOW_CLOSE_in_methodInvocation4433); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemethodInvocationEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemethodInvocationEx;
        	        }

        	        {

        	                    // TODO: hack!
        	                    Expr* varExpr = NULL;
        	                    MethodId method = CTX->SymbolTable->getMethod("pdb_close",varExpr,args);
        	                    result = new ExprMethodCall(method,varExpr,args);
        	                
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulemethodInvocationEx; /* Prevent compiler warnings */
    rulemethodInvocationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end methodInvocation */

/** 
 * $ANTLR start methodName
 * NDDL/base/antlr/NDDL3Tree.g:926:1: methodName : ( IDENT | 'close' );
 */
static NDDL3Tree_methodName_return
methodName(pNDDL3Tree ctx)
{   
    NDDL3Tree_methodName_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // NDDL/base/antlr/NDDL3Tree.g:927:2: ( IDENT | 'close' )
        // NDDL/base/antlr/NDDL3Tree.g:
        {
            if ( LA(1) == IDENT || LA(1) == 106 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_methodName0);    goto rulemethodNameEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemethodNameEx; /* Prevent compiler warnings */
    rulemethodNameEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end methodName */

/** 
 * $ANTLR start cexpressionList
 * NDDL/base/antlr/NDDL3Tree.g:931:1: cexpressionList[std::vector<CExpr*> &args] : (expr= cexpression )* ;
 */
static void
cexpressionList(pNDDL3Tree ctx, std::vector<CExpr*> &args)
{   
    CExpr* expr;
    #undef	RETURN_TYPE_expr
    #define	RETURN_TYPE_expr CExpr*

    /* Initialize rule variables
     */


    expr = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:932:2: ( (expr= cexpression )* )
        // NDDL/base/antlr/NDDL3Tree.g:932:5: (expr= cexpression )*
        {

            // NDDL/base/antlr/NDDL3Tree.g:932:5: (expr= cexpression )*

            for (;;)
            {
                int alt42=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA42_0 = LA(1);
                    if ( (LA42_0 == FUNCTION_CALL || ((LA42_0 >= IDENT) && (LA42_0 <= STRING)) || LA42_0 == 33 || LA42_0 == 38 || ((LA42_0 >= 45) && (LA42_0 <= 46)) || ((LA42_0 >= 62) && (LA42_0 <= 72)) || ((LA42_0 >= 100) && (LA42_0 <= 105))) ) 
                    {
                        alt42=1;
                    }

                }
                switch (alt42) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:932:6: expr= cexpression
            	    {
            	        FOLLOWPUSH(FOLLOW_cexpression_in_cexpressionList4473);
            	        expr=cexpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecexpressionListEx;
            	        }

            	        {
            	             args.push_back(expr); 
            	        }

            	    }
            	    break;

            	default:
            	    goto loop42;	/* break out of the loop */
            	    break;
                }
            }
            loop42: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecexpressionListEx; /* Prevent compiler warnings */
    rulecexpressionListEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end cexpressionList */

/** 
 * $ANTLR start cexpression
 * NDDL/base/antlr/NDDL3Tree.g:935:1: cexpression returns [CExpr* result] : ( ^(cop= cexprOp leftValue= cexpression rightValue= cexpression ) | r= anyValue | ^( FUNCTION_CALL name= IDENT ^( '(' cexpressionList[args] ) ) );
 */
static CExpr*
cexpression(pNDDL3Tree ctx)
{   
    CExpr* result = NULL;

    pANTLR3_BASE_TREE    name;
    NDDL3Tree_cexprOp_return cop;
    #undef	RETURN_TYPE_cop
    #define	RETURN_TYPE_cop NDDL3Tree_cexprOp_return

    CExpr* leftValue;
    #undef	RETURN_TYPE_leftValue
    #define	RETURN_TYPE_leftValue CExpr*

    CExpr* rightValue;
    #undef	RETURN_TYPE_rightValue
    #define	RETURN_TYPE_rightValue CExpr*

    Expr* r;
    #undef	RETURN_TYPE_r
    #define	RETURN_TYPE_r Expr*

    /* Initialize rule variables
     */


     
        std::vector<CExpr*> args; 

    name       = NULL;

    leftValue = NULL;
    rightValue = NULL;
    r = NULL;

    {
        {
            //  NDDL/base/antlr/NDDL3Tree.g:939:2: ( ^(cop= cexprOp leftValue= cexpression rightValue= cexpression ) | r= anyValue | ^( FUNCTION_CALL name= IDENT ^( '(' cexpressionList[args] ) ) )
            
            ANTLR3_UINT32 alt43;

            alt43=3;

            switch ( LA(1) ) 
            {
            case 62:
            case 63:
            case 64:
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 72:
            	{
            		alt43=1;
            	}
                break;
            case IDENT:
            case INT:
            case FLOAT:
            case STRING:
            case 33:
            case 38:
            case 45:
            case 46:
            case 100:
            case 101:
            case 102:
            case 103:
            case 104:
            case 105:
            	{
            		alt43=2;
            	}
                break;
            case FUNCTION_CALL:
            	{
            		alt43=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 43;
                EXCEPTION->state        = 0;


                goto rulecexpressionEx;
            }

            switch (alt43) 
            {
        	case 1:
        	    // NDDL/base/antlr/NDDL3Tree.g:939:4: ^(cop= cexprOp leftValue= cexpression rightValue= cexpression )
        	    {
        	        FOLLOWPUSH(FOLLOW_cexprOp_in_cexpression4501);
        	        cop=cexprOp(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_cexpression_in_cexpression4505);
        	        leftValue=cexpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_cexpression_in_cexpression4509);
        	        rightValue=cexpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecexpressionEx;
        	        }

        	        {

        	                       std::string op = c_str((STRSTREAM->toStringSS(STRSTREAM, cop.start, cop.start))->chars);
        	                       result = new CExprBinary(op, leftValue, rightValue);
        	                    
        	        }

        	    }
        	    break;
        	case 2:
        	    // NDDL/base/antlr/NDDL3Tree.g:944:4: r= anyValue
        	    {
        	        FOLLOWPUSH(FOLLOW_anyValue_in_cexpression4527);
        	        r=anyValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecexpressionEx;
        	        }

        	        {

        	                       result = new CExprValue(r);
        	                    
        	        }

        	    }
        	    break;
        	case 3:
        	    // NDDL/base/antlr/NDDL3Tree.g:948:4: ^( FUNCTION_CALL name= IDENT ^( '(' cexpressionList[args] ) )
        	    {
        	         MATCHT(FUNCTION_CALL, &FOLLOW_FUNCTION_CALL_in_cexpression4543); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecexpressionEx;
        	        }

        	        name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_cexpression4547); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecexpressionEx;
        	        }

        	         MATCHT(41, &FOLLOW_41_in_cexpression4550); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecexpressionEx;
        	        }


        	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulecexpressionEx;
        	            }

        	            FOLLOWPUSH(FOLLOW_cexpressionList_in_cexpression4552);
        	            cexpressionList(ctx, args);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulecexpressionEx;
        	            }


        	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulecexpressionEx;
        	            }

        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecexpressionEx;
        	        }

        	        {

        	                        std::string fName = c_str((name->getText(name))->chars);
        	                        CFunctionId func = CTX->SymbolTable->getCFunction(fName.c_str(),args);

        	                        if (func.isNoId()) 
        	                            reportSemanticError(CTX, "CFunction does not exist: " + fName);
        	                                    
        	                        result = new CExprFunction(func, args);
        	                    
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecexpressionEx; /* Prevent compiler warnings */
    rulecexpressionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end cexpression */

/** 
 * $ANTLR start cexprOp
 * NDDL/base/antlr/NDDL3Tree.g:960:1: cexprOp : ( '==' | '!=' | '<' | '<=' | '>' | '>=' | '||' | '&&' | '+' | '-' | '*' );
 */
static NDDL3Tree_cexprOp_return
cexprOp(pNDDL3Tree ctx)
{   
    NDDL3Tree_cexprOp_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // NDDL/base/antlr/NDDL3Tree.g:961:2: ( '==' | '!=' | '<' | '<=' | '>' | '>=' | '||' | '&&' | '+' | '-' | '*' )
        // NDDL/base/antlr/NDDL3Tree.g:
        {
            if ( ((LA(1) >= 62) && (LA(1) <= 72)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_cexprOp0);    goto rulecexprOpEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecexprOpEx; /* Prevent compiler warnings */
    rulecexprOpEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end cexprOp */

/** 
 * $ANTLR start enforceExpression
 * NDDL/base/antlr/NDDL3Tree.g:974:1: enforceExpression returns [Expr* result] : ^( EXPRESSION_ENFORCE value= cexpression ( violationMsg[vmsg] )? ) ;
 */
static Expr*
enforceExpression(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    CExpr* value;
    #undef	RETURN_TYPE_value
    #define	RETURN_TYPE_value CExpr*

    /* Initialize rule variables
     */


     
    	BoolDomain* dom = NULL; 
    	ExprConstant* con = NULL; 
    	std::vector<Expr*> args; 
    	std::string vmsg;

    value = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:981:2: ( ^( EXPRESSION_ENFORCE value= cexpression ( violationMsg[vmsg] )? ) )
        // NDDL/base/antlr/NDDL3Tree.g:981:4: ^( EXPRESSION_ENFORCE value= cexpression ( violationMsg[vmsg] )? )
        {
             MATCHT(EXPRESSION_ENFORCE, &FOLLOW_EXPRESSION_ENFORCE_in_enforceExpression4647); 
            if  (HASEXCEPTION())
            {
                goto ruleenforceExpressionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleenforceExpressionEx;
            }

            FOLLOWPUSH(FOLLOW_cexpression_in_enforceExpression4651);
            value=cexpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleenforceExpressionEx;
            }


            // NDDL/base/antlr/NDDL3Tree.g:981:43: ( violationMsg[vmsg] )?
            {
                int alt44=2;
                {
                    int LA44_0 = LA(1);
                    if ( (LA44_0 == STRING) ) 
                    {
                        alt44=1;
                    }
                }
                switch (alt44) 
                {
            	case 1:
            	    // NDDL/base/antlr/NDDL3Tree.g:981:43: violationMsg[vmsg]
            	    {
            	        FOLLOWPUSH(FOLLOW_violationMsg_in_enforceExpression4653);
            	        violationMsg(ctx, vmsg);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleenforceExpressionEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleenforceExpressionEx;
            }

            {
                 
                            value->setEnforceContext();
                            value->setViolationMsg(vmsg);
                            
                            /*try {
                                value->checkType();
                            } catch(std::string msg) {
                                reportSemanticError(CTX, msg);
                            }*/
                            
                            if (value->hasReturnValue()) {
                                dom = new BoolDomain(true); 
                                con = new ExprConstant(dom->getTypeName().c_str(), dom); 
                                args.push_back(value);
                                args.push_back(con);    
                                result = new ExprConstraint("eq", args, NULL);
                            } else {
                                result = value;
                            }
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleenforceExpressionEx; /* Prevent compiler warnings */
    ruleenforceExpressionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end enforceExpression */

/** 
 * $ANTLR start expressionCleanReturn
 * NDDL/base/antlr/NDDL3Tree.g:1004:1: expressionCleanReturn returns [Expr* result] : e= cexpression ;
 */
static Expr*
expressionCleanReturn(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    CExpr* e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e CExpr*

    /* Initialize rule variables
     */


    e = NULL;

    {
        // NDDL/base/antlr/NDDL3Tree.g:1005:2: (e= cexpression )
        // NDDL/base/antlr/NDDL3Tree.g:1005:4: e= cexpression
        {
            FOLLOWPUSH(FOLLOW_cexpression_in_expressionCleanReturn4681);
            e=cexpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpressionCleanReturnEx;
            }

            {
                 result = e; 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexpressionCleanReturnEx; /* Prevent compiler warnings */
    ruleexpressionCleanReturnEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end expressionCleanReturn */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
