/** \file
 *  This C source file was generated by $ANTLR version 3.1.1
 *
 *     -  From the grammar source file : ../base/antlr/NDDL3Tree.g
 *     -                            On : 2009-03-02 08:44:11
 *     -           for the tree parser : NDDL3TreeTreeParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "NDDL3Tree.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pNDDL3Tree_##scope##_SCOPE
#define SCOPE_STACK(scope)  pNDDL3Tree_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pNDDL3Tree_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO		
#undef		SEEK    
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   NDDL3TreeTokenNames[96+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "CONSTRUCTOR",
        (pANTLR3_UINT8) "CONSTRUCTOR_INVOCATION",
        (pANTLR3_UINT8) "CONSTRAINT_INSTANTIATION",
        (pANTLR3_UINT8) "NDDL",
        (pANTLR3_UINT8) "TOKEN_RELATION",
        (pANTLR3_UINT8) "VARIABLE",
        (pANTLR3_UINT8) "IDENT",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "INT",
        (pANTLR3_UINT8) "FLOAT",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "INCLUDE",
        (pANTLR3_UINT8) "ESCAPE_SEQUENCE",
        (pANTLR3_UINT8) "UNICODE_ESC",
        (pANTLR3_UINT8) "OCTAL_ESC",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "INT_SUFFIX",
        (pANTLR3_UINT8) "EXPONENT",
        (pANTLR3_UINT8) "FLOAT_SUFFIX",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "LINE_COMMENT",
        (pANTLR3_UINT8) "'typedef'",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'int'",
        (pANTLR3_UINT8) "'float'",
        (pANTLR3_UINT8) "'bool'",
        (pANTLR3_UINT8) "'string'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'}'",
        (pANTLR3_UINT8) "'filter'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'new'",
        (pANTLR3_UINT8) "'this'",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'in'",
        (pANTLR3_UINT8) "'class'",
        (pANTLR3_UINT8) "'extends'",
        (pANTLR3_UINT8) "'predicate'",
        (pANTLR3_UINT8) "'::'",
        (pANTLR3_UINT8) "'rejectable'",
        (pANTLR3_UINT8) "'goal'",
        (pANTLR3_UINT8) "'fact'",
        (pANTLR3_UINT8) "'super'",
        (pANTLR3_UINT8) "'if'",
        (pANTLR3_UINT8) "'else'",
        (pANTLR3_UINT8) "'foreach'",
        (pANTLR3_UINT8) "'=='",
        (pANTLR3_UINT8) "'!='",
        (pANTLR3_UINT8) "'after'",
        (pANTLR3_UINT8) "'any'",
        (pANTLR3_UINT8) "'before'",
        (pANTLR3_UINT8) "'contained_by'",
        (pANTLR3_UINT8) "'contains'",
        (pANTLR3_UINT8) "'contains_end'",
        (pANTLR3_UINT8) "'contains_start'",
        (pANTLR3_UINT8) "'ends'",
        (pANTLR3_UINT8) "'ends_after'",
        (pANTLR3_UINT8) "'ends_after_start'",
        (pANTLR3_UINT8) "'ends_before'",
        (pANTLR3_UINT8) "'ends_during'",
        (pANTLR3_UINT8) "'equal'",
        (pANTLR3_UINT8) "'equals'",
        (pANTLR3_UINT8) "'meets'",
        (pANTLR3_UINT8) "'met_by'",
        (pANTLR3_UINT8) "'parallels'",
        (pANTLR3_UINT8) "'paralleled_by'",
        (pANTLR3_UINT8) "'starts'",
        (pANTLR3_UINT8) "'starts_after'",
        (pANTLR3_UINT8) "'starts_before'",
        (pANTLR3_UINT8) "'starts_before_end'",
        (pANTLR3_UINT8) "'starts_during'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'inf'",
        (pANTLR3_UINT8) "'-inf'",
        (pANTLR3_UINT8) "'true'",
        (pANTLR3_UINT8) "'false'",
        (pANTLR3_UINT8) "'specify'",
        (pANTLR3_UINT8) "'reset'",
        (pANTLR3_UINT8) "'constrain'",
        (pANTLR3_UINT8) "'free'",
        (pANTLR3_UINT8) "'activate'",
        (pANTLR3_UINT8) "'merge'",
        (pANTLR3_UINT8) "'reject'",
        (pANTLR3_UINT8) "'cancel'",
        (pANTLR3_UINT8) "'close'",
        (pANTLR3_UINT8) "'constraint'",
        (pANTLR3_UINT8) "'&&'",
        (pANTLR3_UINT8) "'||'",
        (pANTLR3_UINT8) "'<:'",
        (pANTLR3_UINT8) "'numeric'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static void	nddl    (pNDDL3Tree ctx);
static Expr*	typeDefinition    (pNDDL3Tree ctx);
static AbstractDomain*	type    (pNDDL3Tree ctx);
static AbstractDomain*	simpleType    (pNDDL3Tree ctx);
static AbstractDomain*	inlineType    (pNDDL3Tree ctx, AbstractDomain* baseType);
static ExprList*	variableDeclarations    (pNDDL3Tree ctx);
static Expr*	variableInitialization    (pNDDL3Tree ctx, AbstractDomain* dataType);
static Expr*	initializer    (pNDDL3Tree ctx);
static Expr*	anyValue    (pNDDL3Tree ctx);
static Expr*	value    (pNDDL3Tree ctx);
static Expr*	valueSet    (pNDDL3Tree ctx);
static AbstractDomain*	booleanLiteral    (pNDDL3Tree ctx);
static AbstractDomain*	stringLiteral    (pNDDL3Tree ctx);
static AbstractDomain*	numericLiteral    (pNDDL3Tree ctx);
static Expr*	numericInterval    (pNDDL3Tree ctx);
static Expr*	allocation    (pNDDL3Tree ctx);
static void	variableArgumentList    (pNDDL3Tree ctx, std::vector<Expr*>& result);
static NDDL3Tree_identifier_return	identifier    (pNDDL3Tree ctx);
static ExprConstraint*	constraintInstantiation    (pNDDL3Tree ctx);
static Expr*	classDeclaration    (pNDDL3Tree ctx);
static void	classBlock    (pNDDL3Tree ctx, ObjectType* objType);
static void	componentTypeEntry    (pNDDL3Tree ctx, ObjectType* objType);
static void	classVariable    (pNDDL3Tree ctx, ObjectType* objType);
static void	constructor    (pNDDL3Tree ctx, ObjectType* objType);
static void	constructorArgument    (pNDDL3Tree ctx, std::vector<std::string>& argNames, std::vector<std::string>& argTypes);
static ExprConstructorSuperCall*	constructorSuper    (pNDDL3Tree ctx, ObjectType* objType);
static ExprAssignment*	assignment    (pNDDL3Tree ctx);
static void	predicate    (pNDDL3Tree ctx, ObjectType* objType);
static void	predicateStatements    (pNDDL3Tree ctx, InterpretedTokenFactory* tokenFactory);
static Expr*	predicateParameter    (pNDDL3Tree ctx, InterpretedTokenFactory* tokenFactory);
static Expr*	predicateParameterAssignment    (pNDDL3Tree ctx);
static Expr*	standardConstraint    (pNDDL3Tree ctx);
static Expr*	rule    (pNDDL3Tree ctx);
static void	ruleBlock    (pNDDL3Tree ctx, std::vector<Expr*>& ruleBody);
static Expr*	ruleStatement    (pNDDL3Tree ctx);
static Expr*	ifStatement    (pNDDL3Tree ctx);
static ExprIfGuard*	guardExpression    (pNDDL3Tree ctx);
static NDDL3Tree_guardRelop_return	guardRelop    (pNDDL3Tree ctx);
static Expr*	loopStatement    (pNDDL3Tree ctx);
static Expr*	problemStmt    (pNDDL3Tree ctx);
static NDDL3Tree_problemStmtType_return	problemStmtType    (pNDDL3Tree ctx);
static Expr*	relation    (pNDDL3Tree ctx);
static void	predicateInstanceList    (pNDDL3Tree ctx, std::vector<PredicateInstanceRef*>& instances);
static PredicateInstanceRef*	predicateInstance    (pNDDL3Tree ctx);
static Expr*	qualified    (pNDDL3Tree ctx);
static Expr*	qualifiedToken    (pNDDL3Tree ctx);
static NDDL3Tree_temporalRelation_return	temporalRelation    (pNDDL3Tree ctx);
static Expr*	methodInvocation    (pNDDL3Tree ctx);
static Expr*	variableMethod    (pNDDL3Tree ctx);
static NDDL3Tree_variableOp_return	variableOp    (pNDDL3Tree ctx);
static Expr*	tokenMethod    (pNDDL3Tree ctx);
static NDDL3Tree_tokenOp_return	tokenOp    (pNDDL3Tree ctx);
static void	NDDL3TreeFree(pNDDL3Tree ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "../base/antlr/NDDL3Tree.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new NDDL3Tree parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pNDDL3Tree
NDDL3TreeNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return NDDL3TreeNewSSD(instream, NULL);
}

/** \brief Create a new NDDL3Tree parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pNDDL3Tree
NDDL3TreeNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pNDDL3Tree ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pNDDL3Tree) ANTLR3_CALLOC(1, sizeof(NDDL3Tree));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in NDDL3Tree.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);
    /* Install the implementation of our NDDL3Tree interface
     */
    ctx->nddl	= nddl;
    ctx->typeDefinition	= typeDefinition;
    ctx->type	= type;
    ctx->simpleType	= simpleType;
    ctx->inlineType	= inlineType;
    ctx->variableDeclarations	= variableDeclarations;
    ctx->variableInitialization	= variableInitialization;
    ctx->initializer	= initializer;
    ctx->anyValue	= anyValue;
    ctx->value	= value;
    ctx->valueSet	= valueSet;
    ctx->booleanLiteral	= booleanLiteral;
    ctx->stringLiteral	= stringLiteral;
    ctx->numericLiteral	= numericLiteral;
    ctx->numericInterval	= numericInterval;
    ctx->allocation	= allocation;
    ctx->variableArgumentList	= variableArgumentList;
    ctx->identifier	= identifier;
    ctx->constraintInstantiation	= constraintInstantiation;
    ctx->classDeclaration	= classDeclaration;
    ctx->classBlock	= classBlock;
    ctx->componentTypeEntry	= componentTypeEntry;
    ctx->classVariable	= classVariable;
    ctx->constructor	= constructor;
    ctx->constructorArgument	= constructorArgument;
    ctx->constructorSuper	= constructorSuper;
    ctx->assignment	= assignment;
    ctx->predicate	= predicate;
    ctx->predicateStatements	= predicateStatements;
    ctx->predicateParameter	= predicateParameter;
    ctx->predicateParameterAssignment	= predicateParameterAssignment;
    ctx->standardConstraint	= standardConstraint;
    ctx->rule	= rule;
    ctx->ruleBlock	= ruleBlock;
    ctx->ruleStatement	= ruleStatement;
    ctx->ifStatement	= ifStatement;
    ctx->guardExpression	= guardExpression;
    ctx->guardRelop	= guardRelop;
    ctx->loopStatement	= loopStatement;
    ctx->problemStmt	= problemStmt;
    ctx->problemStmtType	= problemStmtType;
    ctx->relation	= relation;
    ctx->predicateInstanceList	= predicateInstanceList;
    ctx->predicateInstance	= predicateInstance;
    ctx->qualified	= qualified;
    ctx->qualifiedToken	= qualifiedToken;
    ctx->temporalRelation	= temporalRelation;
    ctx->methodInvocation	= methodInvocation;
    ctx->variableMethod	= variableMethod;
    ctx->variableOp	= variableOp;
    ctx->tokenMethod	= tokenMethod;
    ctx->tokenOp	= tokenOp;
    ctx->free			= NDDL3TreeFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    


        // TODO: Install custom error message display that gathers them in CTX->SymbolTable
        //RECOGNIZER->displayRecognitionError = reportAntlrError;

        // Add a function with the following signature:
        // void reportAntlrError(pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_UINT8 *tokenNames);    
        // use the meat from displayRecognitionError() in antlr3baserecognizer.c

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = NDDL3TreeTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 NDDL3TreeFree(pNDDL3Tree ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this tree parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return NDDL3TreeTokenNames; 
}



    static const char* c_str(pANTLR3_UINT8 chars)
    {
        // TODO: what's the best way to do this?
        return (const char*)chars;
    }

    // TODO: make sure we also get ANTLR errors, see apifuncs below
    static void reportSemanticError(pNDDL3Tree treeWalker, const std::string& msg)
    {
        // get location. see displayRecognitionError() in antlr3baserecognizer.c
        treeWalker->SymbolTable->addError(msg);
        // TODO: throw exception to abort tree walker?
    }

    static std::string getAutoLabel(const char* prefix)
    {
        static int idx = 0;
        std::ostringstream os;
        os << prefix << "_" << idx++;
        
        return os.str();   
    }

    static DataRef evalExpr(pNDDL3Tree treeWalker,Expr* expr)
    {
        return expr->eval(*(treeWalker->SymbolTable));
    }


    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_NDDL_in_nddl78  */
static	ANTLR3_BITWORD FOLLOW_NDDL_in_nddl78_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NDDL_in_nddl78	= { FOLLOW_NDDL_in_nddl78_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeDefinition_in_nddl94  */
static	ANTLR3_BITWORD FOLLOW_typeDefinition_in_nddl94_bits[]	= { ANTLR3_UINT64_LIT(0x000F210004000368), ANTLR3_UINT64_LIT(0x000000007FC00000) };
static  ANTLR3_BITSET_LIST FOLLOW_typeDefinition_in_nddl94	= { FOLLOW_typeDefinition_in_nddl94_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableDeclarations_in_nddl122  */
static	ANTLR3_BITWORD FOLLOW_variableDeclarations_in_nddl122_bits[]	= { ANTLR3_UINT64_LIT(0x000F210004000368), ANTLR3_UINT64_LIT(0x000000007FC00000) };
static  ANTLR3_BITSET_LIST FOLLOW_variableDeclarations_in_nddl122	= { FOLLOW_variableDeclarations_in_nddl122_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_in_nddl150  */
static	ANTLR3_BITWORD FOLLOW_assignment_in_nddl150_bits[]	= { ANTLR3_UINT64_LIT(0x000F210004000368), ANTLR3_UINT64_LIT(0x000000007FC00000) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_in_nddl150	= { FOLLOW_assignment_in_nddl150_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraintInstantiation_in_nddl178  */
static	ANTLR3_BITWORD FOLLOW_constraintInstantiation_in_nddl178_bits[]	= { ANTLR3_UINT64_LIT(0x000F210004000368), ANTLR3_UINT64_LIT(0x000000007FC00000) };
static  ANTLR3_BITSET_LIST FOLLOW_constraintInstantiation_in_nddl178	= { FOLLOW_constraintInstantiation_in_nddl178_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_classDeclaration_in_nddl188  */
static	ANTLR3_BITWORD FOLLOW_classDeclaration_in_nddl188_bits[]	= { ANTLR3_UINT64_LIT(0x000F210004000368), ANTLR3_UINT64_LIT(0x000000007FC00000) };
static  ANTLR3_BITSET_LIST FOLLOW_classDeclaration_in_nddl188	= { FOLLOW_classDeclaration_in_nddl188_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_allocation_in_nddl216  */
static	ANTLR3_BITWORD FOLLOW_allocation_in_nddl216_bits[]	= { ANTLR3_UINT64_LIT(0x000F210004000368), ANTLR3_UINT64_LIT(0x000000007FC00000) };
static  ANTLR3_BITSET_LIST FOLLOW_allocation_in_nddl216	= { FOLLOW_allocation_in_nddl216_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rule_in_nddl226  */
static	ANTLR3_BITWORD FOLLOW_rule_in_nddl226_bits[]	= { ANTLR3_UINT64_LIT(0x000F210004000368), ANTLR3_UINT64_LIT(0x000000007FC00000) };
static  ANTLR3_BITSET_LIST FOLLOW_rule_in_nddl226	= { FOLLOW_rule_in_nddl226_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_problemStmt_in_nddl236  */
static	ANTLR3_BITWORD FOLLOW_problemStmt_in_nddl236_bits[]	= { ANTLR3_UINT64_LIT(0x000F210004000368), ANTLR3_UINT64_LIT(0x000000007FC00000) };
static  ANTLR3_BITSET_LIST FOLLOW_problemStmt_in_nddl236	= { FOLLOW_problemStmt_in_nddl236_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_relation_in_nddl264  */
static	ANTLR3_BITWORD FOLLOW_relation_in_nddl264_bits[]	= { ANTLR3_UINT64_LIT(0x000F210004000368), ANTLR3_UINT64_LIT(0x000000007FC00000) };
static  ANTLR3_BITSET_LIST FOLLOW_relation_in_nddl264	= { FOLLOW_relation_in_nddl264_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_methodInvocation_in_nddl274  */
static	ANTLR3_BITWORD FOLLOW_methodInvocation_in_nddl274_bits[]	= { ANTLR3_UINT64_LIT(0x000F210004000368), ANTLR3_UINT64_LIT(0x000000007FC00000) };
static  ANTLR3_BITSET_LIST FOLLOW_methodInvocation_in_nddl274	= { FOLLOW_methodInvocation_in_nddl274_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_26_in_typeDefinition316  */
static	ANTLR3_BITWORD FOLLOW_26_in_typeDefinition316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_26_in_typeDefinition316	= { FOLLOW_26_in_typeDefinition316_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_typeDefinition323  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_typeDefinition323_bits[]	= { ANTLR3_UINT64_LIT(0x00000000F0000400) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_typeDefinition323	= { FOLLOW_IDENT_in_typeDefinition323_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_typeDefinition330  */
static	ANTLR3_BITWORD FOLLOW_type_in_typeDefinition330_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_typeDefinition330	= { FOLLOW_type_in_typeDefinition330_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleType_in_type369  */
static	ANTLR3_BITWORD FOLLOW_simpleType_in_type369_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleType_in_type369	= { FOLLOW_simpleType_in_type369_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleType_in_type393  */
static	ANTLR3_BITWORD FOLLOW_simpleType_in_type393_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleType_in_type393	= { FOLLOW_simpleType_in_type393_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_inlineType_in_type397  */
static	ANTLR3_BITWORD FOLLOW_inlineType_in_type397_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_inlineType_in_type397	= { FOLLOW_inlineType_in_type397_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_simpleType459  */
static	ANTLR3_BITWORD FOLLOW_28_in_simpleType459_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_simpleType459	= { FOLLOW_28_in_simpleType459_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_simpleType487  */
static	ANTLR3_BITWORD FOLLOW_29_in_simpleType487_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_simpleType487	= { FOLLOW_29_in_simpleType487_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_simpleType513  */
static	ANTLR3_BITWORD FOLLOW_30_in_simpleType513_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_simpleType513	= { FOLLOW_30_in_simpleType513_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_simpleType540  */
static	ANTLR3_BITWORD FOLLOW_31_in_simpleType540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_simpleType540	= { FOLLOW_31_in_simpleType540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_simpleType567  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_simpleType567_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_simpleType567	= { FOLLOW_IDENT_in_simpleType567_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSet_in_inlineType617  */
static	ANTLR3_BITWORD FOLLOW_valueSet_in_inlineType617_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSet_in_inlineType617	= { FOLLOW_valueSet_in_inlineType617_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericInterval_in_inlineType638  */
static	ANTLR3_BITWORD FOLLOW_numericInterval_in_inlineType638_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numericInterval_in_inlineType638	= { FOLLOW_numericInterval_in_inlineType638_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARIABLE_in_variableDeclarations703  */
static	ANTLR3_BITWORD FOLLOW_VARIABLE_in_variableDeclarations703_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VARIABLE_in_variableDeclarations703	= { FOLLOW_VARIABLE_in_variableDeclarations703_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_variableDeclarations707  */
static	ANTLR3_BITWORD FOLLOW_type_in_variableDeclarations707_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_variableDeclarations707	= { FOLLOW_type_in_variableDeclarations707_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableInitialization_in_variableDeclarations769  */
static	ANTLR3_BITWORD FOLLOW_variableInitialization_in_variableDeclarations769_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000408) };
static  ANTLR3_BITSET_LIST FOLLOW_variableInitialization_in_variableDeclarations769	= { FOLLOW_variableInitialization_in_variableDeclarations769_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_variableInitialization895  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_variableInitialization895_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_variableInitialization895	= { FOLLOW_IDENT_in_variableInitialization895_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_variableInitialization916  */
static	ANTLR3_BITWORD FOLLOW_40_in_variableInitialization916_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_variableInitialization916	= { FOLLOW_40_in_variableInitialization916_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_variableInitialization920  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_variableInitialization920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000900003C20), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_variableInitialization920	= { FOLLOW_IDENT_in_variableInitialization920_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initializer_in_variableInitialization924  */
static	ANTLR3_BITWORD FOLLOW_initializer_in_variableInitialization924_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_initializer_in_variableInitialization924	= { FOLLOW_initializer_in_variableInitialization924_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anyValue_in_initializer995  */
static	ANTLR3_BITWORD FOLLOW_anyValue_in_initializer995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_anyValue_in_initializer995	= { FOLLOW_anyValue_in_initializer995_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_allocation_in_initializer1018  */
static	ANTLR3_BITWORD FOLLOW_allocation_in_initializer1018_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_allocation_in_initializer1018	= { FOLLOW_allocation_in_initializer1018_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_anyValue1080  */
static	ANTLR3_BITWORD FOLLOW_value_in_anyValue1080_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_anyValue1080	= { FOLLOW_value_in_anyValue1080_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSet_in_anyValue1101  */
static	ANTLR3_BITWORD FOLLOW_valueSet_in_anyValue1101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSet_in_anyValue1101	= { FOLLOW_valueSet_in_anyValue1101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericInterval_in_anyValue1122  */
static	ANTLR3_BITWORD FOLLOW_numericInterval_in_anyValue1122_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numericInterval_in_anyValue1122	= { FOLLOW_numericInterval_in_anyValue1122_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_booleanLiteral_in_value1190  */
static	ANTLR3_BITWORD FOLLOW_booleanLiteral_in_value1190_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_booleanLiteral_in_value1190	= { FOLLOW_booleanLiteral_in_value1190_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stringLiteral_in_value1212  */
static	ANTLR3_BITWORD FOLLOW_stringLiteral_in_value1212_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stringLiteral_in_value1212	= { FOLLOW_stringLiteral_in_value1212_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericLiteral_in_value1234  */
static	ANTLR3_BITWORD FOLLOW_numericLiteral_in_value1234_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numericLiteral_in_value1234	= { FOLLOW_numericLiteral_in_value1234_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_value1258  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_value1258_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_value1258	= { FOLLOW_IDENT_in_value1258_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_value1260  */
static	ANTLR3_BITWORD FOLLOW_type_in_value1260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_value1260	= { FOLLOW_type_in_value1260_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_valueSet1349  */
static	ANTLR3_BITWORD FOLLOW_35_in_valueSet1349_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_valueSet1349	= { FOLLOW_35_in_valueSet1349_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_valueSet1378  */
static	ANTLR3_BITWORD FOLLOW_value_in_valueSet1378_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003C08), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_valueSet1378	= { FOLLOW_value_in_valueSet1378_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_84_in_booleanLiteral1505  */
static	ANTLR3_BITWORD FOLLOW_84_in_booleanLiteral1505_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_84_in_booleanLiteral1505	= { FOLLOW_84_in_booleanLiteral1505_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_85_in_booleanLiteral1538  */
static	ANTLR3_BITWORD FOLLOW_85_in_booleanLiteral1538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_85_in_booleanLiteral1538	= { FOLLOW_85_in_booleanLiteral1538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_stringLiteral1576  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_stringLiteral1576_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_stringLiteral1576	= { FOLLOW_STRING_in_stringLiteral1576_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLOAT_in_numericLiteral1630  */
static	ANTLR3_BITWORD FOLLOW_FLOAT_in_numericLiteral1630_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLOAT_in_numericLiteral1630	= { FOLLOW_FLOAT_in_numericLiteral1630_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_in_numericLiteral1653  */
static	ANTLR3_BITWORD FOLLOW_INT_in_numericLiteral1653_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_in_numericLiteral1653	= { FOLLOW_INT_in_numericLiteral1653_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_numericLiteral1677  */
static	ANTLR3_BITWORD FOLLOW_82_in_numericLiteral1677_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_numericLiteral1677	= { FOLLOW_82_in_numericLiteral1677_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_numericLiteral1710  */
static	ANTLR3_BITWORD FOLLOW_83_in_numericLiteral1710_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_numericLiteral1710	= { FOLLOW_83_in_numericLiteral1710_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_numericInterval1759  */
static	ANTLR3_BITWORD FOLLOW_32_in_numericInterval1759_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_numericInterval1759	= { FOLLOW_32_in_numericInterval1759_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericLiteral_in_numericInterval1790  */
static	ANTLR3_BITWORD FOLLOW_numericLiteral_in_numericInterval1790_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003000), ANTLR3_UINT64_LIT(0x00000000000C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_numericLiteral_in_numericInterval1790	= { FOLLOW_numericLiteral_in_numericInterval1790_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericLiteral_in_numericInterval1818  */
static	ANTLR3_BITWORD FOLLOW_numericLiteral_in_numericInterval1818_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_numericLiteral_in_numericInterval1818	= { FOLLOW_numericLiteral_in_numericInterval1818_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTRUCTOR_INVOCATION_in_allocation1895  */
static	ANTLR3_BITWORD FOLLOW_CONSTRUCTOR_INVOCATION_in_allocation1895_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTRUCTOR_INVOCATION_in_allocation1895	= { FOLLOW_CONSTRUCTOR_INVOCATION_in_allocation1895_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_allocation1923  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_allocation1923_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_allocation1923	= { FOLLOW_IDENT_in_allocation1923_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableArgumentList_in_allocation1950  */
static	ANTLR3_BITWORD FOLLOW_variableArgumentList_in_allocation1950_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_variableArgumentList_in_allocation1950	= { FOLLOW_variableArgumentList_in_allocation1950_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_variableArgumentList2021  */
static	ANTLR3_BITWORD FOLLOW_38_in_variableArgumentList2021_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_variableArgumentList2021	= { FOLLOW_38_in_variableArgumentList2021_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initializer_in_variableArgumentList2050  */
static	ANTLR3_BITWORD FOLLOW_initializer_in_variableArgumentList2050_bits[]	= { ANTLR3_UINT64_LIT(0x0000000900003C28), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_initializer_in_variableArgumentList2050	= { FOLLOW_initializer_in_variableArgumentList2050_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_identifier0  */
static	ANTLR3_BITWORD FOLLOW_set_in_identifier0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_identifier0	= { FOLLOW_set_in_identifier0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTRAINT_INSTANTIATION_in_constraintInstantiation2166  */
static	ANTLR3_BITWORD FOLLOW_CONSTRAINT_INSTANTIATION_in_constraintInstantiation2166_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTRAINT_INSTANTIATION_in_constraintInstantiation2166	= { FOLLOW_CONSTRAINT_INSTANTIATION_in_constraintInstantiation2166_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_constraintInstantiation2194  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_constraintInstantiation2194_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_constraintInstantiation2194	= { FOLLOW_IDENT_in_constraintInstantiation2194_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableArgumentList_in_constraintInstantiation2220  */
static	ANTLR3_BITWORD FOLLOW_variableArgumentList_in_constraintInstantiation2220_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_variableArgumentList_in_constraintInstantiation2220	= { FOLLOW_variableArgumentList_in_constraintInstantiation2220_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_45_in_classDeclaration2302  */
static	ANTLR3_BITWORD FOLLOW_45_in_classDeclaration2302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_45_in_classDeclaration2302	= { FOLLOW_45_in_classDeclaration2302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_classDeclaration2325  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_classDeclaration2325_bits[]	= { ANTLR3_UINT64_LIT(0x0000400808000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_classDeclaration2325	= { FOLLOW_IDENT_in_classDeclaration2325_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_classDeclaration2356  */
static	ANTLR3_BITWORD FOLLOW_46_in_classDeclaration2356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_46_in_classDeclaration2356	= { FOLLOW_46_in_classDeclaration2356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_classDeclaration2360  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_classDeclaration2360_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_classDeclaration2360	= { FOLLOW_IDENT_in_classDeclaration2360_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_classBlock_in_classDeclaration2444  */
static	ANTLR3_BITWORD FOLLOW_classBlock_in_classDeclaration2444_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_classBlock_in_classDeclaration2444	= { FOLLOW_classBlock_in_classDeclaration2444_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_classDeclaration2461  */
static	ANTLR3_BITWORD FOLLOW_27_in_classDeclaration2461_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_classDeclaration2461	= { FOLLOW_27_in_classDeclaration2461_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_classBlock2495  */
static	ANTLR3_BITWORD FOLLOW_35_in_classBlock2495_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_classBlock2495	= { FOLLOW_35_in_classBlock2495_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_componentTypeEntry_in_classBlock2500  */
static	ANTLR3_BITWORD FOLLOW_componentTypeEntry_in_classBlock2500_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000218) };
static  ANTLR3_BITSET_LIST FOLLOW_componentTypeEntry_in_classBlock2500	= { FOLLOW_componentTypeEntry_in_classBlock2500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_classVariable_in_componentTypeEntry2518  */
static	ANTLR3_BITWORD FOLLOW_classVariable_in_componentTypeEntry2518_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_classVariable_in_componentTypeEntry2518	= { FOLLOW_classVariable_in_componentTypeEntry2518_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructor_in_componentTypeEntry2524  */
static	ANTLR3_BITWORD FOLLOW_constructor_in_componentTypeEntry2524_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructor_in_componentTypeEntry2524	= { FOLLOW_constructor_in_componentTypeEntry2524_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicate_in_componentTypeEntry2530  */
static	ANTLR3_BITWORD FOLLOW_predicate_in_componentTypeEntry2530_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_predicate_in_componentTypeEntry2530	= { FOLLOW_predicate_in_componentTypeEntry2530_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARIABLE_in_classVariable2557  */
static	ANTLR3_BITWORD FOLLOW_VARIABLE_in_classVariable2557_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VARIABLE_in_classVariable2557	= { FOLLOW_VARIABLE_in_classVariable2557_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_classVariable2561  */
static	ANTLR3_BITWORD FOLLOW_type_in_classVariable2561_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_classVariable2561	= { FOLLOW_type_in_classVariable2561_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_classVariable2565  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_classVariable2565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_classVariable2565	= { FOLLOW_IDENT_in_classVariable2565_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTRUCTOR_in_constructor2609  */
static	ANTLR3_BITWORD FOLLOW_CONSTRUCTOR_in_constructor2609_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTRUCTOR_in_constructor2609	= { FOLLOW_CONSTRUCTOR_in_constructor2609_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_constructor2616  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_constructor2616_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_constructor2616	= { FOLLOW_IDENT_in_constructor2616_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_constructor2622  */
static	ANTLR3_BITWORD FOLLOW_38_in_constructor2622_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_constructor2622	= { FOLLOW_38_in_constructor2622_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructorArgument_in_constructor2624  */
static	ANTLR3_BITWORD FOLLOW_constructorArgument_in_constructor2624_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000208) };
static  ANTLR3_BITSET_LIST FOLLOW_constructorArgument_in_constructor2624	= { FOLLOW_constructorArgument_in_constructor2624_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_constructor2633  */
static	ANTLR3_BITWORD FOLLOW_35_in_constructor2633_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_constructor2633	= { FOLLOW_35_in_constructor2633_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructorSuper_in_constructor2637  */
static	ANTLR3_BITWORD FOLLOW_constructorSuper_in_constructor2637_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_constructorSuper_in_constructor2637	= { FOLLOW_constructorSuper_in_constructor2637_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_in_constructor2653  */
static	ANTLR3_BITWORD FOLLOW_assignment_in_constructor2653_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_in_constructor2653	= { FOLLOW_assignment_in_constructor2653_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARIABLE_in_constructorArgument2679  */
static	ANTLR3_BITWORD FOLLOW_VARIABLE_in_constructorArgument2679_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VARIABLE_in_constructorArgument2679	= { FOLLOW_VARIABLE_in_constructorArgument2679_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_constructorArgument2686  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_constructorArgument2686_bits[]	= { ANTLR3_UINT64_LIT(0x00000000F0000400) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_constructorArgument2686	= { FOLLOW_IDENT_in_constructorArgument2686_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_constructorArgument2693  */
static	ANTLR3_BITWORD FOLLOW_type_in_constructorArgument2693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_constructorArgument2693	= { FOLLOW_type_in_constructorArgument2693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_52_in_constructorSuper2723  */
static	ANTLR3_BITWORD FOLLOW_52_in_constructorSuper2723_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_52_in_constructorSuper2723	= { FOLLOW_52_in_constructorSuper2723_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableArgumentList_in_constructorSuper2728  */
static	ANTLR3_BITWORD FOLLOW_variableArgumentList_in_constructorSuper2728_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_variableArgumentList_in_constructorSuper2728	= { FOLLOW_variableArgumentList_in_constructorSuper2728_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_assignment2755  */
static	ANTLR3_BITWORD FOLLOW_40_in_assignment2755_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_assignment2755	= { FOLLOW_40_in_assignment2755_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_in_assignment2762  */
static	ANTLR3_BITWORD FOLLOW_qualified_in_assignment2762_bits[]	= { ANTLR3_UINT64_LIT(0x0000000900003C20), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_in_assignment2762	= { FOLLOW_qualified_in_assignment2762_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initializer_in_assignment2769  */
static	ANTLR3_BITWORD FOLLOW_initializer_in_assignment2769_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_initializer_in_assignment2769	= { FOLLOW_initializer_in_assignment2769_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_47_in_predicate2795  */
static	ANTLR3_BITWORD FOLLOW_47_in_predicate2795_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_47_in_predicate2795	= { FOLLOW_47_in_predicate2795_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_predicate2802  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_predicate2802_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_predicate2802	= { FOLLOW_IDENT_in_predicate2802_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicateStatements_in_predicate2813  */
static	ANTLR3_BITWORD FOLLOW_predicateStatements_in_predicate2813_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_predicateStatements_in_predicate2813	= { FOLLOW_predicateStatements_in_predicate2813_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_predicateStatements2836  */
static	ANTLR3_BITWORD FOLLOW_35_in_predicateStatements2836_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_predicateStatements2836	= { FOLLOW_35_in_predicateStatements2836_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicateParameter_in_predicateStatements2862  */
static	ANTLR3_BITWORD FOLLOW_predicateParameter_in_predicateStatements2862_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000248) };
static  ANTLR3_BITSET_LIST FOLLOW_predicateParameter_in_predicateStatements2862	= { FOLLOW_predicateParameter_in_predicateStatements2862_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicateParameterAssignment_in_predicateStatements2894  */
static	ANTLR3_BITWORD FOLLOW_predicateParameterAssignment_in_predicateStatements2894_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000248) };
static  ANTLR3_BITSET_LIST FOLLOW_predicateParameterAssignment_in_predicateStatements2894	= { FOLLOW_predicateParameterAssignment_in_predicateStatements2894_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_standardConstraint_in_predicateStatements2904  */
static	ANTLR3_BITWORD FOLLOW_standardConstraint_in_predicateStatements2904_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000248) };
static  ANTLR3_BITSET_LIST FOLLOW_standardConstraint_in_predicateStatements2904	= { FOLLOW_standardConstraint_in_predicateStatements2904_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableDeclarations_in_predicateParameter2965  */
static	ANTLR3_BITWORD FOLLOW_variableDeclarations_in_predicateParameter2965_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variableDeclarations_in_predicateParameter2965	= { FOLLOW_variableDeclarations_in_predicateParameter2965_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_in_predicateParameterAssignment3022  */
static	ANTLR3_BITWORD FOLLOW_assignment_in_predicateParameterAssignment3022_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_in_predicateParameterAssignment3022	= { FOLLOW_assignment_in_predicateParameterAssignment3022_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraintInstantiation_in_standardConstraint3081  */
static	ANTLR3_BITWORD FOLLOW_constraintInstantiation_in_standardConstraint3081_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constraintInstantiation_in_standardConstraint3081	= { FOLLOW_constraintInstantiation_in_standardConstraint3081_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_48_in_rule3122  */
static	ANTLR3_BITWORD FOLLOW_48_in_rule3122_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_48_in_rule3122	= { FOLLOW_48_in_rule3122_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_rule3129  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_rule3129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_rule3129	= { FOLLOW_IDENT_in_rule3129_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_rule3136  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_rule3136_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_rule3136	= { FOLLOW_IDENT_in_rule3136_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ruleBlock_in_rule3141  */
static	ANTLR3_BITWORD FOLLOW_ruleBlock_in_rule3141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ruleBlock_in_rule3141	= { FOLLOW_ruleBlock_in_rule3141_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_ruleBlock3163  */
static	ANTLR3_BITWORD FOLLOW_35_in_ruleBlock3163_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_ruleBlock3163	= { FOLLOW_35_in_ruleBlock3163_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ruleStatement_in_ruleBlock3171  */
static	ANTLR3_BITWORD FOLLOW_ruleStatement_in_ruleBlock3171_bits[]	= { ANTLR3_UINT64_LIT(0x00A0010000000348) };
static  ANTLR3_BITSET_LIST FOLLOW_ruleStatement_in_ruleBlock3171	= { FOLLOW_ruleStatement_in_ruleBlock3171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraintInstantiation_in_ruleStatement3198  */
static	ANTLR3_BITWORD FOLLOW_constraintInstantiation_in_ruleStatement3198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constraintInstantiation_in_ruleStatement3198	= { FOLLOW_constraintInstantiation_in_ruleStatement3198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_in_ruleStatement3207  */
static	ANTLR3_BITWORD FOLLOW_assignment_in_ruleStatement3207_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_in_ruleStatement3207	= { FOLLOW_assignment_in_ruleStatement3207_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableDeclarations_in_ruleStatement3216  */
static	ANTLR3_BITWORD FOLLOW_variableDeclarations_in_ruleStatement3216_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variableDeclarations_in_ruleStatement3216	= { FOLLOW_variableDeclarations_in_ruleStatement3216_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifStatement_in_ruleStatement3225  */
static	ANTLR3_BITWORD FOLLOW_ifStatement_in_ruleStatement3225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ifStatement_in_ruleStatement3225	= { FOLLOW_ifStatement_in_ruleStatement3225_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_loopStatement_in_ruleStatement3234  */
static	ANTLR3_BITWORD FOLLOW_loopStatement_in_ruleStatement3234_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_loopStatement_in_ruleStatement3234	= { FOLLOW_loopStatement_in_ruleStatement3234_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_relation_in_ruleStatement3247  */
static	ANTLR3_BITWORD FOLLOW_relation_in_ruleStatement3247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_relation_in_ruleStatement3247	= { FOLLOW_relation_in_ruleStatement3247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_53_in_ifStatement3279  */
static	ANTLR3_BITWORD FOLLOW_53_in_ifStatement3279_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_53_in_ifStatement3279	= { FOLLOW_53_in_ifStatement3279_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guardExpression_in_ifStatement3286  */
static	ANTLR3_BITWORD FOLLOW_guardExpression_in_ifStatement3286_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_guardExpression_in_ifStatement3286	= { FOLLOW_guardExpression_in_ifStatement3286_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ruleBlock_in_ifStatement3291  */
static	ANTLR3_BITWORD FOLLOW_ruleBlock_in_ifStatement3291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ruleBlock_in_ifStatement3291	= { FOLLOW_ruleBlock_in_ifStatement3291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ruleBlock_in_ifStatement3297  */
static	ANTLR3_BITWORD FOLLOW_ruleBlock_in_ifStatement3297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ruleBlock_in_ifStatement3297	= { FOLLOW_ruleBlock_in_ifStatement3297_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guardRelop_in_guardExpression3340  */
static	ANTLR3_BITWORD FOLLOW_guardRelop_in_guardExpression3340_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_guardRelop_in_guardExpression3340	= { FOLLOW_guardRelop_in_guardExpression3340_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anyValue_in_guardExpression3346  */
static	ANTLR3_BITWORD FOLLOW_anyValue_in_guardExpression3346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000900003C00), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_anyValue_in_guardExpression3346	= { FOLLOW_anyValue_in_guardExpression3346_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anyValue_in_guardExpression3350  */
static	ANTLR3_BITWORD FOLLOW_anyValue_in_guardExpression3350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_anyValue_in_guardExpression3350	= { FOLLOW_anyValue_in_guardExpression3350_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anyValue_in_guardExpression3368  */
static	ANTLR3_BITWORD FOLLOW_anyValue_in_guardExpression3368_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_anyValue_in_guardExpression3368	= { FOLLOW_anyValue_in_guardExpression3368_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_guardRelop0  */
static	ANTLR3_BITWORD FOLLOW_set_in_guardRelop0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_guardRelop0	= { FOLLOW_set_in_guardRelop0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_55_in_loopStatement3438  */
static	ANTLR3_BITWORD FOLLOW_55_in_loopStatement3438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_55_in_loopStatement3438	= { FOLLOW_55_in_loopStatement3438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_loopStatement3445  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_loopStatement3445_bits[]	= { ANTLR3_UINT64_LIT(0x00000C0000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_loopStatement3445	= { FOLLOW_IDENT_in_loopStatement3445_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_in_loopStatement3452  */
static	ANTLR3_BITWORD FOLLOW_qualified_in_loopStatement3452_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_in_loopStatement3452	= { FOLLOW_qualified_in_loopStatement3452_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ruleBlock_in_loopStatement3458  */
static	ANTLR3_BITWORD FOLLOW_ruleBlock_in_loopStatement3458_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ruleBlock_in_loopStatement3458	= { FOLLOW_ruleBlock_in_loopStatement3458_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_problemStmtType_in_problemStmt3505  */
static	ANTLR3_BITWORD FOLLOW_problemStmtType_in_problemStmt3505_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_problemStmtType_in_problemStmt3505	= { FOLLOW_problemStmtType_in_problemStmt3505_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicateInstanceList_in_problemStmt3507  */
static	ANTLR3_BITWORD FOLLOW_predicateInstanceList_in_problemStmt3507_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_predicateInstanceList_in_problemStmt3507	= { FOLLOW_predicateInstanceList_in_problemStmt3507_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_problemStmtType0  */
static	ANTLR3_BITWORD FOLLOW_set_in_problemStmtType0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_problemStmtType0	= { FOLLOW_set_in_problemStmtType0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TOKEN_RELATION_in_relation3642  */
static	ANTLR3_BITWORD FOLLOW_TOKEN_RELATION_in_relation3642_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TOKEN_RELATION_in_relation3642	= { FOLLOW_TOKEN_RELATION_in_relation3642_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_relation3650  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_relation3650_bits[]	= { ANTLR3_UINT64_LIT(0xFC00000000000000), ANTLR3_UINT64_LIT(0x000000000001FFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_relation3650	= { FOLLOW_IDENT_in_relation3650_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_temporalRelation_in_relation3661  */
static	ANTLR3_BITWORD FOLLOW_temporalRelation_in_relation3661_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_temporalRelation_in_relation3661	= { FOLLOW_temporalRelation_in_relation3661_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicateInstanceList_in_relation3669  */
static	ANTLR3_BITWORD FOLLOW_predicateInstanceList_in_relation3669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_predicateInstanceList_in_relation3669	= { FOLLOW_predicateInstanceList_in_relation3669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_predicateInstanceList3691  */
static	ANTLR3_BITWORD FOLLOW_38_in_predicateInstanceList3691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_predicateInstanceList3691	= { FOLLOW_38_in_predicateInstanceList3691_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicateInstance_in_predicateInstanceList3699  */
static	ANTLR3_BITWORD FOLLOW_predicateInstance_in_predicateInstanceList3699_bits[]	= { ANTLR3_UINT64_LIT(0x00000C0000000408) };
static  ANTLR3_BITSET_LIST FOLLOW_predicateInstance_in_predicateInstanceList3699	= { FOLLOW_predicateInstance_in_predicateInstanceList3699_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_predicateInstanceList3715  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_predicateInstanceList3715_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_predicateInstanceList3715	= { FOLLOW_IDENT_in_predicateInstanceList3715_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualifiedToken_in_predicateInstance3752  */
static	ANTLR3_BITWORD FOLLOW_qualifiedToken_in_predicateInstance3752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_qualifiedToken_in_predicateInstance3752	= { FOLLOW_qualifiedToken_in_predicateInstance3752_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_predicateInstance3757  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_predicateInstance3757_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_predicateInstance3757	= { FOLLOW_IDENT_in_predicateInstance3757_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_qualified3811  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_qualified3811_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_qualified3811	= { FOLLOW_identifier_in_qualified3811_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_qualified3852  */
static	ANTLR3_BITWORD FOLLOW_43_in_qualified3852_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_qualified3852	= { FOLLOW_43_in_qualified3852_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_qualified3856  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_qualified3856_bits[]	= { ANTLR3_UINT64_LIT(0x00000C0000000408) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_qualified3856	= { FOLLOW_identifier_in_qualified3856_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_in_qualified3860  */
static	ANTLR3_BITWORD FOLLOW_qualified_in_qualified3860_bits[]	= { ANTLR3_UINT64_LIT(0x00000C0000000408) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_in_qualified3860	= { FOLLOW_qualified_in_qualified3860_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_in_qualifiedToken3926  */
static	ANTLR3_BITWORD FOLLOW_qualified_in_qualifiedToken3926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_in_qualifiedToken3926	= { FOLLOW_qualified_in_qualifiedToken3926_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_temporalRelation0  */
static	ANTLR3_BITWORD FOLLOW_set_in_temporalRelation0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_temporalRelation0	= { FOLLOW_set_in_temporalRelation0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableMethod_in_methodInvocation4408  */
static	ANTLR3_BITWORD FOLLOW_variableMethod_in_methodInvocation4408_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variableMethod_in_methodInvocation4408	= { FOLLOW_variableMethod_in_methodInvocation4408_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tokenMethod_in_methodInvocation4428  */
static	ANTLR3_BITWORD FOLLOW_tokenMethod_in_methodInvocation4428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tokenMethod_in_methodInvocation4428	= { FOLLOW_tokenMethod_in_methodInvocation4428_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableOp_in_variableMethod4484  */
static	ANTLR3_BITWORD FOLLOW_variableOp_in_variableMethod4484_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_variableOp_in_variableMethod4484	= { FOLLOW_variableOp_in_variableMethod4484_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_in_variableMethod4488  */
static	ANTLR3_BITWORD FOLLOW_qualified_in_variableMethod4488_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_in_variableMethod4488	= { FOLLOW_qualified_in_variableMethod4488_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableArgumentList_in_variableMethod4490  */
static	ANTLR3_BITWORD FOLLOW_variableArgumentList_in_variableMethod4490_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_variableArgumentList_in_variableMethod4490	= { FOLLOW_variableArgumentList_in_variableMethod4490_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_variableOp0  */
static	ANTLR3_BITWORD FOLLOW_set_in_variableOp0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_variableOp0	= { FOLLOW_set_in_variableOp0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tokenOp_in_tokenMethod4644  */
static	ANTLR3_BITWORD FOLLOW_tokenOp_in_tokenMethod4644_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_tokenOp_in_tokenMethod4644	= { FOLLOW_tokenOp_in_tokenMethod4644_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_tokenMethod4648  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_tokenMethod4648_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_tokenMethod4648	= { FOLLOW_IDENT_in_tokenMethod4648_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableArgumentList_in_tokenMethod4650  */
static	ANTLR3_BITWORD FOLLOW_variableArgumentList_in_tokenMethod4650_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_variableArgumentList_in_tokenMethod4650	= { FOLLOW_variableArgumentList_in_tokenMethod4650_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_tokenOp0  */
static	ANTLR3_BITWORD FOLLOW_set_in_tokenOp0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_tokenOp0	= { FOLLOW_set_in_tokenOp0_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start nddl
 * ../base/antlr/NDDL3Tree.g:67:1: nddl : ^( NDDL ( (child= typeDefinition | child= variableDeclarations | child= assignment | child= constraintInstantiation | child= classDeclaration | child= allocation | child= rule | child= problemStmt | child= relation | child= methodInvocation ) )* ) ;
 */
static void
nddl(pNDDL3Tree ctx)
{   
    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:67:6: ( ^( NDDL ( (child= typeDefinition | child= variableDeclarations | child= assignment | child= constraintInstantiation | child= classDeclaration | child= allocation | child= rule | child= problemStmt | child= relation | child= methodInvocation ) )* ) )
        // ../base/antlr/NDDL3Tree.g:68:2: ^( NDDL ( (child= typeDefinition | child= variableDeclarations | child= assignment | child= constraintInstantiation | child= classDeclaration | child= allocation | child= rule | child= problemStmt | child= relation | child= methodInvocation ) )* )
        {
             MATCHT(NDDL, &FOLLOW_NDDL_in_nddl78); 
            if  (HASEXCEPTION())
            {
                goto rulenddlEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulenddlEx;
                }


                // ../base/antlr/NDDL3Tree.g:69:3: ( (child= typeDefinition | child= variableDeclarations | child= assignment | child= constraintInstantiation | child= classDeclaration | child= allocation | child= rule | child= problemStmt | child= relation | child= methodInvocation ) )*

                for (;;)
                {
                    int alt2=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA2_0 = LA(1);
                        if ( (((LA2_0 >= CONSTRUCTOR_INVOCATION) && (LA2_0 <= CONSTRAINT_INSTANTIATION)) || ((LA2_0 >= TOKEN_RELATION) && (LA2_0 <= VARIABLE)) || LA2_0 == 26 || LA2_0 == 40 || LA2_0 == 45 || ((LA2_0 >= 48) && (LA2_0 <= 51)) || ((LA2_0 >= 86) && (LA2_0 <= 94))) ) 
                        {
                            alt2=1;
                        }

                    }
                    switch (alt2) 
                    {
                	case 1:
                	    // ../base/antlr/NDDL3Tree.g:69:5: (child= typeDefinition | child= variableDeclarations | child= assignment | child= constraintInstantiation | child= classDeclaration | child= allocation | child= rule | child= problemStmt | child= relation | child= methodInvocation )
                	    {
                	        {

                	            		     // debugMsg("NddlInterpreter:nddl","Line:" << LEXER->getLine(LEXER)); 
                	            		  
                	        }

                	        // ../base/antlr/NDDL3Tree.g:72:5: (child= typeDefinition | child= variableDeclarations | child= assignment | child= constraintInstantiation | child= classDeclaration | child= allocation | child= rule | child= problemStmt | child= relation | child= methodInvocation )
                	        {
                	            int alt1=10;
                	            switch ( LA(1) ) 
                	            {
                	            case 26:
                	            	{
                	            		alt1=1;
                	            	}
                	                break;
                	            case VARIABLE:
                	            	{
                	            		alt1=2;
                	            	}
                	                break;
                	            case 40:
                	            	{
                	            		alt1=3;
                	            	}
                	                break;
                	            case CONSTRAINT_INSTANTIATION:
                	            	{
                	            		alt1=4;
                	            	}
                	                break;
                	            case 45:
                	            	{
                	            		alt1=5;
                	            	}
                	                break;
                	            case CONSTRUCTOR_INVOCATION:
                	            	{
                	            		alt1=6;
                	            	}
                	                break;
                	            case 48:
                	            	{
                	            		alt1=7;
                	            	}
                	                break;
                	            case 49:
                	            case 50:
                	            case 51:
                	            	{
                	            		alt1=8;
                	            	}
                	                break;
                	            case TOKEN_RELATION:
                	            	{
                	            		alt1=9;
                	            	}
                	                break;
                	            case 86:
                	            case 87:
                	            case 88:
                	            case 89:
                	            case 90:
                	            case 91:
                	            case 92:
                	            case 93:
                	            case 94:
                	            	{
                	            		alt1=10;
                	            	}
                	                break;

                	            default:
                	                CONSTRUCTEX();
                	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                	                EXCEPTION->message      = (void *)"";
                	                EXCEPTION->decisionNum  = 1;
                	                EXCEPTION->state        = 0;


                	                goto rulenddlEx;
                	            }

                	            switch (alt1) 
                	            {
                	        	case 1:
                	        	    // ../base/antlr/NDDL3Tree.g:72:7: child= typeDefinition
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_typeDefinition_in_nddl94);
                	        	        child=typeDefinition(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 2:
                	        	    // ../base/antlr/NDDL3Tree.g:73:25: child= variableDeclarations
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_variableDeclarations_in_nddl122);
                	        	        child=variableDeclarations(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 3:
                	        	    // ../base/antlr/NDDL3Tree.g:74:25: child= assignment
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_assignment_in_nddl150);
                	        	        child=assignment(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 4:
                	        	    // ../base/antlr/NDDL3Tree.g:75:25: child= constraintInstantiation
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_constraintInstantiation_in_nddl178);
                	        	        child=constraintInstantiation(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 5:
                	        	    // ../base/antlr/NDDL3Tree.g:76:7: child= classDeclaration
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_classDeclaration_in_nddl188);
                	        	        child=classDeclaration(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 6:
                	        	    // ../base/antlr/NDDL3Tree.g:77:25: child= allocation
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_allocation_in_nddl216);
                	        	        child=allocation(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 7:
                	        	    // ../base/antlr/NDDL3Tree.g:78:7: child= rule
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_rule_in_nddl226);
                	        	        child=rule(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 8:
                	        	    // ../base/antlr/NDDL3Tree.g:79:7: child= problemStmt
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_problemStmt_in_nddl236);
                	        	        child=problemStmt(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 9:
                	        	    // ../base/antlr/NDDL3Tree.g:80:25: child= relation
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_relation_in_nddl264);
                	        	        child=relation(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 10:
                	        	    // ../base/antlr/NDDL3Tree.g:81:7: child= methodInvocation
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_methodInvocation_in_nddl274);
                	        	        child=methodInvocation(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulenddlEx;
                	        	        }


                	        	    }
                	        	    break;

                	            }
                	        }
                	        {

                	            		      if (child != NULL) { 
                	            		          debugMsg("NddlInterpreter:nddl","Evaluating:" << child->toString());
                	            		          evalExpr(CTX,child);
                	            		          delete child;
                	            		          child = NULL; 
                	            		      }
                	            		  
                	        }

                	    }
                	    break;

                	default:
                	    goto loop2;	/* break out of the loop */
                	    break;
                    }
                }
                loop2: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulenddlEx;
                }

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenddlEx; /* Prevent compiler warnings */
    rulenddlEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end nddl */

/** 
 * $ANTLR start typeDefinition
 * ../base/antlr/NDDL3Tree.g:96:1: typeDefinition returns [Expr* result] : ^( 'typedef' name= IDENT dataType= type ) ;
 */
static Expr*
typeDefinition(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    name;
    AbstractDomain* dataType;
    #undef	RETURN_TYPE_dataType
    #define	RETURN_TYPE_dataType AbstractDomain*

    /* Initialize rule variables
     */


    name       = NULL;
    dataType = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:97:2: ( ^( 'typedef' name= IDENT dataType= type ) )
        // ../base/antlr/NDDL3Tree.g:97:4: ^( 'typedef' name= IDENT dataType= type )
        {
             MATCHT(26, &FOLLOW_26_in_typeDefinition316); 
            if  (HASEXCEPTION())
            {
                goto ruletypeDefinitionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletypeDefinitionEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_typeDefinition323); 
            if  (HASEXCEPTION())
            {
                goto ruletypeDefinitionEx;
            }

            FOLLOWPUSH(FOLLOW_type_in_typeDefinition330);
            dataType=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletypeDefinitionEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletypeDefinitionEx;
            }

            {

                		    if (dataType != NULL) {
                		        if (!dataType->getIsRestricted()) // then this is just an alias for another type
                		            dataType = dataType->copy();
                		        
                		        const char* newName = c_str((name != NULL ? name->getText(name) : NULL)->chars);
                		        dataType->setTypeName(newName);    		            
                		        result = new ExprTypedef(newName,dataType);
                		     }
                		     else {
                                         result = NULL;              
                                         reportSemanticError(CTX,
                                            "Incorrect typedef. Unknown data type for : " + std::string(c_str((name != NULL ? name->getText(name) : NULL)->chars)));
                		     }   
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletypeDefinitionEx; /* Prevent compiler warnings */
    ruletypeDefinitionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end typeDefinition */

/** 
 * $ANTLR start type
 * ../base/antlr/NDDL3Tree.g:118:1: type returns [AbstractDomain* result] : (retval= simpleType | ^(baseType= simpleType retval= inlineType[baseType] ) ) ;
 */
static AbstractDomain*
type(pNDDL3Tree ctx)
{   
    AbstractDomain* result = NULL;

    AbstractDomain* retval;
    #undef	RETURN_TYPE_retval
    #define	RETURN_TYPE_retval AbstractDomain*

    AbstractDomain* baseType;
    #undef	RETURN_TYPE_baseType
    #define	RETURN_TYPE_baseType AbstractDomain*

    /* Initialize rule variables
     */


    retval = NULL;
    baseType = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:119:9: ( (retval= simpleType | ^(baseType= simpleType retval= inlineType[baseType] ) ) )
        // ../base/antlr/NDDL3Tree.g:119:11: (retval= simpleType | ^(baseType= simpleType retval= inlineType[baseType] ) )
        {

            // ../base/antlr/NDDL3Tree.g:119:11: (retval= simpleType | ^(baseType= simpleType retval= inlineType[baseType] ) )
            {
                int alt3=2;
                switch ( LA(1) ) 
                {
                case 28:
                	{

                		{
                		    int LA3_1 = LA(2);
                		    if ( (LA3_1 == DOWN) ) 
                		    {
                		        alt3=2;
                		    }
                		    else if ( (LA3_1 == UP || LA3_1 == IDENT || LA3_1 == 40) ) 
                		    {
                		        alt3=1;
                		    }
                		    else 
                		    {
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 3;
                		        EXCEPTION->state        = 1;


                		        goto ruletypeEx;
                		    }
                		}
                	}
                    break;
                case 29:
                	{

                		{
                		    int LA3_2 = LA(2);
                		    if ( (LA3_2 == DOWN) ) 
                		    {
                		        alt3=2;
                		    }
                		    else if ( (LA3_2 == UP || LA3_2 == IDENT || LA3_2 == 40) ) 
                		    {
                		        alt3=1;
                		    }
                		    else 
                		    {
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 3;
                		        EXCEPTION->state        = 2;


                		        goto ruletypeEx;
                		    }
                		}
                	}
                    break;
                case 30:
                	{

                		{
                		    int LA3_3 = LA(2);
                		    if ( (LA3_3 == DOWN) ) 
                		    {
                		        alt3=2;
                		    }
                		    else if ( (LA3_3 == UP || LA3_3 == IDENT || LA3_3 == 40) ) 
                		    {
                		        alt3=1;
                		    }
                		    else 
                		    {
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 3;
                		        EXCEPTION->state        = 3;


                		        goto ruletypeEx;
                		    }
                		}
                	}
                    break;
                case 31:
                	{

                		{
                		    int LA3_4 = LA(2);
                		    if ( (LA3_4 == UP || LA3_4 == IDENT || LA3_4 == 40) ) 
                		    {
                		        alt3=1;
                		    }
                		    else if ( (LA3_4 == DOWN) ) 
                		    {
                		        alt3=2;
                		    }
                		    else 
                		    {
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 3;
                		        EXCEPTION->state        = 4;


                		        goto ruletypeEx;
                		    }
                		}
                	}
                    break;
                case IDENT:
                	{

                		{
                		    int LA3_5 = LA(2);
                		    if ( (LA3_5 == DOWN) ) 
                		    {
                		        alt3=2;
                		    }
                		    else if ( (LA3_5 == UP || LA3_5 == IDENT || LA3_5 == 40) ) 
                		    {
                		        alt3=1;
                		    }
                		    else 
                		    {
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 3;
                		        EXCEPTION->state        = 5;


                		        goto ruletypeEx;
                		    }
                		}
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 3;
                    EXCEPTION->state        = 0;


                    goto ruletypeEx;
                }

                switch (alt3) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:119:18: retval= simpleType
            	    {
            	        FOLLOWPUSH(FOLLOW_simpleType_in_type369);
            	        retval=simpleType(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // ../base/antlr/NDDL3Tree.g:120:19: ^(baseType= simpleType retval= inlineType[baseType] )
            	    {
            	        FOLLOWPUSH(FOLLOW_simpleType_in_type393);
            	        baseType=simpleType(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_inlineType_in_type397);
            	        retval=inlineType(ctx, baseType);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                              result = retval;
                          
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletypeEx; /* Prevent compiler warnings */
    ruletypeEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end type */

/** 
 * $ANTLR start simpleType
 * ../base/antlr/NDDL3Tree.g:127:1: simpleType returns [AbstractDomain* result] : ( 'int' | 'float' | 'bool' | 'string' | object= IDENT );
 */
static AbstractDomain*
simpleType(pNDDL3Tree ctx)
{   
    AbstractDomain* result = NULL;

    pANTLR3_BASE_TREE    object;

    /* Initialize rule variables
     */


    object       = NULL;

    {
        {
            //  ../base/antlr/NDDL3Tree.g:128:9: ( 'int' | 'float' | 'bool' | 'string' | object= IDENT )
            
            ANTLR3_UINT32 alt4;

            alt4=5;

            switch ( LA(1) ) 
            {
            case 28:
            	{
            		alt4=1;
            	}
                break;
            case 29:
            	{
            		alt4=2;
            	}
                break;
            case 30:
            	{
            		alt4=3;
            	}
                break;
            case 31:
            	{
            		alt4=4;
            	}
                break;
            case IDENT:
            	{
            		alt4=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 4;
                EXCEPTION->state        = 0;


                goto rulesimpleTypeEx;
            }

            switch (alt4) 
            {
        	case 1:
        	    // ../base/antlr/NDDL3Tree.g:128:17: 'int'
        	    {
        	         MATCHT(28, &FOLLOW_28_in_simpleType459); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTypeEx;
        	        }

        	        {
        	             result = CTX->SymbolTable->getVarType("int"); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // ../base/antlr/NDDL3Tree.g:129:17: 'float'
        	    {
        	         MATCHT(29, &FOLLOW_29_in_simpleType487); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTypeEx;
        	        }

        	        {
        	             result = CTX->SymbolTable->getVarType("float"); 
        	        }

        	    }
        	    break;
        	case 3:
        	    // ../base/antlr/NDDL3Tree.g:130:17: 'bool'
        	    {
        	         MATCHT(30, &FOLLOW_30_in_simpleType513); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTypeEx;
        	        }

        	        {
        	             result = CTX->SymbolTable->getVarType("bool"); 
        	        }

        	    }
        	    break;
        	case 4:
        	    // ../base/antlr/NDDL3Tree.g:131:17: 'string'
        	    {
        	         MATCHT(31, &FOLLOW_31_in_simpleType540); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTypeEx;
        	        }

        	        {
        	             result = CTX->SymbolTable->getVarType("string"); 
        	        }

        	    }
        	    break;
        	case 5:
        	    // ../base/antlr/NDDL3Tree.g:132:17: object= IDENT
        	    {
        	        object = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_simpleType567); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTypeEx;
        	        }

        	        {
        	             result = CTX->SymbolTable->getVarType(c_str((object != NULL ? object->getText(object) : NULL)->chars)); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulesimpleTypeEx; /* Prevent compiler warnings */
    rulesimpleTypeEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end simpleType */

/** 
 * $ANTLR start inlineType
 * ../base/antlr/NDDL3Tree.g:135:1: inlineType[AbstractDomain* baseType] returns [AbstractDomain* result] : (child= valueSet | child= numericInterval ) ;
 */
static AbstractDomain*
inlineType(pNDDL3Tree ctx, AbstractDomain* baseType)
{   
    AbstractDomain* result = NULL;

    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:136:9: ( (child= valueSet | child= numericInterval ) )
        // ../base/antlr/NDDL3Tree.g:136:11: (child= valueSet | child= numericInterval )
        {

            // ../base/antlr/NDDL3Tree.g:136:11: (child= valueSet | child= numericInterval )
            {
                int alt5=2;

                {
                    int LA5_0 = LA(1);
                    if ( (LA5_0 == 35) ) 
                    {
                        alt5=1;
                    }
                    else if ( (LA5_0 == 32) ) 
                    {
                        alt5=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 5;
                        EXCEPTION->state        = 0;


                        goto ruleinlineTypeEx;
                    }
                }
                switch (alt5) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:136:18: child= valueSet
            	    {
            	        FOLLOWPUSH(FOLLOW_valueSet_in_inlineType617);
            	        child=valueSet(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinlineTypeEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // ../base/antlr/NDDL3Tree.g:137:18: child= numericInterval
            	    {
            	        FOLLOWPUSH(FOLLOW_numericInterval_in_inlineType638);
            	        child=numericInterval(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinlineTypeEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                    // TODO: type checking. ensure inline domain is consistent with base
                    DataRef data=evalExpr(CTX,child);    
                    result = (AbstractDomain*)&(data.getValue()->lastDomain()); 

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleinlineTypeEx; /* Prevent compiler warnings */
    ruleinlineTypeEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end inlineType */

/** 
 * $ANTLR start variableDeclarations
 * ../base/antlr/NDDL3Tree.g:146:1: variableDeclarations returns [ExprList* result] : ^( VARIABLE dataType= type (child= variableInitialization[dataType] )+ ) ;
 */
static ExprList*
variableDeclarations(pNDDL3Tree ctx)
{   
    ExprList* result = NULL;

    AbstractDomain* dataType;
    #undef	RETURN_TYPE_dataType
    #define	RETURN_TYPE_dataType AbstractDomain*

    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    dataType = NULL;
    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:147:9: ( ^( VARIABLE dataType= type (child= variableInitialization[dataType] )+ ) )
        // ../base/antlr/NDDL3Tree.g:147:17: ^( VARIABLE dataType= type (child= variableInitialization[dataType] )+ )
        {
             MATCHT(VARIABLE, &FOLLOW_VARIABLE_in_variableDeclarations703); 
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationsEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationsEx;
            }

            FOLLOWPUSH(FOLLOW_type_in_variableDeclarations707);
            dataType=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationsEx;
            }

            {

                                               if (dataType != NULL)
                                                   result = new ExprList();
                                               else { 
                                                   result = NULL;
                                                   reportSemanticError(CTX,
                                                       "Incorrect variable declaration. Unknown data type");
                                               }
                                           
            }
            // ../base/antlr/NDDL3Tree.g:157:28: (child= variableInitialization[dataType] )+
            {
                int cnt6=0;

                for (;;)
                {
                    int alt6=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA6_0 = LA(1);
            	    if ( (LA6_0 == IDENT || LA6_0 == 40) ) 
            	    {
            	        alt6=1;
            	    }

            	}
            	switch (alt6) 
            	{
            	    case 1:
            	        // ../base/antlr/NDDL3Tree.g:157:29: child= variableInitialization[dataType]
            	        {
            	            FOLLOWPUSH(FOLLOW_variableInitialization_in_variableDeclarations769);
            	            child=variableInitialization(ctx, dataType);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulevariableDeclarationsEx;
            	            }

            	            {

            	                                               result->addChild(child);
            	                                           
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt6 >= 1 )
            		{
            		    goto loop6;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulevariableDeclarationsEx;
            	}
            	cnt6++;
                }
                loop6: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationsEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevariableDeclarationsEx; /* Prevent compiler warnings */
    rulevariableDeclarationsEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end variableDeclarations */

/** 
 * $ANTLR start variableInitialization
 * ../base/antlr/NDDL3Tree.g:165:1: variableInitialization[AbstractDomain* dataType] returns [Expr* result] : (name= IDENT | ^( '=' name= IDENT rhs= initializer ) ) ;
 */
static Expr*
variableInitialization(pNDDL3Tree ctx, AbstractDomain* dataType)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    name;
    Expr* rhs;
    #undef	RETURN_TYPE_rhs
    #define	RETURN_TYPE_rhs Expr*

    /* Initialize rule variables
     */


    name       = NULL;
    rhs = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:166:9: ( (name= IDENT | ^( '=' name= IDENT rhs= initializer ) ) )
        // ../base/antlr/NDDL3Tree.g:166:11: (name= IDENT | ^( '=' name= IDENT rhs= initializer ) )
        {

            // ../base/antlr/NDDL3Tree.g:166:11: (name= IDENT | ^( '=' name= IDENT rhs= initializer ) )
            {
                int alt7=2;

                {
                    int LA7_0 = LA(1);
                    if ( (LA7_0 == IDENT) ) 
                    {
                        alt7=1;
                    }
                    else if ( (LA7_0 == 40) ) 
                    {
                        alt7=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 7;
                        EXCEPTION->state        = 0;


                        goto rulevariableInitializationEx;
                    }
                }
                switch (alt7) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:166:18: name= IDENT
            	    {
            	        name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_variableInitialization895); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableInitializationEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // ../base/antlr/NDDL3Tree.g:167:19: ^( '=' name= IDENT rhs= initializer )
            	    {
            	         MATCHT(40, &FOLLOW_40_in_variableInitialization916); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableInitializationEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableInitializationEx;
            	        }

            	        name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_variableInitialization920); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableInitializationEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_initializer_in_variableInitialization924);
            	        rhs=initializer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableInitializationEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableInitializationEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                              const char* varName = c_str((name != NULL ? name->getText(name) : NULL)->chars);
                              Expr* lhs = new ExprVarRef(varName);
                              // TODO: to preserve old semantics, this needs to restrict base domain instead              
                              Expr* initializer = new ExprAssignment(lhs,rhs);
                              result = new ExprVarDeclaration(
                                   varName,
                                   dataType->getTypeName().c_str(),
                                   initializer
                              ); 
                          
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevariableInitializationEx; /* Prevent compiler warnings */
    rulevariableInitializationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end variableInitialization */

/** 
 * $ANTLR start initializer
 * ../base/antlr/NDDL3Tree.g:182:1: initializer returns [Expr* result] : (child= anyValue | child= allocation ) ;
 */
static Expr*
initializer(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:183:9: ( (child= anyValue | child= allocation ) )
        // ../base/antlr/NDDL3Tree.g:183:11: (child= anyValue | child= allocation )
        {

            // ../base/antlr/NDDL3Tree.g:183:11: (child= anyValue | child= allocation )
            {
                int alt8=2;

                {
                    int LA8_0 = LA(1);
                    if ( (((LA8_0 >= IDENT) && (LA8_0 <= FLOAT)) || LA8_0 == 32 || LA8_0 == 35 || ((LA8_0 >= 82) && (LA8_0 <= 85))) ) 
                    {
                        alt8=1;
                    }
                    else if ( (LA8_0 == CONSTRUCTOR_INVOCATION) ) 
                    {
                        alt8=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 8;
                        EXCEPTION->state        = 0;


                        goto ruleinitializerEx;
                    }
                }
                switch (alt8) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:183:19: child= anyValue
            	    {
            	        FOLLOWPUSH(FOLLOW_anyValue_in_initializer995);
            	        child=anyValue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinitializerEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // ../base/antlr/NDDL3Tree.g:184:19: child= allocation
            	    {
            	        FOLLOWPUSH(FOLLOW_allocation_in_initializer1018);
            	        child=allocation(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinitializerEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                              result = child;
                          
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleinitializerEx; /* Prevent compiler warnings */
    ruleinitializerEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end initializer */

/** 
 * $ANTLR start anyValue
 * ../base/antlr/NDDL3Tree.g:191:1: anyValue returns [Expr* result] : (child= value | child= valueSet | child= numericInterval ) ;
 */
static Expr*
anyValue(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:192:9: ( (child= value | child= valueSet | child= numericInterval ) )
        // ../base/antlr/NDDL3Tree.g:192:11: (child= value | child= valueSet | child= numericInterval )
        {

            // ../base/antlr/NDDL3Tree.g:192:11: (child= value | child= valueSet | child= numericInterval )
            {
                int alt9=3;
                switch ( LA(1) ) 
                {
                case IDENT:
                case STRING:
                case INT:
                case FLOAT:
                case 82:
                case 83:
                case 84:
                case 85:
                	{
                		alt9=1;
                	}
                    break;
                case 35:
                	{
                		alt9=2;
                	}
                    break;
                case 32:
                	{
                		alt9=3;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 9;
                    EXCEPTION->state        = 0;


                    goto ruleanyValueEx;
                }

                switch (alt9) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:192:18: child= value
            	    {
            	        FOLLOWPUSH(FOLLOW_value_in_anyValue1080);
            	        child=value(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleanyValueEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // ../base/antlr/NDDL3Tree.g:193:18: child= valueSet
            	    {
            	        FOLLOWPUSH(FOLLOW_valueSet_in_anyValue1101);
            	        child=valueSet(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleanyValueEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // ../base/antlr/NDDL3Tree.g:194:18: child= numericInterval
            	    {
            	        FOLLOWPUSH(FOLLOW_numericInterval_in_anyValue1122);
            	        child=numericInterval(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleanyValueEx;
            	        }


            	    }
            	    break;

                }
            }
            {
                 
                              result = child;
                          
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleanyValueEx; /* Prevent compiler warnings */
    ruleanyValueEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end anyValue */

/** 
 * $ANTLR start value
 * ../base/antlr/NDDL3Tree.g:201:1: value returns [Expr* result] : (child= booleanLiteral | child= stringLiteral | child= numericLiteral | ^(i= IDENT ( type )? ) ) ;
 */
static Expr*
value(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    i;
    AbstractDomain* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child AbstractDomain*

    /* Initialize rule variables
     */



        result = NULL;

    i       = NULL;
    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:205:9: ( (child= booleanLiteral | child= stringLiteral | child= numericLiteral | ^(i= IDENT ( type )? ) ) )
        // ../base/antlr/NDDL3Tree.g:205:11: (child= booleanLiteral | child= stringLiteral | child= numericLiteral | ^(i= IDENT ( type )? ) )
        {

            // ../base/antlr/NDDL3Tree.g:205:11: (child= booleanLiteral | child= stringLiteral | child= numericLiteral | ^(i= IDENT ( type )? ) )
            {
                int alt11=4;
                switch ( LA(1) ) 
                {
                case 84:
                case 85:
                	{
                		alt11=1;
                	}
                    break;
                case STRING:
                	{
                		alt11=2;
                	}
                    break;
                case INT:
                case FLOAT:
                case 82:
                case 83:
                	{
                		alt11=3;
                	}
                    break;
                case IDENT:
                	{
                		alt11=4;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 11;
                    EXCEPTION->state        = 0;


                    goto rulevalueEx;
                }

                switch (alt11) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:205:19: child= booleanLiteral
            	    {
            	        FOLLOWPUSH(FOLLOW_booleanLiteral_in_value1190);
            	        child=booleanLiteral(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevalueEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // ../base/antlr/NDDL3Tree.g:206:19: child= stringLiteral
            	    {
            	        FOLLOWPUSH(FOLLOW_stringLiteral_in_value1212);
            	        child=stringLiteral(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevalueEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // ../base/antlr/NDDL3Tree.g:207:19: child= numericLiteral
            	    {
            	        FOLLOWPUSH(FOLLOW_numericLiteral_in_value1234);
            	        child=numericLiteral(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevalueEx;
            	        }


            	    }
            	    break;
            	case 4:
            	    // ../base/antlr/NDDL3Tree.g:208:19: ^(i= IDENT ( type )? )
            	    {
            	        i = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_value1258); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevalueEx;
            	        }


            	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
            	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulevalueEx;
            	            }


            	            // ../base/antlr/NDDL3Tree.g:208:29: ( type )?
            	            {
            	                int alt10=2;
            	                {
            	                    int LA10_0 = LA(1);
            	                    if ( (LA10_0 == IDENT || ((LA10_0 >= 28) && (LA10_0 <= 31))) ) 
            	                    {
            	                        alt10=1;
            	                    }
            	                }
            	                switch (alt10) 
            	                {
            	            	case 1:
            	            	    // ../base/antlr/NDDL3Tree.g:208:29: type
            	            	    {
            	            	        FOLLOWPUSH(FOLLOW_type_in_value1260);
            	            	        type(ctx);

            	            	        FOLLOWPOP();
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto rulevalueEx;
            	            	        }


            	            	    }
            	            	    break;

            	                }
            	            }

            	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulevalueEx;
            	            }

            	        }
            	        {
            	             result = new ExprVarRef(c_str((i != NULL ? i->getText(i) : NULL)->chars)); 
            	        }

            	    }
            	    break;

                }
            }
            {
                 
                              if (result == NULL)
                                  result = new ExprConstant(
                                      CTX->SymbolTable->getPlanDatabase()->getClient(),
                                      child->getTypeName().c_str(),
                                      child); 
                          
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevalueEx; /* Prevent compiler warnings */
    rulevalueEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end value */

/** 
 * $ANTLR start valueSet
 * ../base/antlr/NDDL3Tree.g:220:1: valueSet returns [Expr* result] : ^( '{' (element= value )* ) ;
 */
static Expr*
valueSet(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Expr* element;
    #undef	RETURN_TYPE_element
    #define	RETURN_TYPE_element Expr*

    /* Initialize rule variables
     */



        bool isNumeric = false;
        std::list<double> values;
        std::string autoName = getAutoLabel("ENUM");
        const char* typeName = autoName.c_str();

    element = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:227:9: ( ^( '{' (element= value )* ) )
        // ../base/antlr/NDDL3Tree.g:227:17: ^( '{' (element= value )* )
        {
             MATCHT(35, &FOLLOW_35_in_valueSet1349); 
            if  (HASEXCEPTION())
            {
                goto rulevalueSetEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulevalueSetEx;
                }


                // ../base/antlr/NDDL3Tree.g:228:25: (element= value )*

                for (;;)
                {
                    int alt12=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA12_0 = LA(1);
                        if ( (((LA12_0 >= IDENT) && (LA12_0 <= FLOAT)) || ((LA12_0 >= 82) && (LA12_0 <= 85))) ) 
                        {
                            alt12=1;
                        }

                    }
                    switch (alt12) 
                    {
                	case 1:
                	    // ../base/antlr/NDDL3Tree.g:228:26: element= value
                	    {
                	        FOLLOWPUSH(FOLLOW_value_in_valueSet1378);
                	        element=value(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulevalueSetEx;
                	        }

                	        {

                	                                         DataRef elemValue = evalExpr(CTX,element);
                	                                         const AbstractDomain& ev = elemValue.getValue()->lastDomain(); 
                	                                         // TODO: delete element;
                	                                         double v = ev.getSingletonValue();
                	                                         values.push_back(v);
                	                                         isNumeric = ev.isNumeric();
                	                                         // TODO: make sure data types for all values are consistent
                	                                     
                	        }

                	    }
                	    break;

                	default:
                	    goto loop12;	/* break out of the loop */
                	    break;
                    }
                }
                loop12: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulevalueSetEx;
                }

            }
            {

                                   AbstractDomain* newDomain = new EnumeratedDomain(values,isNumeric,typeName); 
                                   result = new ExprConstant(
                                       CTX->SymbolTable->getPlanDatabase()->getClient(),
                                       typeName,
                                       newDomain                       
                                   );
                                   
                                   // TODO: this is necessary so that the Expr definaed above can be evaluated, see about fixing it.
                                   ExprTypedef newTypedef(typeName,newDomain);
                                   evalExpr(CTX,&newTypedef);
                                 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevalueSetEx; /* Prevent compiler warnings */
    rulevalueSetEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end valueSet */

/** 
 * $ANTLR start booleanLiteral
 * ../base/antlr/NDDL3Tree.g:254:1: booleanLiteral returns [AbstractDomain* result] : ( 'true' | 'false' );
 */
static AbstractDomain*
booleanLiteral(pNDDL3Tree ctx)
{   
    AbstractDomain* result = NULL;

    /* Initialize rule variables
     */


    {
        {
            //  ../base/antlr/NDDL3Tree.g:255:9: ( 'true' | 'false' )
            
            ANTLR3_UINT32 alt13;

            alt13=2;


            {
                int LA13_0 = LA(1);
                if ( (LA13_0 == 84) ) 
                {
                    alt13=1;
                }
                else if ( (LA13_0 == 85) ) 
                {
                    alt13=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 13;
                    EXCEPTION->state        = 0;


                    goto rulebooleanLiteralEx;
                }
            }
            switch (alt13) 
            {
        	case 1:
        	    // ../base/antlr/NDDL3Tree.g:255:17: 'true'
        	    {
        	         MATCHT(84, &FOLLOW_84_in_booleanLiteral1505); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebooleanLiteralEx;
        	        }

        	        {
        	             result = new BoolDomain(true); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // ../base/antlr/NDDL3Tree.g:256:17: 'false'
        	    {
        	         MATCHT(85, &FOLLOW_85_in_booleanLiteral1538); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebooleanLiteralEx;
        	        }

        	        {
        	             result = new BoolDomain(false); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulebooleanLiteralEx; /* Prevent compiler warnings */
    rulebooleanLiteralEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end booleanLiteral */

/** 
 * $ANTLR start stringLiteral
 * ../base/antlr/NDDL3Tree.g:259:1: stringLiteral returns [AbstractDomain* result] : str= STRING ;
 */
static AbstractDomain*
stringLiteral(pNDDL3Tree ctx)
{   
    AbstractDomain* result = NULL;

    pANTLR3_BASE_TREE    str;

    /* Initialize rule variables
     */


    str       = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:260:9: (str= STRING )
        // ../base/antlr/NDDL3Tree.g:260:14: str= STRING
        {
            str = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_stringLiteral1576); 
            if  (HASEXCEPTION())
            {
                goto rulestringLiteralEx;
            }

            {
                 
                                 LabelStr value = c_str((str != NULL ? str->getText(str) : NULL)->chars); 
                                 result = new StringDomain((double)value);
                             
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestringLiteralEx; /* Prevent compiler warnings */
    rulestringLiteralEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end stringLiteral */

/** 
 * $ANTLR start numericLiteral
 * ../base/antlr/NDDL3Tree.g:267:1: numericLiteral returns [AbstractDomain* result] : (floating= FLOAT | integer= INT | 'inf' | '-inf' );
 */
static AbstractDomain*
numericLiteral(pNDDL3Tree ctx)
{   
    AbstractDomain* result = NULL;

    pANTLR3_BASE_TREE    floating;
    pANTLR3_BASE_TREE    integer;

    /* Initialize rule variables
     */


    floating       = NULL;
    integer       = NULL;

    {
        {
            //  ../base/antlr/NDDL3Tree.g:268:9: (floating= FLOAT | integer= INT | 'inf' | '-inf' )
            
            ANTLR3_UINT32 alt14;

            alt14=4;

            switch ( LA(1) ) 
            {
            case FLOAT:
            	{
            		alt14=1;
            	}
                break;
            case INT:
            	{
            		alt14=2;
            	}
                break;
            case 82:
            	{
            		alt14=3;
            	}
                break;
            case 83:
            	{
            		alt14=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 14;
                EXCEPTION->state        = 0;


                goto rulenumericLiteralEx;
            }

            switch (alt14) 
            {
        	case 1:
        	    // ../base/antlr/NDDL3Tree.g:268:17: floating= FLOAT
        	    {
        	        floating = (pANTLR3_BASE_TREE) MATCHT(FLOAT, &FOLLOW_FLOAT_in_numericLiteral1630); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenumericLiteralEx;
        	        }

        	        {
        	             result = new IntervalDomain(atof(c_str((floating != NULL ? floating->getText(floating) : NULL)->chars))); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // ../base/antlr/NDDL3Tree.g:269:17: integer= INT
        	    {
        	        integer = (pANTLR3_BASE_TREE) MATCHT(INT, &FOLLOW_INT_in_numericLiteral1653); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenumericLiteralEx;
        	        }

        	        {
        	             result = new IntervalIntDomain(atoi(c_str((integer != NULL ? integer->getText(integer) : NULL)->chars))); 
        	        }

        	    }
        	    break;
        	case 3:
        	    // ../base/antlr/NDDL3Tree.g:270:17: 'inf'
        	    {
        	         MATCHT(82, &FOLLOW_82_in_numericLiteral1677); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenumericLiteralEx;
        	        }

        	        {
        	             result = new IntervalIntDomain(PLUS_INFINITY); 
        	        }

        	    }
        	    break;
        	case 4:
        	    // ../base/antlr/NDDL3Tree.g:271:17: '-inf'
        	    {
        	         MATCHT(83, &FOLLOW_83_in_numericLiteral1710); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenumericLiteralEx;
        	        }

        	        {
        	             result = new IntervalIntDomain(MINUS_INFINITY); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulenumericLiteralEx; /* Prevent compiler warnings */
    rulenumericLiteralEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end numericLiteral */

/** 
 * $ANTLR start numericInterval
 * ../base/antlr/NDDL3Tree.g:274:1: numericInterval returns [Expr* result] : ^( '[' lower= numericLiteral upper= numericLiteral ) ;
 */
static Expr*
numericInterval(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    AbstractDomain* lower;
    #undef	RETURN_TYPE_lower
    #define	RETURN_TYPE_lower AbstractDomain*

    AbstractDomain* upper;
    #undef	RETURN_TYPE_upper
    #define	RETURN_TYPE_upper AbstractDomain*

    /* Initialize rule variables
     */


    lower = NULL;
    upper = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:275:9: ( ^( '[' lower= numericLiteral upper= numericLiteral ) )
        // ../base/antlr/NDDL3Tree.g:275:17: ^( '[' lower= numericLiteral upper= numericLiteral )
        {
             MATCHT(32, &FOLLOW_32_in_numericInterval1759); 
            if  (HASEXCEPTION())
            {
                goto rulenumericIntervalEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulenumericIntervalEx;
            }

            FOLLOWPUSH(FOLLOW_numericLiteral_in_numericInterval1790);
            lower=numericLiteral(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenumericIntervalEx;
            }

            FOLLOWPUSH(FOLLOW_numericLiteral_in_numericInterval1818);
            upper=numericLiteral(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenumericIntervalEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulenumericIntervalEx;
            }

            {
                      
                                    double lb = lower->getSingletonValue();
                                    double ub = upper->getSingletonValue();
                                    const char* typeName;
                                    AbstractDomain* baseDomain;
                                    
                                    if (lower->getTypeName().toString()=="float" || upper->getTypeName().toString()=="float") {
                                        typeName = "float";
                                        baseDomain = new IntervalDomain(lb,ub);
                                    }
                                    else {
                                        typeName = "int";
                                        baseDomain = new IntervalIntDomain((int)lb,(int)ub);
                                    }
                                                  
                                    result = new ExprConstant(
                                        CTX->SymbolTable->getPlanDatabase()->getClient(),
                                        lower->getTypeName().c_str(),
                                        baseDomain
                                    );
                                    
                                    delete lower;
                                    delete upper;
                                
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenumericIntervalEx; /* Prevent compiler warnings */
    rulenumericIntervalEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end numericInterval */

/** 
 * $ANTLR start allocation
 * ../base/antlr/NDDL3Tree.g:305:1: allocation returns [Expr* result] : ^( CONSTRUCTOR_INVOCATION objType= IDENT ( variableArgumentList[args] )? ) ;
 */
static Expr*
allocation(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    objType;

    /* Initialize rule variables
     */



        std::vector<Expr*> args;

    objType       = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:309:9: ( ^( CONSTRUCTOR_INVOCATION objType= IDENT ( variableArgumentList[args] )? ) )
        // ../base/antlr/NDDL3Tree.g:309:17: ^( CONSTRUCTOR_INVOCATION objType= IDENT ( variableArgumentList[args] )? )
        {
             MATCHT(CONSTRUCTOR_INVOCATION, &FOLLOW_CONSTRUCTOR_INVOCATION_in_allocation1895); 
            if  (HASEXCEPTION())
            {
                goto ruleallocationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleallocationEx;
            }

            objType = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_allocation1923); 
            if  (HASEXCEPTION())
            {
                goto ruleallocationEx;
            }


            // ../base/antlr/NDDL3Tree.g:311:25: ( variableArgumentList[args] )?
            {
                int alt15=2;
                {
                    int LA15_0 = LA(1);
                    if ( (LA15_0 == 38) ) 
                    {
                        alt15=1;
                    }
                }
                switch (alt15) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:311:25: variableArgumentList[args]
            	    {
            	        FOLLOWPUSH(FOLLOW_variableArgumentList_in_allocation1950);
            	        variableArgumentList(ctx, args);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleallocationEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleallocationEx;
            }

            {

                                    result = new ExprNewObject(
                                        CTX->SymbolTable->getPlanDatabase()->getClient(),
                                        c_str((objType != NULL ? objType->getText(objType) : NULL)->chars), // objectType
                                        "", // TODO!: object name?
                                        args
                                    );
                                
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleallocationEx; /* Prevent compiler warnings */
    ruleallocationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end allocation */

/** 
 * $ANTLR start variableArgumentList
 * ../base/antlr/NDDL3Tree.g:323:1: variableArgumentList[std::vector<Expr*>& result] : ^( '(' (arg= initializer )* ) ;
 */
static void
variableArgumentList(pNDDL3Tree ctx, std::vector<Expr*>& result)
{   
    Expr* arg;
    #undef	RETURN_TYPE_arg
    #define	RETURN_TYPE_arg Expr*

    /* Initialize rule variables
     */


    arg = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:324:9: ( ^( '(' (arg= initializer )* ) )
        // ../base/antlr/NDDL3Tree.g:324:17: ^( '(' (arg= initializer )* )
        {
             MATCHT(38, &FOLLOW_38_in_variableArgumentList2021); 
            if  (HASEXCEPTION())
            {
                goto rulevariableArgumentListEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulevariableArgumentListEx;
                }


                // ../base/antlr/NDDL3Tree.g:325:25: (arg= initializer )*

                for (;;)
                {
                    int alt16=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA16_0 = LA(1);
                        if ( (LA16_0 == CONSTRUCTOR_INVOCATION || ((LA16_0 >= IDENT) && (LA16_0 <= FLOAT)) || LA16_0 == 32 || LA16_0 == 35 || ((LA16_0 >= 82) && (LA16_0 <= 85))) ) 
                        {
                            alt16=1;
                        }

                    }
                    switch (alt16) 
                    {
                	case 1:
                	    // ../base/antlr/NDDL3Tree.g:325:26: arg= initializer
                	    {
                	        FOLLOWPUSH(FOLLOW_initializer_in_variableArgumentList2050);
                	        arg=initializer(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulevariableArgumentListEx;
                	        }

                	        {
                	            result.push_back(arg);
                	        }

                	    }
                	    break;

                	default:
                	    goto loop16;	/* break out of the loop */
                	    break;
                    }
                }
                loop16: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulevariableArgumentListEx;
                }

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevariableArgumentListEx; /* Prevent compiler warnings */
    rulevariableArgumentListEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end variableArgumentList */

/** 
 * $ANTLR start identifier
 * ../base/antlr/NDDL3Tree.g:329:1: identifier : ( IDENT | 'this' );
 */
static NDDL3Tree_identifier_return
identifier(pNDDL3Tree ctx)
{   
    NDDL3Tree_identifier_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1);

    {
        // ../base/antlr/NDDL3Tree.g:330:9: ( IDENT | 'this' )
        // ../base/antlr/NDDL3Tree.g:
        {
            if ( LA(1) == IDENT || LA(1) == 42 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_identifier0);    goto ruleidentifierEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleidentifierEx; /* Prevent compiler warnings */
    ruleidentifierEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end identifier */

/** 
 * $ANTLR start constraintInstantiation
 * ../base/antlr/NDDL3Tree.g:334:1: constraintInstantiation returns [ExprConstraint* result] : ^( CONSTRAINT_INSTANTIATION name= IDENT variableArgumentList[args] ) ;
 */
static ExprConstraint*
constraintInstantiation(pNDDL3Tree ctx)
{   
    ExprConstraint* result = NULL;

    pANTLR3_BASE_TREE    name;

    /* Initialize rule variables
     */



        std::vector<Expr*> args;

    name       = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:338:9: ( ^( CONSTRAINT_INSTANTIATION name= IDENT variableArgumentList[args] ) )
        // ../base/antlr/NDDL3Tree.g:339:15: ^( CONSTRAINT_INSTANTIATION name= IDENT variableArgumentList[args] )
        {
             MATCHT(CONSTRAINT_INSTANTIATION, &FOLLOW_CONSTRAINT_INSTANTIATION_in_constraintInstantiation2166); 
            if  (HASEXCEPTION())
            {
                goto ruleconstraintInstantiationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstraintInstantiationEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_constraintInstantiation2194); 
            if  (HASEXCEPTION())
            {
                goto ruleconstraintInstantiationEx;
            }

            FOLLOWPUSH(FOLLOW_variableArgumentList_in_constraintInstantiation2220);
            variableArgumentList(ctx, args);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconstraintInstantiationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstraintInstantiationEx;
            }

            {

                                    result = new ExprConstraint(c_str((name != NULL ? name->getText(name) : NULL)->chars),args);
                                
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconstraintInstantiationEx; /* Prevent compiler warnings */
    ruleconstraintInstantiationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end constraintInstantiation */

/** 
 * $ANTLR start classDeclaration
 * ../base/antlr/NDDL3Tree.g:349:1: classDeclaration returns [Expr* result] : ^( 'class' className= IDENT ( ^( 'extends' superClass= IDENT ) )? ( classBlock[objType] | ';' ) ) ;
 */
static Expr*
classDeclaration(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    className;
    pANTLR3_BASE_TREE    superClass;

    /* Initialize rule variables
     */



    const char* newClass = NULL;
    const char* parentClass = "Object";
    ObjectType* objType = NULL;

    className       = NULL;
    superClass       = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:355:2: ( ^( 'class' className= IDENT ( ^( 'extends' superClass= IDENT ) )? ( classBlock[objType] | ';' ) ) )
        // ../base/antlr/NDDL3Tree.g:355:4: ^( 'class' className= IDENT ( ^( 'extends' superClass= IDENT ) )? ( classBlock[objType] | ';' ) )
        {
             MATCHT(45, &FOLLOW_45_in_classDeclaration2302); 
            if  (HASEXCEPTION())
            {
                goto ruleclassDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleclassDeclarationEx;
            }

            className = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_classDeclaration2325); 
            if  (HASEXCEPTION())
            {
                goto ruleclassDeclarationEx;
            }

            {
                 newClass = c_str((className != NULL ? className->getText(className) : NULL)->chars); 
            }

            // ../base/antlr/NDDL3Tree.g:358:6: ( ^( 'extends' superClass= IDENT ) )?
            {
                int alt17=2;
                {
                    int LA17_0 = LA(1);
                    if ( (LA17_0 == 46) ) 
                    {
                        alt17=1;
                    }
                }
                switch (alt17) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:358:7: ^( 'extends' superClass= IDENT )
            	    {
            	         MATCHT(46, &FOLLOW_46_in_classDeclaration2356); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleclassDeclarationEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleclassDeclarationEx;
            	        }

            	        superClass = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_classDeclaration2360); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleclassDeclarationEx;
            	        }

            	        {
            	             parentClass = c_str((superClass != NULL ? superClass->getText(superClass) : NULL)->chars); 
            	        }

            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleclassDeclarationEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                                       objType = new ObjectType(newClass,parentClass);
                                       
                                   
            }

            // ../base/antlr/NDDL3Tree.g:365:20: ( classBlock[objType] | ';' )
            {
                int alt18=2;

                {
                    int LA18_0 = LA(1);
                    if ( (LA18_0 == 35) ) 
                    {
                        alt18=1;
                    }
                    else if ( (LA18_0 == 27) ) 
                    {
                        alt18=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 18;
                        EXCEPTION->state        = 0;


                        goto ruleclassDeclarationEx;
                    }
                }
                switch (alt18) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:366:10: classBlock[objType]
            	    {
            	        FOLLOWPUSH(FOLLOW_classBlock_in_classDeclaration2444);
            	        classBlock(ctx, objType);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleclassDeclarationEx;
            	        }

            	        {
            	             result = new ExprObjectTypeDefinition(objType->getId()); 
            	        }

            	    }
            	    break;
            	case 2:
            	    // ../base/antlr/NDDL3Tree.g:367:12: ';'
            	    {
            	         MATCHT(27, &FOLLOW_27_in_classDeclaration2461); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleclassDeclarationEx;
            	        }

            	        {
            	             result = new ExprObjectTypeDeclaration(objType->getId()); 
            	        }

            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleclassDeclarationEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleclassDeclarationEx; /* Prevent compiler warnings */
    ruleclassDeclarationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end classDeclaration */

/** 
 * $ANTLR start classBlock
 * ../base/antlr/NDDL3Tree.g:372:1: classBlock[ObjectType* objType] : ^( '{' ( componentTypeEntry[objType] )* ) ;
 */
static void
classBlock(pNDDL3Tree ctx, ObjectType* objType)
{   
    /* Initialize rule variables
     */


    {
        // ../base/antlr/NDDL3Tree.g:373:2: ( ^( '{' ( componentTypeEntry[objType] )* ) )
        // ../base/antlr/NDDL3Tree.g:373:4: ^( '{' ( componentTypeEntry[objType] )* )
        {
             MATCHT(35, &FOLLOW_35_in_classBlock2495); 
            if  (HASEXCEPTION())
            {
                goto ruleclassBlockEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleclassBlockEx;
                }


                // ../base/antlr/NDDL3Tree.g:374:4: ( componentTypeEntry[objType] )*

                for (;;)
                {
                    int alt19=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA19_0 = LA(1);
                        if ( (LA19_0 == CONSTRUCTOR || LA19_0 == VARIABLE || LA19_0 == 47) ) 
                        {
                            alt19=1;
                        }

                    }
                    switch (alt19) 
                    {
                	case 1:
                	    // ../base/antlr/NDDL3Tree.g:374:4: componentTypeEntry[objType]
                	    {
                	        FOLLOWPUSH(FOLLOW_componentTypeEntry_in_classBlock2500);
                	        componentTypeEntry(ctx, objType);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleclassBlockEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop19;	/* break out of the loop */
                	    break;
                    }
                }
                loop19: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleclassBlockEx;
                }

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleclassBlockEx; /* Prevent compiler warnings */
    ruleclassBlockEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end classBlock */

/** 
 * $ANTLR start componentTypeEntry
 * ../base/antlr/NDDL3Tree.g:378:1: componentTypeEntry[ObjectType* objType] : ( classVariable[objType] | constructor[objType] | predicate[objType] );
 */
static void
componentTypeEntry(pNDDL3Tree ctx, ObjectType* objType)
{   
    /* Initialize rule variables
     */


    {
        {
            //  ../base/antlr/NDDL3Tree.g:379:2: ( classVariable[objType] | constructor[objType] | predicate[objType] )
            
            ANTLR3_UINT32 alt20;

            alt20=3;

            switch ( LA(1) ) 
            {
            case VARIABLE:
            	{
            		alt20=1;
            	}
                break;
            case CONSTRUCTOR:
            	{
            		alt20=2;
            	}
                break;
            case 47:
            	{
            		alt20=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 20;
                EXCEPTION->state        = 0;


                goto rulecomponentTypeEntryEx;
            }

            switch (alt20) 
            {
        	case 1:
        	    // ../base/antlr/NDDL3Tree.g:379:4: classVariable[objType]
        	    {
        	        FOLLOWPUSH(FOLLOW_classVariable_in_componentTypeEntry2518);
        	        classVariable(ctx, objType);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponentTypeEntryEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../base/antlr/NDDL3Tree.g:380:4: constructor[objType]
        	    {
        	        FOLLOWPUSH(FOLLOW_constructor_in_componentTypeEntry2524);
        	        constructor(ctx, objType);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponentTypeEntryEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../base/antlr/NDDL3Tree.g:381:4: predicate[objType]
        	    {
        	        FOLLOWPUSH(FOLLOW_predicate_in_componentTypeEntry2530);
        	        predicate(ctx, objType);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponentTypeEntryEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecomponentTypeEntryEx; /* Prevent compiler warnings */
    rulecomponentTypeEntryEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end componentTypeEntry */

/** 
 * $ANTLR start classVariable
 * ../base/antlr/NDDL3Tree.g:384:1: classVariable[ObjectType* objType] : ^( VARIABLE dataType= type name= IDENT ) ;
 */
static void
classVariable(pNDDL3Tree ctx, ObjectType* objType)
{   
    pANTLR3_BASE_TREE    name;
    AbstractDomain* dataType;
    #undef	RETURN_TYPE_dataType
    #define	RETURN_TYPE_dataType AbstractDomain*

    /* Initialize rule variables
     */


    name       = NULL;
    dataType = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:385:9: ( ^( VARIABLE dataType= type name= IDENT ) )
        // ../base/antlr/NDDL3Tree.g:385:17: ^( VARIABLE dataType= type name= IDENT )
        {
             MATCHT(VARIABLE, &FOLLOW_VARIABLE_in_classVariable2557); 
            if  (HASEXCEPTION())
            {
                goto ruleclassVariableEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleclassVariableEx;
            }

            FOLLOWPUSH(FOLLOW_type_in_classVariable2561);
            dataType=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleclassVariableEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_classVariable2565); 
            if  (HASEXCEPTION())
            {
                goto ruleclassVariableEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleclassVariableEx;
            }

            {

                            objType->addMember(dataType->getTypeName().c_str(),c_str((name != NULL ? name->getText(name) : NULL)->chars)); // TODO!!: this won't work for inlined types
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleclassVariableEx; /* Prevent compiler warnings */
    ruleclassVariableEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end classVariable */

/** 
 * $ANTLR start constructor
 * ../base/antlr/NDDL3Tree.g:391:1: constructor[ObjectType* objType] : ^( CONSTRUCTOR name= IDENT ^( '(' ( constructorArgument[argNames,argTypes] )* ) ^( '{' (superCallExpr= constructorSuper[objType] )? (child= assignment )* ) ) ;
 */
static void
constructor(pNDDL3Tree ctx, ObjectType* objType)
{   
    pANTLR3_BASE_TREE    name;
    ExprConstructorSuperCall* superCallExpr;
    #undef	RETURN_TYPE_superCallExpr
    #define	RETURN_TYPE_superCallExpr ExprConstructorSuperCall*

    ExprAssignment* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child ExprAssignment*

    /* Initialize rule variables
     */



        std::vector<std::string> argNames;
        std::vector<std::string> argTypes;
        std::vector<Expr*> body;

    name       = NULL;
    superCallExpr = NULL;
    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:397:2: ( ^( CONSTRUCTOR name= IDENT ^( '(' ( constructorArgument[argNames,argTypes] )* ) ^( '{' (superCallExpr= constructorSuper[objType] )? (child= assignment )* ) ) )
        // ../base/antlr/NDDL3Tree.g:397:4: ^( CONSTRUCTOR name= IDENT ^( '(' ( constructorArgument[argNames,argTypes] )* ) ^( '{' (superCallExpr= constructorSuper[objType] )? (child= assignment )* ) )
        {
             MATCHT(CONSTRUCTOR, &FOLLOW_CONSTRUCTOR_in_constructor2609); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_constructor2616); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorEx;
            }

             MATCHT(38, &FOLLOW_38_in_constructor2622); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleconstructorEx;
                }


                // ../base/antlr/NDDL3Tree.g:399:10: ( constructorArgument[argNames,argTypes] )*

                for (;;)
                {
                    int alt21=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA21_0 = LA(1);
                        if ( (LA21_0 == VARIABLE) ) 
                        {
                            alt21=1;
                        }

                    }
                    switch (alt21) 
                    {
                	case 1:
                	    // ../base/antlr/NDDL3Tree.g:399:10: constructorArgument[argNames,argTypes]
                	    {
                	        FOLLOWPUSH(FOLLOW_constructorArgument_in_constructor2624);
                	        constructorArgument(ctx, argNames, argTypes);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleconstructorEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop21;	/* break out of the loop */
                	    break;
                    }
                }
                loop21: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleconstructorEx;
                }

            }
             MATCHT(35, &FOLLOW_35_in_constructor2633); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleconstructorEx;
                }


                // ../base/antlr/NDDL3Tree.g:400:23: (superCallExpr= constructorSuper[objType] )?
                {
                    int alt22=2;
                    {
                        int LA22_0 = LA(1);
                        if ( (LA22_0 == 52) ) 
                        {
                            alt22=1;
                        }
                    }
                    switch (alt22) 
                    {
                	case 1:
                	    // ../base/antlr/NDDL3Tree.g:400:23: superCallExpr= constructorSuper[objType]
                	    {
                	        FOLLOWPUSH(FOLLOW_constructorSuper_in_constructor2637);
                	        superCallExpr=constructorSuper(ctx, objType);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleconstructorEx;
                	        }


                	    }
                	    break;

                    }
                }

                // ../base/antlr/NDDL3Tree.g:401:10: (child= assignment )*

                for (;;)
                {
                    int alt23=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA23_0 = LA(1);
                        if ( (LA23_0 == 40) ) 
                        {
                            alt23=1;
                        }

                    }
                    switch (alt23) 
                    {
                	case 1:
                	    // ../base/antlr/NDDL3Tree.g:401:11: child= assignment
                	    {
                	        FOLLOWPUSH(FOLLOW_assignment_in_constructor2653);
                	        child=assignment(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleconstructorEx;
                	        }

                	        {
                	            body.push_back(child);
                	        }

                	    }
                	    break;

                	default:
                	    goto loop23;	/* break out of the loop */
                	    break;
                    }
                }
                loop23: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleconstructorEx;
                }

            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorEx;
            }

            {

                		    std::ostringstream signature;
                		    signature << objType->getName().c_str();
                		    
                		    for (unsigned int i=0;i<argTypes.size();i++)
                		        signature << ":" << argTypes[i];
                		        
                                    objType->addObjectFactory(
                                        (new InterpretedObjectFactory(
                                            objType->getId(),
                                            signature.str(),
                                            argNames,
                                            argTypes,
                                            superCallExpr,
                                            body)
                                        )->getId()
                                    );
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconstructorEx; /* Prevent compiler warnings */
    ruleconstructorEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end constructor */

/** 
 * $ANTLR start constructorArgument
 * ../base/antlr/NDDL3Tree.g:423:1: constructorArgument[std::vector<std::string>& argNames,std::vector<std::string>& argTypes] : ^( VARIABLE argName= IDENT argType= type ) ;
 */
static void
constructorArgument(pNDDL3Tree ctx, std::vector<std::string>& argNames, std::vector<std::string>& argTypes)
{   
    pANTLR3_BASE_TREE    argName;
    AbstractDomain* argType;
    #undef	RETURN_TYPE_argType
    #define	RETURN_TYPE_argType AbstractDomain*

    /* Initialize rule variables
     */


    argName       = NULL;
    argType = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:424:2: ( ^( VARIABLE argName= IDENT argType= type ) )
        // ../base/antlr/NDDL3Tree.g:424:4: ^( VARIABLE argName= IDENT argType= type )
        {
             MATCHT(VARIABLE, &FOLLOW_VARIABLE_in_constructorArgument2679); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorArgumentEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorArgumentEx;
            }

            argName = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_constructorArgument2686); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorArgumentEx;
            }

            FOLLOWPUSH(FOLLOW_type_in_constructorArgument2693);
            argType=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconstructorArgumentEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorArgumentEx;
            }

            {

                		    argNames.push_back(std::string(c_str((argName != NULL ? argName->getText(argName) : NULL)->chars)));
                		    argTypes.push_back(argType->getTypeName().toString());
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconstructorArgumentEx; /* Prevent compiler warnings */
    ruleconstructorArgumentEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end constructorArgument */

/** 
 * $ANTLR start constructorSuper
 * ../base/antlr/NDDL3Tree.g:434:1: constructorSuper[ObjectType* objType] returns [ExprConstructorSuperCall* result] : ^( 'super' variableArgumentList[args] ) ;
 */
static ExprConstructorSuperCall*
constructorSuper(pNDDL3Tree ctx, ObjectType* objType)
{   
    ExprConstructorSuperCall* result = NULL;

    /* Initialize rule variables
     */



        std::vector<Expr*> args;

    {
        // ../base/antlr/NDDL3Tree.g:438:2: ( ^( 'super' variableArgumentList[args] ) )
        // ../base/antlr/NDDL3Tree.g:438:4: ^( 'super' variableArgumentList[args] )
        {
             MATCHT(52, &FOLLOW_52_in_constructorSuper2723); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorSuperEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorSuperEx;
            }

            FOLLOWPUSH(FOLLOW_variableArgumentList_in_constructorSuper2728);
            variableArgumentList(ctx, args);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconstructorSuperEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconstructorSuperEx;
            }

            {

                		    result = new ExprConstructorSuperCall(objType->getParent(),args);  
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconstructorSuperEx; /* Prevent compiler warnings */
    ruleconstructorSuperEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end constructorSuper */

/** 
 * $ANTLR start assignment
 * ../base/antlr/NDDL3Tree.g:446:1: assignment returns [ExprAssignment* result] : ^( '=' lhs= qualified rhs= initializer ) ;
 */
static ExprAssignment*
assignment(pNDDL3Tree ctx)
{   
    ExprAssignment* result = NULL;

    Expr* lhs;
    #undef	RETURN_TYPE_lhs
    #define	RETURN_TYPE_lhs Expr*

    Expr* rhs;
    #undef	RETURN_TYPE_rhs
    #define	RETURN_TYPE_rhs Expr*

    /* Initialize rule variables
     */


    lhs = NULL;
    rhs = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:447:2: ( ^( '=' lhs= qualified rhs= initializer ) )
        // ../base/antlr/NDDL3Tree.g:447:4: ^( '=' lhs= qualified rhs= initializer )
        {
             MATCHT(40, &FOLLOW_40_in_assignment2755); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }

            FOLLOWPUSH(FOLLOW_qualified_in_assignment2762);
            lhs=qualified(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }

            FOLLOWPUSH(FOLLOW_initializer_in_assignment2769);
            rhs=initializer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }

            {

                		    result = new ExprAssignment(lhs,rhs);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleassignmentEx; /* Prevent compiler warnings */
    ruleassignmentEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end assignment */

/** 
 * $ANTLR start predicate
 * ../base/antlr/NDDL3Tree.g:456:1: predicate[ObjectType* objType] : ^( 'predicate' pred= IDENT predicateStatements[tokenFactory] ) ;
 */
static void
predicate(pNDDL3Tree ctx, ObjectType* objType)
{   
    pANTLR3_BASE_TREE    pred;

    /* Initialize rule variables
     */



        InterpretedTokenFactory* tokenFactory;
        std::string predName;

    pred       = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:461:2: ( ^( 'predicate' pred= IDENT predicateStatements[tokenFactory] ) )
        // ../base/antlr/NDDL3Tree.g:461:4: ^( 'predicate' pred= IDENT predicateStatements[tokenFactory] )
        {
             MATCHT(47, &FOLLOW_47_in_predicate2795); 
            if  (HASEXCEPTION())
            {
                goto rulepredicateEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepredicateEx;
            }

            pred = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_predicate2802); 
            if  (HASEXCEPTION())
            {
                goto rulepredicateEx;
            }

            {
                 
                			    predName = objType->getName().toString() + "." + c_str((pred != NULL ? pred->getText(pred) : NULL)->chars);   
                			    tokenFactory = new InterpretedTokenFactory(predName,objType->getId()); 
                			
            }
            FOLLOWPUSH(FOLLOW_predicateStatements_in_predicate2813);
            predicateStatements(ctx, tokenFactory);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepredicateEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepredicateEx;
            }

            {

                                    objType->addTokenFactory(tokenFactory->getId());
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepredicateEx; /* Prevent compiler warnings */
    rulepredicateEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end predicate */

/** 
 * $ANTLR start predicateStatements
 * ../base/antlr/NDDL3Tree.g:475:1: predicateStatements[InterpretedTokenFactory* tokenFactory] : ^( '{' ( (child= predicateParameter[tokenFactory] | child= predicateParameterAssignment | child= standardConstraint ) )* ) ;
 */
static void
predicateStatements(pNDDL3Tree ctx, InterpretedTokenFactory* tokenFactory)
{   
    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:476:2: ( ^( '{' ( (child= predicateParameter[tokenFactory] | child= predicateParameterAssignment | child= standardConstraint ) )* ) )
        // ../base/antlr/NDDL3Tree.g:476:4: ^( '{' ( (child= predicateParameter[tokenFactory] | child= predicateParameterAssignment | child= standardConstraint ) )* )
        {
             MATCHT(35, &FOLLOW_35_in_predicateStatements2836); 
            if  (HASEXCEPTION())
            {
                goto rulepredicateStatementsEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulepredicateStatementsEx;
                }


                // ../base/antlr/NDDL3Tree.g:477:9: ( (child= predicateParameter[tokenFactory] | child= predicateParameterAssignment | child= standardConstraint ) )*

                for (;;)
                {
                    int alt25=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA25_0 = LA(1);
                        if ( (LA25_0 == CONSTRAINT_INSTANTIATION || LA25_0 == VARIABLE || LA25_0 == 40) ) 
                        {
                            alt25=1;
                        }

                    }
                    switch (alt25) 
                    {
                	case 1:
                	    // ../base/antlr/NDDL3Tree.g:478:11: (child= predicateParameter[tokenFactory] | child= predicateParameterAssignment | child= standardConstraint )
                	    {

                	        // ../base/antlr/NDDL3Tree.g:478:11: (child= predicateParameter[tokenFactory] | child= predicateParameterAssignment | child= standardConstraint )
                	        {
                	            int alt24=3;
                	            switch ( LA(1) ) 
                	            {
                	            case VARIABLE:
                	            	{
                	            		alt24=1;
                	            	}
                	                break;
                	            case 40:
                	            	{
                	            		alt24=2;
                	            	}
                	                break;
                	            case CONSTRAINT_INSTANTIATION:
                	            	{
                	            		alt24=3;
                	            	}
                	                break;

                	            default:
                	                CONSTRUCTEX();
                	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                	                EXCEPTION->message      = (void *)"";
                	                EXCEPTION->decisionNum  = 24;
                	                EXCEPTION->state        = 0;


                	                goto rulepredicateStatementsEx;
                	            }

                	            switch (alt24) 
                	            {
                	        	case 1:
                	        	    // ../base/antlr/NDDL3Tree.g:478:13: child= predicateParameter[tokenFactory]
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_predicateParameter_in_predicateStatements2862);
                	        	        child=predicateParameter(ctx, tokenFactory);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulepredicateStatementsEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 2:
                	        	    // ../base/antlr/NDDL3Tree.g:479:27: child= predicateParameterAssignment
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_predicateParameterAssignment_in_predicateStatements2894);
                	        	        child=predicateParameterAssignment(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulepredicateStatementsEx;
                	        	        }


                	        	    }
                	        	    break;
                	        	case 3:
                	        	    // ../base/antlr/NDDL3Tree.g:480:6: child= standardConstraint
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_standardConstraint_in_predicateStatements2904);
                	        	        child=standardConstraint(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulepredicateStatementsEx;
                	        	        }


                	        	    }
                	        	    break;

                	            }
                	        }
                	        {

                	            			    tokenFactory->addBodyExpr(child);
                	            			
                	        }

                	    }
                	    break;

                	default:
                	    goto loop25;	/* break out of the loop */
                	    break;
                    }
                }
                loop25: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulepredicateStatementsEx;
                }

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepredicateStatementsEx; /* Prevent compiler warnings */
    rulepredicateStatementsEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end predicateStatements */

/** 
 * $ANTLR start predicateParameter
 * ../base/antlr/NDDL3Tree.g:490:1: predicateParameter[InterpretedTokenFactory* tokenFactory] returns [Expr* result] : child= variableDeclarations ;
 */
static Expr*
predicateParameter(pNDDL3Tree ctx, InterpretedTokenFactory* tokenFactory)
{   
    Expr* result = NULL;

    ExprList* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child ExprList*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:491:9: (child= variableDeclarations )
        // ../base/antlr/NDDL3Tree.g:492:9: child= variableDeclarations
        {
            FOLLOWPUSH(FOLLOW_variableDeclarations_in_predicateParameter2965);
            child=variableDeclarations(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepredicateParameterEx;
            }

            {
                 
                            const std::vector<Expr*>& vars=child->getChildren();
                            for (unsigned int i=0;i<vars.size();i++) {
                                ExprVarDeclaration* vd = dynamic_cast<ExprVarDeclaration*>(vars[i]);
                                tokenFactory->addArg(vd->getType(),vd->getName());
                            }
                            result = child;            
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepredicateParameterEx; /* Prevent compiler warnings */
    rulepredicateParameterEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end predicateParameter */

/** 
 * $ANTLR start predicateParameterAssignment
 * ../base/antlr/NDDL3Tree.g:503:1: predicateParameterAssignment returns [Expr* result] : child= assignment ;
 */
static Expr*
predicateParameterAssignment(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    ExprAssignment* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child ExprAssignment*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:504:9: (child= assignment )
        // ../base/antlr/NDDL3Tree.g:505:9: child= assignment
        {
            FOLLOWPUSH(FOLLOW_assignment_in_predicateParameterAssignment3022);
            child=assignment(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepredicateParameterAssignmentEx;
            }

            {
                 
                            result = child; 
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepredicateParameterAssignmentEx; /* Prevent compiler warnings */
    rulepredicateParameterAssignmentEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end predicateParameterAssignment */

/** 
 * $ANTLR start standardConstraint
 * ../base/antlr/NDDL3Tree.g:511:1: standardConstraint returns [Expr* result] : child= constraintInstantiation ;
 */
static Expr*
standardConstraint(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    ExprConstraint* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child ExprConstraint*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:512:9: (child= constraintInstantiation )
        // ../base/antlr/NDDL3Tree.g:513:9: child= constraintInstantiation
        {
            FOLLOWPUSH(FOLLOW_constraintInstantiation_in_standardConstraint3081);
            child=constraintInstantiation(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestandardConstraintEx;
            }

            {
                 
                            result = child; 
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestandardConstraintEx; /* Prevent compiler warnings */
    rulestandardConstraintEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end standardConstraint */

/** 
 * $ANTLR start rule
 * ../base/antlr/NDDL3Tree.g:519:1: rule returns [Expr* result] : ^( '::' className= IDENT predicateName= IDENT ruleBlock[ruleBody] ) ;
 */
static Expr*
rule(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    className;
    pANTLR3_BASE_TREE    predicateName;

    /* Initialize rule variables
     */



        std::vector<Expr*> ruleBody;

    className       = NULL;
    predicateName       = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:523:3: ( ^( '::' className= IDENT predicateName= IDENT ruleBlock[ruleBody] ) )
        // ../base/antlr/NDDL3Tree.g:523:5: ^( '::' className= IDENT predicateName= IDENT ruleBlock[ruleBody] )
        {
             MATCHT(48, &FOLLOW_48_in_rule3122); 
            if  (HASEXCEPTION())
            {
                goto ruleruleEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleruleEx;
            }

            className = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_rule3129); 
            if  (HASEXCEPTION())
            {
                goto ruleruleEx;
            }

            predicateName = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_rule3136); 
            if  (HASEXCEPTION())
            {
                goto ruleruleEx;
            }

            FOLLOWPUSH(FOLLOW_ruleBlock_in_rule3141);
            ruleBlock(ctx, ruleBody);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleruleEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleruleEx;
            }

            {

                		    std::string predName = std::string(c_str((className != NULL ? className->getText(className) : NULL)->chars)) + "." + std::string(c_str((predicateName != NULL ? predicateName->getText(predicateName) : NULL)->chars));
                		    std::string source=""; // TODO: get this from the antlr parser
                		    result = new ExprRuleTypeDefinition((new InterpretedRuleFactory(predName,source,ruleBody))->getId());
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleruleEx; /* Prevent compiler warnings */
    ruleruleEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end rule */

/** 
 * $ANTLR start ruleBlock
 * ../base/antlr/NDDL3Tree.g:535:1: ruleBlock[std::vector<Expr*>& ruleBody] : ^( '{' (child= ruleStatement )* ) ;
 */
static void
ruleBlock(pNDDL3Tree ctx, std::vector<Expr*>& ruleBody)
{   
    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:536:2: ( ^( '{' (child= ruleStatement )* ) )
        // ../base/antlr/NDDL3Tree.g:536:4: ^( '{' (child= ruleStatement )* )
        {
             MATCHT(35, &FOLLOW_35_in_ruleBlock3163); 
            if  (HASEXCEPTION())
            {
                goto ruleruleBlockEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleruleBlockEx;
                }


                // ../base/antlr/NDDL3Tree.g:537:4: (child= ruleStatement )*

                for (;;)
                {
                    int alt26=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA26_0 = LA(1);
                        if ( (LA26_0 == CONSTRAINT_INSTANTIATION || ((LA26_0 >= TOKEN_RELATION) && (LA26_0 <= VARIABLE)) || LA26_0 == 40 || LA26_0 == 53 || LA26_0 == 55) ) 
                        {
                            alt26=1;
                        }

                    }
                    switch (alt26) 
                    {
                	case 1:
                	    // ../base/antlr/NDDL3Tree.g:537:5: child= ruleStatement
                	    {
                	        FOLLOWPUSH(FOLLOW_ruleStatement_in_ruleBlock3171);
                	        child=ruleStatement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleruleBlockEx;
                	        }

                	        {
                	             ruleBody.push_back(child); 
                	        }

                	    }
                	    break;

                	default:
                	    goto loop26;	/* break out of the loop */
                	    break;
                    }
                }
                loop26: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleruleBlockEx;
                }

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleruleBlockEx; /* Prevent compiler warnings */
    ruleruleBlockEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end ruleBlock */

/** 
 * $ANTLR start ruleStatement
 * ../base/antlr/NDDL3Tree.g:541:1: ruleStatement returns [Expr* result] : (child= constraintInstantiation | child= assignment | child= variableDeclarations | child= ifStatement | child= loopStatement | child= relation ) ;
 */
static Expr*
ruleStatement(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:542:2: ( (child= constraintInstantiation | child= assignment | child= variableDeclarations | child= ifStatement | child= loopStatement | child= relation ) )
        // ../base/antlr/NDDL3Tree.g:542:4: (child= constraintInstantiation | child= assignment | child= variableDeclarations | child= ifStatement | child= loopStatement | child= relation )
        {

            // ../base/antlr/NDDL3Tree.g:542:4: (child= constraintInstantiation | child= assignment | child= variableDeclarations | child= ifStatement | child= loopStatement | child= relation )
            {
                int alt27=6;
                switch ( LA(1) ) 
                {
                case CONSTRAINT_INSTANTIATION:
                	{
                		alt27=1;
                	}
                    break;
                case 40:
                	{
                		alt27=2;
                	}
                    break;
                case VARIABLE:
                	{
                		alt27=3;
                	}
                    break;
                case 53:
                	{
                		alt27=4;
                	}
                    break;
                case 55:
                	{
                		alt27=5;
                	}
                    break;
                case TOKEN_RELATION:
                	{
                		alt27=6;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 27;
                    EXCEPTION->state        = 0;


                    goto ruleruleStatementEx;
                }

                switch (alt27) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:542:6: child= constraintInstantiation
            	    {
            	        FOLLOWPUSH(FOLLOW_constraintInstantiation_in_ruleStatement3198);
            	        child=constraintInstantiation(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleStatementEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // ../base/antlr/NDDL3Tree.g:543:6: child= assignment
            	    {
            	        FOLLOWPUSH(FOLLOW_assignment_in_ruleStatement3207);
            	        child=assignment(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleStatementEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // ../base/antlr/NDDL3Tree.g:544:6: child= variableDeclarations
            	    {
            	        FOLLOWPUSH(FOLLOW_variableDeclarations_in_ruleStatement3216);
            	        child=variableDeclarations(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleStatementEx;
            	        }


            	    }
            	    break;
            	case 4:
            	    // ../base/antlr/NDDL3Tree.g:545:6: child= ifStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_ifStatement_in_ruleStatement3225);
            	        child=ifStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleStatementEx;
            	        }


            	    }
            	    break;
            	case 5:
            	    // ../base/antlr/NDDL3Tree.g:546:6: child= loopStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_loopStatement_in_ruleStatement3234);
            	        child=loopStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleStatementEx;
            	        }


            	    }
            	    break;
            	case 6:
            	    // ../base/antlr/NDDL3Tree.g:547:10: child= relation
            	    {
            	        FOLLOWPUSH(FOLLOW_relation_in_ruleStatement3247);
            	        child=relation(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleStatementEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                	      result = child;
                	  
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleruleStatementEx; /* Prevent compiler warnings */
    ruleruleStatementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end ruleStatement */

/** 
 * $ANTLR start ifStatement
 * ../base/antlr/NDDL3Tree.g:555:1: ifStatement returns [Expr* result] : ^( 'if' guard= guardExpression ruleBlock[ifBody] ( ruleBlock[elseBody] )? ) ;
 */
static Expr*
ifStatement(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    ExprIfGuard* guard;
    #undef	RETURN_TYPE_guard
    #define	RETURN_TYPE_guard ExprIfGuard*

    /* Initialize rule variables
     */



    std::vector<Expr*> ifBody;
    std::vector<Expr*> elseBody;

    guard = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:560:2: ( ^( 'if' guard= guardExpression ruleBlock[ifBody] ( ruleBlock[elseBody] )? ) )
        // ../base/antlr/NDDL3Tree.g:560:4: ^( 'if' guard= guardExpression ruleBlock[ifBody] ( ruleBlock[elseBody] )? )
        {
             MATCHT(53, &FOLLOW_53_in_ifStatement3279); 
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }

            FOLLOWPUSH(FOLLOW_guardExpression_in_ifStatement3286);
            guard=guardExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }

            FOLLOWPUSH(FOLLOW_ruleBlock_in_ifStatement3291);
            ruleBlock(ctx, ifBody);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            // ../base/antlr/NDDL3Tree.g:563:4: ( ruleBlock[elseBody] )?
            {
                int alt28=2;
                {
                    int LA28_0 = LA(1);
                    if ( (LA28_0 == 35) ) 
                    {
                        alt28=1;
                    }
                }
                switch (alt28) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:563:4: ruleBlock[elseBody]
            	    {
            	        FOLLOWPUSH(FOLLOW_ruleBlock_in_ifStatement3297);
            	        ruleBlock(ctx, elseBody);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }

            {

                		    result = new ExprIf(guard,ifBody,elseBody);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleifStatementEx; /* Prevent compiler warnings */
    ruleifStatementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end ifStatement */

/** 
 * $ANTLR start guardExpression
 * ../base/antlr/NDDL3Tree.g:570:1: guardExpression returns [ExprIfGuard* result] : ( ^(relop= guardRelop lhs= anyValue rhs= anyValue ) | lhs= anyValue ) ;
 */
static ExprIfGuard*
guardExpression(pNDDL3Tree ctx)
{   
    ExprIfGuard* result = NULL;

    NDDL3Tree_guardRelop_return relop;
    #undef	RETURN_TYPE_relop
    #define	RETURN_TYPE_relop NDDL3Tree_guardRelop_return

    Expr* lhs;
    #undef	RETURN_TYPE_lhs
    #define	RETURN_TYPE_lhs Expr*

    Expr* rhs;
    #undef	RETURN_TYPE_rhs
    #define	RETURN_TYPE_rhs Expr*

    /* Initialize rule variables
     */



        const char* relopStr = "==";


    lhs = NULL;
    rhs = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:575:9: ( ( ^(relop= guardRelop lhs= anyValue rhs= anyValue ) | lhs= anyValue ) )
        // ../base/antlr/NDDL3Tree.g:575:11: ( ^(relop= guardRelop lhs= anyValue rhs= anyValue ) | lhs= anyValue )
        {

            // ../base/antlr/NDDL3Tree.g:575:11: ( ^(relop= guardRelop lhs= anyValue rhs= anyValue ) | lhs= anyValue )
            {
                int alt29=2;

                {
                    int LA29_0 = LA(1);
                    if ( (((LA29_0 >= 56) && (LA29_0 <= 57))) ) 
                    {
                        alt29=1;
                    }
                    else if ( (((LA29_0 >= IDENT) && (LA29_0 <= FLOAT)) || LA29_0 == 32 || LA29_0 == 35 || ((LA29_0 >= 82) && (LA29_0 <= 85))) ) 
                    {
                        alt29=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 29;
                        EXCEPTION->state        = 0;


                        goto ruleguardExpressionEx;
                    }
                }
                switch (alt29) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:575:13: ^(relop= guardRelop lhs= anyValue rhs= anyValue )
            	    {
            	        FOLLOWPUSH(FOLLOW_guardRelop_in_guardExpression3340);
            	        relop=guardRelop(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }


            	        {
            	            relopStr=c_str((relop.start != NULL ? STRSTREAM->toStringSS(STRSTREAM, relop.start, relop.start) : NULL )->chars);
            	        }

            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_anyValue_in_guardExpression3346);
            	        lhs=anyValue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_anyValue_in_guardExpression3350);
            	        rhs=anyValue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // ../base/antlr/NDDL3Tree.g:576:13: lhs= anyValue
            	    {
            	        FOLLOWPUSH(FOLLOW_anyValue_in_guardExpression3368);
            	        lhs=anyValue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleguardExpressionEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                              result = new ExprIfGuard(relopStr,lhs,rhs);
                          
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleguardExpressionEx; /* Prevent compiler warnings */
    ruleguardExpressionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end guardExpression */

/** 
 * $ANTLR start guardRelop
 * ../base/antlr/NDDL3Tree.g:583:1: guardRelop : ( '==' | '!=' );
 */
static NDDL3Tree_guardRelop_return
guardRelop(pNDDL3Tree ctx)
{   
    NDDL3Tree_guardRelop_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1);

    {
        // ../base/antlr/NDDL3Tree.g:584:5: ( '==' | '!=' )
        // ../base/antlr/NDDL3Tree.g:
        {
            if ( ((LA(1) >= 56) && (LA(1) <= 57)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_guardRelop0);    goto ruleguardRelopEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleguardRelopEx; /* Prevent compiler warnings */
    ruleguardRelopEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end guardRelop */

/** 
 * $ANTLR start loopStatement
 * ../base/antlr/NDDL3Tree.g:587:1: loopStatement returns [Expr* result] : ^( 'foreach' name= IDENT val= qualified ruleBlock[loopBody] ) ;
 */
static Expr*
loopStatement(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    name;
    Expr* val;
    #undef	RETURN_TYPE_val
    #define	RETURN_TYPE_val Expr*

    /* Initialize rule variables
     */



    std::vector<Expr*> loopBody;

    name       = NULL;
    val = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:591:2: ( ^( 'foreach' name= IDENT val= qualified ruleBlock[loopBody] ) )
        // ../base/antlr/NDDL3Tree.g:591:4: ^( 'foreach' name= IDENT val= qualified ruleBlock[loopBody] )
        {
             MATCHT(55, &FOLLOW_55_in_loopStatement3438); 
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_loopStatement3445); 
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }

            FOLLOWPUSH(FOLLOW_qualified_in_loopStatement3452);
            val=qualified(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }

            FOLLOWPUSH(FOLLOW_ruleBlock_in_loopStatement3458);
            ruleBlock(ctx, loopBody);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleloopStatementEx;
            }

            {

                		    result = new ExprLoop(c_str((name != NULL ? name->getText(name) : NULL)->chars),val->toString().c_str(),loopBody); // TODO : modify ExprLoop to pass val Expr instead
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleloopStatementEx; /* Prevent compiler warnings */
    ruleloopStatementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end loopStatement */

/** 
 * $ANTLR start problemStmt
 * ../base/antlr/NDDL3Tree.g:601:1: problemStmt returns [Expr* result] : ^(t= problemStmtType predicateInstanceList[tokens] ) ;
 */
static Expr*
problemStmt(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    NDDL3Tree_problemStmtType_return t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t NDDL3Tree_problemStmtType_return

    /* Initialize rule variables
     */



        std::vector<PredicateInstanceRef*> tokens;    

    {
        // ../base/antlr/NDDL3Tree.g:606:9: ( ^(t= problemStmtType predicateInstanceList[tokens] ) )
        // ../base/antlr/NDDL3Tree.g:606:17: ^(t= problemStmtType predicateInstanceList[tokens] )
        {
            FOLLOWPUSH(FOLLOW_problemStmtType_in_problemStmt3505);
            t=problemStmtType(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproblemStmtEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleproblemStmtEx;
            }

            FOLLOWPUSH(FOLLOW_predicateInstanceList_in_problemStmt3507);
            predicateInstanceList(ctx, tokens);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproblemStmtEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleproblemStmtEx;
            }

            {

                                    result = new ExprProblemStmt(c_str((t.start != NULL ? STRSTREAM->toStringSS(STRSTREAM, t.start, t.start) : NULL )->chars),tokens);
                                
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleproblemStmtEx; /* Prevent compiler warnings */
    ruleproblemStmtEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end problemStmt */

/** 
 * $ANTLR start problemStmtType
 * ../base/antlr/NDDL3Tree.g:612:1: problemStmtType : ( 'goal' | 'rejectable' | 'fact' );
 */
static NDDL3Tree_problemStmtType_return
problemStmtType(pNDDL3Tree ctx)
{   
    NDDL3Tree_problemStmtType_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1);

    {
        // ../base/antlr/NDDL3Tree.g:613:9: ( 'goal' | 'rejectable' | 'fact' )
        // ../base/antlr/NDDL3Tree.g:
        {
            if ( ((LA(1) >= 49) && (LA(1) <= 51)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_problemStmtType0);    goto ruleproblemStmtTypeEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleproblemStmtTypeEx; /* Prevent compiler warnings */
    ruleproblemStmtTypeEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end problemStmtType */

/** 
 * $ANTLR start relation
 * ../base/antlr/NDDL3Tree.g:618:1: relation returns [Expr* result] : ^( TOKEN_RELATION (i= IDENT )? tr= temporalRelation predicateInstanceList[targets] ) ;
 */
static Expr*
relation(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    i;
    NDDL3Tree_temporalRelation_return tr;
    #undef	RETURN_TYPE_tr
    #define	RETURN_TYPE_tr NDDL3Tree_temporalRelation_return

    /* Initialize rule variables
     */



        const char* relationType=NULL;
        PredicateInstanceRef* source=NULL;
        std::vector<PredicateInstanceRef*> targets;    

    i       = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:624:2: ( ^( TOKEN_RELATION (i= IDENT )? tr= temporalRelation predicateInstanceList[targets] ) )
        // ../base/antlr/NDDL3Tree.g:624:4: ^( TOKEN_RELATION (i= IDENT )? tr= temporalRelation predicateInstanceList[targets] )
        {
             MATCHT(TOKEN_RELATION, &FOLLOW_TOKEN_RELATION_in_relation3642); 
            if  (HASEXCEPTION())
            {
                goto rulerelationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerelationEx;
            }


            // ../base/antlr/NDDL3Tree.g:625:4: (i= IDENT )?
            {
                int alt30=2;
                {
                    int LA30_0 = LA(1);
                    if ( (LA30_0 == IDENT) ) 
                    {
                        alt30=1;
                    }
                }
                switch (alt30) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:625:5: i= IDENT
            	    {
            	        i = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_relation3650); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerelationEx;
            	        }

            	        {
            	             source = new PredicateInstanceRef(NULL,c_str((i != NULL ? i->getText(i) : NULL)->chars)); 
            	        }

            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_temporalRelation_in_relation3661);
            tr=temporalRelation(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerelationEx;
            }

            {
                 relationType = c_str((tr.start != NULL ? STRSTREAM->toStringSS(STRSTREAM, tr.start, tr.start) : NULL )->chars); 
            }
            FOLLOWPUSH(FOLLOW_predicateInstanceList_in_relation3669);
            predicateInstanceList(ctx, targets);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerelationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerelationEx;
            }

            {

                		    result = new ExprRelation(relationType,source,targets);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerelationEx; /* Prevent compiler warnings */
    rulerelationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end relation */

/** 
 * $ANTLR start predicateInstanceList
 * ../base/antlr/NDDL3Tree.g:634:1: predicateInstanceList[std::vector<PredicateInstanceRef*>& instances] : ( ^( '(' (child= predicateInstance )* ) | i= IDENT );
 */
static void
predicateInstanceList(pNDDL3Tree ctx, std::vector<PredicateInstanceRef*>& instances)
{   
    pANTLR3_BASE_TREE    i;
    PredicateInstanceRef* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child PredicateInstanceRef*

    /* Initialize rule variables
     */


    i       = NULL;
    child = NULL;

    {
        {
            //  ../base/antlr/NDDL3Tree.g:635:2: ( ^( '(' (child= predicateInstance )* ) | i= IDENT )
            
            ANTLR3_UINT32 alt32;

            alt32=2;


            {
                int LA32_0 = LA(1);
                if ( (LA32_0 == 38) ) 
                {
                    alt32=1;
                }
                else if ( (LA32_0 == IDENT) ) 
                {
                    alt32=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 32;
                    EXCEPTION->state        = 0;


                    goto rulepredicateInstanceListEx;
                }
            }
            switch (alt32) 
            {
        	case 1:
        	    // ../base/antlr/NDDL3Tree.g:635:4: ^( '(' (child= predicateInstance )* )
        	    {
        	         MATCHT(38, &FOLLOW_38_in_predicateInstanceList3691); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepredicateInstanceListEx;
        	        }


        	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulepredicateInstanceListEx;
        	            }


        	            // ../base/antlr/NDDL3Tree.g:636:4: (child= predicateInstance )*

        	            for (;;)
        	            {
        	                int alt31=2;
        	                {
        	                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                    */
        	                    int LA31_0 = LA(1);
        	                    if ( (LA31_0 == IDENT || ((LA31_0 >= 42) && (LA31_0 <= 43))) ) 
        	                    {
        	                        alt31=1;
        	                    }

        	                }
        	                switch (alt31) 
        	                {
        	            	case 1:
        	            	    // ../base/antlr/NDDL3Tree.g:636:5: child= predicateInstance
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_predicateInstance_in_predicateInstanceList3699);
        	            	        child=predicateInstance(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulepredicateInstanceListEx;
        	            	        }

        	            	        {
        	            	             instances.push_back(child); 
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop31;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop31: ; /* Jump out to here if this rule does not match */


        	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulepredicateInstanceListEx;
        	            }

        	        }

        	    }
        	    break;
        	case 2:
        	    // ../base/antlr/NDDL3Tree.g:638:5: i= IDENT
        	    {
        	        i = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_predicateInstanceList3715); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepredicateInstanceListEx;
        	        }

        	        {
        	             instances.push_back(new PredicateInstanceRef(NULL,c_str((i != NULL ? i->getText(i) : NULL)->chars))); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulepredicateInstanceListEx; /* Prevent compiler warnings */
    rulepredicateInstanceListEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end predicateInstanceList */

/** 
 * $ANTLR start predicateInstance
 * ../base/antlr/NDDL3Tree.g:642:1: predicateInstance returns [PredicateInstanceRef* pi] : ^(qt= qualifiedToken (i= IDENT )? ) ;
 */
static PredicateInstanceRef*
predicateInstance(pNDDL3Tree ctx)
{   
    PredicateInstanceRef* pi = NULL;

    pANTLR3_BASE_TREE    i;
    Expr* qt;
    #undef	RETURN_TYPE_qt
    #define	RETURN_TYPE_qt Expr*

    /* Initialize rule variables
     */



        const char* name = NULL;

    i       = NULL;
    qt = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:646:2: ( ^(qt= qualifiedToken (i= IDENT )? ) )
        // ../base/antlr/NDDL3Tree.g:646:4: ^(qt= qualifiedToken (i= IDENT )? )
        {
            FOLLOWPUSH(FOLLOW_qualifiedToken_in_predicateInstance3752);
            qt=qualifiedToken(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepredicateInstanceEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulepredicateInstanceEx;
                }


                // ../base/antlr/NDDL3Tree.g:646:24: (i= IDENT )?
                {
                    int alt33=2;
                    {
                        int LA33_0 = LA(1);
                        if ( (LA33_0 == IDENT) ) 
                        {
                            alt33=1;
                        }
                    }
                    switch (alt33) 
                    {
                	case 1:
                	    // ../base/antlr/NDDL3Tree.g:646:25: i= IDENT
                	    {
                	        i = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_predicateInstance3757); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulepredicateInstanceEx;
                	        }

                	        {
                	             name = c_str((i != NULL ? i->getText(i) : NULL)->chars); 
                	        }

                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulepredicateInstanceEx;
                }

            }
            {

                	            pi = new PredicateInstanceRef(qt->toString().c_str(),name);
                	            delete qt;
                	        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepredicateInstanceEx; /* Prevent compiler warnings */
    rulepredicateInstanceEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return pi;
}
/* $ANTLR end predicateInstance */

/** 
 * $ANTLR start qualified
 * ../base/antlr/NDDL3Tree.g:653:1: qualified returns [Expr* result] : (name= identifier | ^( '.' name= identifier ( qualified )* ) ) ;
 */
static Expr*
qualified(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    NDDL3Tree_identifier_return name;
    #undef	RETURN_TYPE_name
    #define	RETURN_TYPE_name NDDL3Tree_identifier_return

    /* Initialize rule variables
     */



        std::string varName;

    {
        // ../base/antlr/NDDL3Tree.g:657:9: ( (name= identifier | ^( '.' name= identifier ( qualified )* ) ) )
        // ../base/antlr/NDDL3Tree.g:657:12: (name= identifier | ^( '.' name= identifier ( qualified )* ) )
        {

            // ../base/antlr/NDDL3Tree.g:657:12: (name= identifier | ^( '.' name= identifier ( qualified )* ) )
            {
                int alt35=2;

                {
                    int LA35_0 = LA(1);
                    if ( (LA35_0 == IDENT || LA35_0 == 42) ) 
                    {
                        alt35=1;
                    }
                    else if ( (LA35_0 == 43) ) 
                    {
                        alt35=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 35;
                        EXCEPTION->state        = 0;


                        goto rulequalifiedEx;
                    }
                }
                switch (alt35) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:657:19: name= identifier
            	    {
            	        FOLLOWPUSH(FOLLOW_identifier_in_qualified3811);
            	        name=identifier(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequalifiedEx;
            	        }

            	        {
            	             varName=c_str((name.start != NULL ? STRSTREAM->toStringSS(STRSTREAM, name.start, name.start) : NULL )->chars); 
            	        }

            	    }
            	    break;
            	case 2:
            	    // ../base/antlr/NDDL3Tree.g:658:20: ^( '.' name= identifier ( qualified )* )
            	    {
            	         MATCHT(43, &FOLLOW_43_in_qualified3852); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequalifiedEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequalifiedEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_identifier_in_qualified3856);
            	        name=identifier(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequalifiedEx;
            	        }

            	        {
            	             if (varName.length()>0) varName+="."; varName+=c_str((name.start != NULL ? STRSTREAM->toStringSS(STRSTREAM, name.start, name.start) : NULL )->chars); 
            	        }

            	        // ../base/antlr/NDDL3Tree.g:658:119: ( qualified )*

            	        for (;;)
            	        {
            	            int alt34=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA34_0 = LA(1);
            	                if ( (LA34_0 == IDENT || ((LA34_0 >= 42) && (LA34_0 <= 43))) ) 
            	                {
            	                    alt34=1;
            	                }

            	            }
            	            switch (alt34) 
            	            {
            	        	case 1:
            	        	    // ../base/antlr/NDDL3Tree.g:658:119: qualified
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_qualified_in_qualified3860);
            	        	        qualified(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulequalifiedEx;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop34;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop34: ; /* Jump out to here if this rule does not match */


            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequalifiedEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                               // TODO!!: do type checking at each "."
                               result = new ExprVarRef(varName.c_str());
                           
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulequalifiedEx; /* Prevent compiler warnings */
    rulequalifiedEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end qualified */

/** 
 * $ANTLR start qualifiedToken
 * ../base/antlr/NDDL3Tree.g:666:1: qualifiedToken returns [Expr* result] : e= qualified ;
 */
static Expr*
qualifiedToken(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Expr* e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e Expr*

    /* Initialize rule variables
     */


    e = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:667:9: (e= qualified )
        // ../base/antlr/NDDL3Tree.g:667:17: e= qualified
        {
            FOLLOWPUSH(FOLLOW_qualified_in_qualifiedToken3926);
            e=qualified(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulequalifiedTokenEx;
            }

            {

                                    // TODO: type checking !
                                    result = e;
                                
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulequalifiedTokenEx; /* Prevent compiler warnings */
    rulequalifiedTokenEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end qualifiedToken */

/** 
 * $ANTLR start temporalRelation
 * ../base/antlr/NDDL3Tree.g:674:1: temporalRelation : ( 'after' | 'any' | 'before' | 'contained_by' | 'contains' | 'contains_end' | 'contains_start' | 'ends' | 'ends_after' | 'ends_after_start' | 'ends_before' | 'ends_during' | 'equal' | 'equals' | 'meets' | 'met_by' | 'parallels' | 'paralleled_by' | 'starts' | 'starts_after' | 'starts_before' | 'starts_before_end' | 'starts_during' );
 */
static NDDL3Tree_temporalRelation_return
temporalRelation(pNDDL3Tree ctx)
{   
    NDDL3Tree_temporalRelation_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1);

    {
        // ../base/antlr/NDDL3Tree.g:675:9: ( 'after' | 'any' | 'before' | 'contained_by' | 'contains' | 'contains_end' | 'contains_start' | 'ends' | 'ends_after' | 'ends_after_start' | 'ends_before' | 'ends_during' | 'equal' | 'equals' | 'meets' | 'met_by' | 'parallels' | 'paralleled_by' | 'starts' | 'starts_after' | 'starts_before' | 'starts_before_end' | 'starts_during' )
        // ../base/antlr/NDDL3Tree.g:
        {
            if ( ((LA(1) >= 58) && (LA(1) <= 80)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_temporalRelation0);    goto ruletemporalRelationEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletemporalRelationEx; /* Prevent compiler warnings */
    ruletemporalRelationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end temporalRelation */

/** 
 * $ANTLR start methodInvocation
 * ../base/antlr/NDDL3Tree.g:700:1: methodInvocation returns [Expr* result] : (child= variableMethod | child= tokenMethod ) ;
 */
static Expr*
methodInvocation(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    Expr* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child Expr*

    /* Initialize rule variables
     */


    child = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:701:2: ( (child= variableMethod | child= tokenMethod ) )
        // ../base/antlr/NDDL3Tree.g:702:2: (child= variableMethod | child= tokenMethod )
        {

            // ../base/antlr/NDDL3Tree.g:702:2: (child= variableMethod | child= tokenMethod )
            {
                int alt36=2;

                {
                    int LA36_0 = LA(1);
                    if ( (((LA36_0 >= 86) && (LA36_0 <= 87)) || LA36_0 == 94) ) 
                    {
                        alt36=1;
                    }
                    else if ( (((LA36_0 >= 88) && (LA36_0 <= 93))) ) 
                    {
                        alt36=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 36;
                        EXCEPTION->state        = 0;


                        goto rulemethodInvocationEx;
                    }
                }
                switch (alt36) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:702:4: child= variableMethod
            	    {
            	        FOLLOWPUSH(FOLLOW_variableMethod_in_methodInvocation4408);
            	        child=variableMethod(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemethodInvocationEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // ../base/antlr/NDDL3Tree.g:703:17: child= tokenMethod
            	    {
            	        FOLLOWPUSH(FOLLOW_tokenMethod_in_methodInvocation4428);
            	        child=tokenMethod(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemethodInvocationEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                            result = child;
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemethodInvocationEx; /* Prevent compiler warnings */
    rulemethodInvocationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end methodInvocation */

/** 
 * $ANTLR start variableMethod
 * ../base/antlr/NDDL3Tree.g:710:1: variableMethod returns [Expr* result] : ^(op= variableOp v= qualified ( variableArgumentList[args] )? ) ;
 */
static Expr*
variableMethod(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    NDDL3Tree_variableOp_return op;
    #undef	RETURN_TYPE_op
    #define	RETURN_TYPE_op NDDL3Tree_variableOp_return

    Expr* v;
    #undef	RETURN_TYPE_v
    #define	RETURN_TYPE_v Expr*

    /* Initialize rule variables
     */



        std::vector<Expr*> args;


    v = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:714:9: ( ^(op= variableOp v= qualified ( variableArgumentList[args] )? ) )
        // ../base/antlr/NDDL3Tree.g:714:17: ^(op= variableOp v= qualified ( variableArgumentList[args] )? )
        {
            FOLLOWPUSH(FOLLOW_variableOp_in_variableMethod4484);
            op=variableOp(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevariableMethodEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulevariableMethodEx;
            }

            FOLLOWPUSH(FOLLOW_qualified_in_variableMethod4488);
            v=qualified(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevariableMethodEx;
            }


            // ../base/antlr/NDDL3Tree.g:714:45: ( variableArgumentList[args] )?
            {
                int alt37=2;
                {
                    int LA37_0 = LA(1);
                    if ( (LA37_0 == 38) ) 
                    {
                        alt37=1;
                    }
                }
                switch (alt37) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:714:45: variableArgumentList[args]
            	    {
            	        FOLLOWPUSH(FOLLOW_variableArgumentList_in_variableMethod4490);
            	        variableArgumentList(ctx, args);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableMethodEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulevariableMethodEx;
            }

            {

                                    // TODO!: close() can also apply to the database or to a class
                                    result = new ExprVariableMethod(c_str((op.start != NULL ? STRSTREAM->toStringSS(STRSTREAM, op.start, op.start) : NULL )->chars),v,args);
                                
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevariableMethodEx; /* Prevent compiler warnings */
    rulevariableMethodEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end variableMethod */

/** 
 * $ANTLR start variableOp
 * ../base/antlr/NDDL3Tree.g:721:1: variableOp : ( 'specify' | 'reset' | 'close' );
 */
static NDDL3Tree_variableOp_return
variableOp(pNDDL3Tree ctx)
{   
    NDDL3Tree_variableOp_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1);

    {
        // ../base/antlr/NDDL3Tree.g:722:9: ( 'specify' | 'reset' | 'close' )
        // ../base/antlr/NDDL3Tree.g:
        {
            if ( ((LA(1) >= 86) && (LA(1) <= 87)) || LA(1) == 94 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_variableOp0);    goto rulevariableOpEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevariableOpEx; /* Prevent compiler warnings */
    rulevariableOpEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end variableOp */

/** 
 * $ANTLR start tokenMethod
 * ../base/antlr/NDDL3Tree.g:727:1: tokenMethod returns [Expr* result] : ^(op= tokenOp tok= IDENT ( variableArgumentList[args] )? ) ;
 */
static Expr*
tokenMethod(pNDDL3Tree ctx)
{   
    Expr* result = NULL;

    pANTLR3_BASE_TREE    tok;
    NDDL3Tree_tokenOp_return op;
    #undef	RETURN_TYPE_op
    #define	RETURN_TYPE_op NDDL3Tree_tokenOp_return

    /* Initialize rule variables
     */



        std::vector<Expr*> args;

    tok       = NULL;

    {
        // ../base/antlr/NDDL3Tree.g:731:9: ( ^(op= tokenOp tok= IDENT ( variableArgumentList[args] )? ) )
        // ../base/antlr/NDDL3Tree.g:731:17: ^(op= tokenOp tok= IDENT ( variableArgumentList[args] )? )
        {
            FOLLOWPUSH(FOLLOW_tokenOp_in_tokenMethod4644);
            op=tokenOp(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletokenMethodEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletokenMethodEx;
            }

            tok = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_tokenMethod4648); 
            if  (HASEXCEPTION())
            {
                goto ruletokenMethodEx;
            }


            // ../base/antlr/NDDL3Tree.g:731:40: ( variableArgumentList[args] )?
            {
                int alt38=2;
                {
                    int LA38_0 = LA(1);
                    if ( (LA38_0 == 38) ) 
                    {
                        alt38=1;
                    }
                }
                switch (alt38) 
                {
            	case 1:
            	    // ../base/antlr/NDDL3Tree.g:731:40: variableArgumentList[args]
            	    {
            	        FOLLOWPUSH(FOLLOW_variableArgumentList_in_tokenMethod4650);
            	        variableArgumentList(ctx, args);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletokenMethodEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletokenMethodEx;
            }

            {

                                    result = new ExprTokenMethod(c_str((op.start != NULL ? STRSTREAM->toStringSS(STRSTREAM, op.start, op.start) : NULL )->chars),c_str((tok != NULL ? tok->getText(tok) : NULL)->chars),args); 
                                
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletokenMethodEx; /* Prevent compiler warnings */
    ruletokenMethodEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end tokenMethod */

/** 
 * $ANTLR start tokenOp
 * ../base/antlr/NDDL3Tree.g:737:1: tokenOp : ( 'activate' | 'merge' | 'reject' | 'cancel' | 'free' | 'constrain' );
 */
static NDDL3Tree_tokenOp_return
tokenOp(pNDDL3Tree ctx)
{   
    NDDL3Tree_tokenOp_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1);

    {
        // ../base/antlr/NDDL3Tree.g:738:9: ( 'activate' | 'merge' | 'reject' | 'cancel' | 'free' | 'constrain' )
        // ../base/antlr/NDDL3Tree.g:
        {
            if ( ((LA(1) >= 88) && (LA(1) <= 93)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_tokenOp0);    goto ruletokenOpEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletokenOpEx; /* Prevent compiler warnings */
    ruletokenOpEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end tokenOp */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
