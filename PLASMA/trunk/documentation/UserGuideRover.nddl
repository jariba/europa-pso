#include "../PLASMA/NDDL/core/Plasma.nddl"
#include "../PLASMA/NDDL/core/PlannerConfig.nddl"

/**
 * Locations with plane coordinates and labels.
 */

class Location {
 int x;
 int y;
 string label;

 Location(int _x, int _y){
  x = _x;
  y = _y;
  label = "anonymous";
 }

 Location(int _x, int _y, string _label){
  x = _x;
  y = _y;
  label = _label;
 }
}

/**
 * Valid links from place to place. Includes path traversal cost and
 * difficulty category
 */

enum Category {'low', 'low-medium', 'medium', 'medium-high', 'high'}

class Path {
 string name;
 Location from;
 Location to;
 float cost;
 Category level;

 Path(string _name, Location _from, Location _to, float _cost, Category _level){
  name = _name;
  from = _from;
  to = _to;
  cost = _cost;
  level = _level;
 }
}

/*
 * Instruments can be positioned on destinations which must be locations
 */

class Instrument {

 predicate Position {
  Location destination;
  int position_speed;
  eq(position_speed, duration);
 }

 predicate Positioned { }

}

/*
 * Stowable Instruments inherit all properties from Instruments and in
 * addition, can be stowed and unstowed.
 */

class Stowable_Instrument extends Instrument {
 int stow_speed;
 int unstow_speed;
 Stowable_Instrument(int _stow_spd, int _unstow_spd) {
  stow_speed = _stow_spd;
  unstow_speed = _unstow_spd;
 }
 predicate Stow { }
 predicate Unstow { }
 predicate Stowed { }
 predicate Unstowed { }
}

/*
 * Cameras inherit all properties from Instruments and in addition, can
 * shoot with or without filter.
 */
class Camera extends Instrument {
 predicate ShootRequest { 
  bool filtering;
  Location view;
  int length;
 } 
 predicate PlaceFilter { 
  Location view;
 }
 predicate Shoot { 
  Location view;
 }
}

/*
 * A battery is a consumable resource.
 */

class Battery extends Resource {
  Battery(float ic, float ll_min, float ll_max){
   super(ic, ll_min, ll_max, 0.0, 0.0, MINUS_INFINITY, MINUS_INFINITY);
  }
}

/*
 * A navigator denotes the location of the rover and where it is moving
 */

class Navigator
{
 predicate At{
  Location location;
 }

 predicate Going{
  Location from;
  Location to;
  neq(from, to);
 }
}

/*
 * A rover composes instruments, a navigator and a battery.
 */

class Rover {
// Commands commands; // High-level rover commands
 Navigator nav; // Handles position control and achievement
 Instrument antenna;
 Camera pancam;
 Stowable_Instrument rat;
 Battery battery;
 Rover(Battery r){
  nav = new Navigator();
  antenna = new Instrument();
  pancam = new Camera();
  rat = new Stowable_Instrument(10,15);
  battery = r;
 }
}

/// RULES

Instrument::Position{
 contained_by(Navigator.At at);
 eq(at.location, destination);
 Rover rovers;
 commonAncestor(at.object, this.object, rovers);

 starts(Battery.change tx);
 eq(tx.quantity, -20);
}

Stowable_Instrument::Unstow{
 eq(object.unstow_speed, duration);

 contained_by(Navigator.At at);
 Rover rovers;
 commonAncestor(at.object, this.object, rovers);

 meets(Unstowed a);
 met_by(Stowed b);

 starts(Battery.change tx);
 eq(tx.quantity, -20);
}

Stowable_Instrument::Stow{
 eq(object.stow_speed, duration);

 contained_by(Navigator.At at);
 Rover rovers;
 commonAncestor(at.object, this.object, rovers);

 meets(Stowed a);
 met_by(Position b);

 starts(Battery.change tx);
 eq(tx.quantity, -20);
}


Stowable_Instrument::Stowed {
 met_by(Stow a);
 meets(Unstow b);
}

Stowable_Instrument::Unstowed {
 met_by(Unstow a);
 meets(Position b);
}

Camera::ShootRequest {
 eq(length,duration);
 contained_by(Navigator.At atc);
 eq(atc.location, view);
 if (filtering == true) {
   meets(object.PlaceFilter s0);
   eq(s0.view,view);
 }
 if (filtering == false) {
   meets(object.Shoot s1);
   eq(s1.view,view);
 }
}

Camera::PlaceFilter {
 eq(duration,5);
 contained_by(Navigator.At atc);
 eq(atc.location, view);
 met_by(object.ShootRequest s0);
 eq(s0.view,view);
 meets(object.Shoot s1);
 eq(s1.view,view);
 starts(Battery.change tx);
 eq(tx.quantity, -20);
}

Camera::Shoot {
 contained_by(Navigator.At atc);
 eq(atc.location, view);
 meets(object.ShootRequest s0);
 eq(s0.view,view);
 starts(Battery.change tx);
 eq(tx.quantity, -100);
}

Navigator::At {
 met_by(object.Going go_before);
 eq(go_before.to, location);
 meets(object.Going go_after);
 eq(go_after.from, location);
}

Navigator::Going {
 met_by(object.At at_before);
 eq(at_before.location, from);
 meets(object.At at_after);
 eq(at_after.location, to);

 // Select a path from those available between the 2 points
 Path p : {
  eq(p.from, from);
  eq(p.to, to);
 };
 // Pull juice from the battery. Should be based on path length.
 starts(Battery.change tx);
 eq(tx.quantity, p.cost);
}
