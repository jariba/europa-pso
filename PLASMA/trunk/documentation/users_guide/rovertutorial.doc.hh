/** * @page rovertutorial Rover Tutorial *  * We introduced a simple EUROPA2 application based upon a planetary rover in the Quick Start Guide. We will revisit that is example in this tutorial and cover it in * much greater detail. You will be able to being writing your own EUROPA2 applications are reading this tutorial. We begin by recapping the purpose of the application. We * then step through the stages of creating a EUROPA2 application beginning with an analysis of the application to identify timelines and token types, moving through the * NDDL encoding and finally stepping through the planner's operation on the domain.  * * @section rovertutorialapplicatonbackground Overview of the Simple Planetary Rover Application * * NASA Mars Exploratory Rover mission is operatering two rovers on the surface of Mars. The rovers are moving to rocks of interst identified by scientists on earth * and then collecting a variety of scentific data. We are going to write the planning application for controlling a simplified version of these rovers.  * * The figure below shows NASA Ames' K9 rover that is used to experiment with advanced control concepts for future Mars rover missions. K9 is operating in a simulated * martion landscape (called Marscape) where it is to navigate to target rocks and collect data. The second picture shows K9 placing its sensor on a rock.  * * @image html k9-rover-overview-photo.jpg K9 Rover at NASA Ames' Marscape while controlled by a EUROPA2 planner * * @image html k9-sensor-on-rock-photo.jpg K9 Rover Placing a sensor at NASA Ames' Marscape  *  * @section rovertutorialdomainanalysis Application Domain Analysis * * Developing EUROPA2 applications is a design task that will requie judgement and multiple iterations. We will follow the steps in this tutorial that we have  * found useful in practice. The overally apprach is to gradually build up a domain description adding detail in a methodical order. This control complxity by allowing * us to focus only on well defined issues at a given instant.   * * The first stage is to draw a concept map of the entties in the application domain and their relationships. The figure below shows our diagram for the rover domain. We have * identified rocks and the paths between them as the key environment entities. The rover itself has been divided in subcomonenets. The navigator concept manages the  * location of the rover. The instrument concept will manage the instruments for sampling rocks and the commands concept looks after instrcturtions from the scientists that  * the rover will serve. Finally the battery concept is included to provide a place for manageing the power used by the other componenets of the rover. *  * @image html rover-application-concept-diagram.jpg Rover Application Concept Diagram *  * The next decision is to identify the entities that will become timelines and to specify the predicates that will be placed on them. The rover in our domain is the  * actor we will be planning for and will contain all the timelines. Analayzing the components of the rover produces the following breakdown of timelines and predicates.  * * @image html rover-tutorial-initial-timelines.jpg Initial Timelines and Predicates * * Working from the top of the figure downwards  * <ul> * <li>The navigator time line controls the rovers navigation between places. We have determined only two predicates for this timeline.  * The rover is <i>at</i> a location or it <i>going</i> between locations.  * <li> The instrument can be stowed away and can be in the state of being stowed or being unstowed. The insturment may also be placed on a target where it can then * take a sample * <li> The commands capture instructions from the scientist. The rover can be instructed to take a sample or to upload its data to the lander or directly to earth.  *</ul> * As noted earlier, identifying the timelines and predicates is an iterative process. It would not be unusal to find new timelines while identifying prediates or to  * discover that two timelines could be collapsed into one. Please iterate and be comfotable with experimentation. * * The next stage is to flesh out the properties of the predicates and the constraints between them. To lets begin by adding these elements to the figure above (we've  * ommited the proties of the instrument's predicates for claraity). We focus inital on just the transitions between predicates within a timeline not the constraintes * between predicates on different timelines.  * * @image html rover-tutorial-navigation-timeline.jpg Timelines and Predicates with Transitions between Predicates on each Timeline.  * * The meaning of the state transitions added to this figure are obvious. The next stage is to consider the constraints between predicates on different time lines.  * so far we have only used the notion state transitions to connect predicates. These map to the temporal relations of <i>meets</i> and <i>met by</i> and are sufficent * for a time lines where only one predicate instance can occur at any given moment. When we start to connect predicates between timelines we need to use the full range * of temporal relations as we begin to deal with concurrent states.  * * @image html rover-tutorial-timeline-interaction.jpg Iteractions Between Timelines. *  * We have only one interaction between timelines in this application. The <i>take sample</i> prediate requries that the navigation timeline be <i>at</i> the location  * throuhgout its lifetime. We are identifyingthe common sense  constraint that we have to be at and remain at a location in order to sample it.  * * We now have the main concepts in the application identified and categorized and we are ready to start encoding it in NDDL.  * * @section rovertutorialnddl NDDL Encoding *  * Our encoding of the Rover domain is availble in the <i>Examples/SimpleRover</i> directory. We will step through each line of that file and explain how it was derived * form our analysis above and the NDDL constructs that were used. * * The first two lines are the default include statements that we meet in the <i>HelloRover</i> tutorial. Please disregard them for now. The first intersting area  * is the encoding of the <i>location</i> class. This is an extention of the <i>rock</i> concept we identfied earlier and is more general. We will allow the rover * to be at locations which may or may not be rocks. The <i>location</i> class has three attibues. The <i>name</i> is a symbolic name for the location. The <i>x</i> and <i>y</i> * attributes are coordinates. We have decided to position all our locations on a Eclidean Plane. The second part of the class specifies the constructor. The consructor defines * how the attributes of a location are initalized when a new instance is created. We are simply providing a signature that allows us to create locations with the name * and coordinates specified. The constors job is simply to copy those inital values into the correct member variables.  * * <i> *  class Location { * string name; * int x; * int y; * * Location(string _name, int _x, int _y){ *  name = _name; *  x = _x; *  y = _y; * }  *} * </i> * * @section rovertutorialplanning Planning * * @section rovertuotrialsummary Summary */