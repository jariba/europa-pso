/** * @page rovertutorial Rover Tutorial *  * We introduced a simple EUROPA2 application based upon a planetary rover in the Quick Start Guide. We will revisit that is example in this tutorial and cover it in * much greater detail. You will be able to being writing your own EUROPA2 applications are reading this tutorial. We begin by recapping the purpose of the application. We * then step through the stages of creating a EUROPA2 application beginning with an analysis of the application to identify timelines and token types, moving through the * NDDL encoding and finally stepping through the planner's operation on the domain.  * * @section rovertutorialapplicatonbackground Overview of the Simple Planetary Rover Application * * NASA Mars Exploratory Rover mission is operating two rovers on the surface of Mars. The rovers are moving to rocks of interest identified by scientists on earth * and then collecting a variety of scientific data. We are going to write the planning application for controlling a simplified version of these rovers.  * * The figure below shows NASA Ames' K9 rover that is used to experiment with advanced control concepts for future Mars rover missions. K9 is operating in a simulated * martion landscape (called Marscape) where it is to navigate to target rocks and collect data. The second picture shows K9 placing its sensor on a rock.  * * @image html k9-rover-overview-photo.jpg K9 Rover at NASA Ames' Marscape while controlled by a EUROPA2 planner * * @image html k9-sensor-on-rock-photo.jpg K9 Rover Placing a sensor at NASA Ames' Marscape  *  * @section rovertutorialdomainanalysis Application Domain Analysis * * Developing EUROPA2 applications is a design task that will require judgment and multiple iterations. We will follow the steps in this tutorial that we have  * found useful in practice. The overall approach is to gradually build up a domain description adding detail in a methodical order. This control complexity by allowing * us to focus only on well defined issues at a given instant.   * * The first stage is to draw a concept map of the entities in the application domain and their relationships. The figure below shows our diagram for the rover domain. We have * identified rocks and the paths between them as the key environment entities. The rover itself has been divided in subcomponents. The navigator concept manages the  * location of the rover. The instrument concept will manage the instruments for sampling rocks and the commands concept looks after instructions from the scientists that  * the rover will serve. Finally the battery concept is included to provide a place for managing the power used by the other components of the rover. *  * @image html rover-application-concept-diagram.jpg Rover Application Concept Diagram *  * The next decision is to identify the entities that will become timelines and to specify the predicates that will be placed on them. The rover in our domain is the  * actor we will be planning for and will contain all the timelines. Analyzing the components of the rover produces the following breakdown of timelines and predicates.  * * @image html rover-tutorial-initial-timelines.jpg Initial Timelines and Predicates * * Working from the top of the figure downwards  * <ul> * <li>The navigator time line controls the rovers navigation between places. We have determined only two predicates for this timeline.  * The rover is <i>at</i> a location or it <i>going</i> between locations.  * <li> The instrument can be stowed away and can be in the state of being stowed or being unstowed. The instrument may also be placed on a target where it can then * take a sample * <li> The commands capture instructions from the scientist. The rover can be instructed to take a sample or to upload its data to the lander or directly to earth.  *</ul> * As noted earlier, identifying the timelines and predicates is an iterative process. It would not be unusual to find new timelines while identifying predicates or to  * discover that two timelines could be collapsed into one. Please iterate and be comfortable with experimentation. * * The next stage is to flesh out the properties of the predicates and the constraints between them. To lets begin by adding these elements to the figure above (we've  * omitted the properties of the instrument's predicates for clarity). We focus initial on just the transitions between predicates within a timeline not the constraints * between predicates on different timelines.  * * @image html rover-tutorial-navigation-timeline.jpg Timelines and Predicates with Transitions between Predicates on each Timeline.  * * The meaning of the state transitions added to this figure are obvious. The next stage is to consider the constraints between predicates on different time lines.  * so far we have only used the notion state transitions to connect predicates. These map to the temporal relations of <i>meets</i> and <i>met by</i> and are sufficient * for a time lines where only one predicate instance can occur at any given moment. When we start to connect predicates between timelines we need to use the full range * of temporal relations as we begin to deal with concurrent states.  * * @image html rover-tutorial-timeline-interaction.jpg Iterations Between Timelines. *  * We have only one interaction between timelines in this application. The <i>take sample</i> predicate requires that the navigation timeline be <i>at</i> the location  * throughout its lifetime. We are identifying the common sense  constraint that we have to be at and remain at a location in order to sample it.  * * We now have the main concepts in the application identified and categorized and we are ready to start encoding it in NDDL.  * * @section rovertutorialnddl NDDL Encoding *  * Our encoding of the Rover domain is available in the <i>Examples/SimpleRover</i> directory. We will step through each line of that file and explain how it was derived * form our analysis above and the NDDL constructs that were used. * * The first two lines are the default include statements that we meet in the <i>HelloRover</i> tutorial. Please disregard them for now. The first interesting area  * is the encoding of the <i>location</i> class. This is an extension of the <i>rock</i> concept we identified earlier and is more general. We will allow the rover * to be at locations which may or may not be rocks. The <i>location</i> class has three attributes. The <i>name</i> is a symbolic name for the location. The <i>x</i> and <i>y</i> * attributes are coordinates. We have decided to position all our locations on a Euclidean Plane. The second part of the class specifies the constructor. The constructor defines * how the attributes of a location are initialized when a new instance is created. We are simply providing a signature that allows us to create locations with the name * and coordinates specified. The constructor's job is simply to copy those initial values into the correct member variables.  * * <i> *  class Location { <br> * string name; <br> * int x; <br> * int y; <br> *  * Location(string _name, int _x, int _y){ <br> *  name = _name; <br> *  x = _x; <br> *  y = _y; <br> * }  <br> *} <br> * </i> * * The <i>Path</i> class follows a similar pattern to the <i>Location</i> class. Paths have a symbolic name and a * pair of locations that they connect. The <i>cost</i> parameter will be used to compute the amount of battery * power that will be consumed while traversing a path. The constructor's role is again just to take initial  * values for each of a <i>path's</i> attributes. * * <i> * class Path { <br> * string name; <br> * Location from; <br> * Location to; <br> * float cost; <br> * Path(string _name, Location _from, Location _to, float _cost){ <br> *  name = _name; <br> *  from = _from; <br> *   to = _to; <br> *   cost = _cost; <br> * } <br> *} <br> * </i> * * We next encode the <i>Battery</i> that will be used to power the rover. EUROPA2 provides a <i>Resource</i> class for modeling items like batteries and * fuel cells that have a numeric capacity that is produced and consumed during a plan. The <i>Battery</i> class specializes the general <i>Resource</i> class. * It takes four arguments. An initial capacity <i>ic</i>, a minimum charge level <i>ll_min</i> and a maximum charge level <i>ll_max</i>. The <i>Battery</i> * constructor delegates the creation of an instance to its parent or super class, the general <i>Resource</i> class.  * *<i> * class Battery extends Resource { <br> *  Battery(float ic, float ll_min, float ll_max){ <br> *   super(ic, ll_min, ll_max, 0.0, 0.0, MINUS_INFINITY, MINUS_INFINITY);  <br> *  } <br> *} <br> *</i> * * We now move on to encode the component of the rover. Lets begin with the rover's navigator. This class contains the two predicates we identified earlier. * The <i>At</i> predicate models the concept of the rover being at a particular location. The <i>Going</i> predicate models the concept of moving between * locations. The <i>neq</i> construct is a constraint that ensures the rover does not attempt to traverse a path that start and finishes in the same location.  * <i> * class Navigator <br> * {<br> *   predicate At{<br> *     Location location; <br> * } <br> * <br> * (predicate Going{<br> *  Location from; <br> *  Location to; <br> *  neq(from, to); <br> *  } <br> * } <br> * </i> *  * The next element encodes the detail of the <i>At</i> predicate. The first constraint is a <i>met_by</i> that specifies instances of this predicate will be * proceeded by an instance of the <i>Going</i> predicate. Will name that predecessor as <i>from</i>. We then post the constraint that the <i>from</i> predicates * <i>to</i> attribute is equal to the <i>location</i> attribute of this predicate. We are just saying that a preceding <i>Going</i> predicate must end at * the location of this <i>At</i>. The third constraint specifies that an <i>At</i> predicate will be followed by a <i>Going</i> predicate. That <i>from</i> * location of that succeeding <i>Going</i> predicate must be set this location.  * * <i> * Navigator::At{ <br> * met_by(object.Going from); <br> * eq(from.to, location); <br> * meets(object.Going to); <br> * eq(to.from, location); <br> * }</i> * * We next specify the details of the <i>Going</i> predicate. It first mirrors the <i>At</i> predicates constraints in ensuring that a <i>Going</i> * is always preceded and followed by a <i>At</i> predicate and that the <i>to</i> and <i>from</i> attributes are synchronized correctly. The <i>Path</i> * element models the constraint that <i>Going</i> predicate must pass along a path that connects to locations being traversed. Finally, the battery * components specifies that the change in battery level caused by a <i>Going</i> predicate is equal to the cost associated with the path selected.  * * <i> * Navigator::Going{ <br> * met_by(object.At _from); <br> * eq(_from.location, from); <br> * meets(object.At _to); <br> * eq(_to.location, to);  <br> * <br> * Path p : { <br> * eq(p.from, from); <br> * eq(p.to, to); <br> * }; <br> * <br> * starts(Battery.change tx); <br> * eq(tx.quantity, p.cost); <br> *} <br> * </i> * * @section rovertutorialplanning Planning * * @section rovertuotrialsummary Summary */