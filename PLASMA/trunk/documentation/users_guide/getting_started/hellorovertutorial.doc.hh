/** * @page hellorovertutorial A Simple Introductory Example - HelloWorld * * @section roverTutorialObjective Objective * * Programming textbooks traditionally start the reader with a simple program * that will print the message "Hello World" to the computer  * screen. We follow the spirit of that tradition in this tutorial by providing a very simple application of EUROPA2 that will  * produce a plan containing a number of "HelloWorld" steps. Keeping the application simple right now will allow you to focus  * on the what is required to build and execute EUROPA2 applications. By the time you have finished you will be comfortable with * the basic operation of EUROPA2 and ready to tackle a realistic sized application based on an interplanetary rover in the * next section. Please do not get frustrated with the simplicity of this particular application and just view it as a teaching aide.  *  * It will take approximately one hour to complete this tutorial. *  * @section roverTutorialCreateProject Creating your Own Project * * We have provided a script to generate the files you need for this tutorial. As you advance, you will also use this same script to * build the initial infrastructure you need for you own projects. Please just keep this future use in the back of your mind for now. * * Open up a command line shell in your environment and move to the directory where you installed EUROPA2 then enter the PLASMA directory *  and enter the following command: * <br><br><center><i> * makeproject HelloWorld * </i></center><br><br> * You will see the message "Creating directory: ./../HelloRover" followed by the trace of nine files being added to that directory. Change * directory to the newly created HelloRover directory. It will be in the directory above where you installed PLASMA. * * The directory contains nine files. We are going to step through each in turn and execute then execute the system on this simple applications. * * @section hellorovermodel HelloRover-model.nddl * * Open the HelloRover-model.nddl file in your preferred text editor. This is the application model file that describes the actions available in our * domain and the constraints between those actions. It is written in the domain description language used by EUROPA2 named the New Domain Description Language * (NDDL - hence the extention). The NDDL acronym is pronounced, "noodle".  * * Look at the first two lines in the file.  * <br><br><i> * #include "Plasma.nddl" <br> * #include "PlannerConfig.nddl" *</i><br> * * NDDL supports the modular structuring of a domain description into multiple files to permit reuse between applications and to manage complexity within an application. * The <i>#include</i> directive is used to include the contents of other NDDL files into the current file. In these case we are including from Plasma.nddl and * PlannerConfig.nddl. These files contain some default NDDL elements that we will use in this application. Please do not worry about the details of these files  * for the moment and just note that we have included some default definitions. * * NDDL takes an object-oriented approach to modeling application domains. The world is modeled as a set of interacting objects where each may have a number of * predicates. In this simple domain we have declared a single object called <i>YourObject</i>. * <br><br><i> * class YourObject { <br> * predicate helloWorld{} <br> * }<br> * </i><br> * Our <i>YourObject</i> class has a single predicate <i>helloWorld</i>. We have defined an object which corresponds to a timeline and a single predicate that can occur on that timeline. *  * The remainder of the file specifies the detail of the <i>helloWorld</i> predicate. *<br><br><i> * YourObject::helloWorld{ <br> * eq(duration, 10);<br> * meets (object.helloWorld);<br> * met_by(object.helloWorld);<br> * }<br> * </i><br> * The <i>eq</i> statement is an equals constraint that sets the duration property of the predicate to be 10 units. The <i>meets</i> constraint *  specifies that an instance of the helloWorld predicate must meet another <i>helloworld</i> predicate instance on the <i>YourObject</i> timeline.  * The <i>met_by</i> constraint specifies that an instance of this predicate must be met_by (or proceeded) by an instance of the <i>helloWorld</i>. * * We have defined a very simple domain that contains one timeline (<i>YourObject</i>) that can hold instances of one predicate (<i>helloWorld</i>).  * Each <i>helloWorld</i> predicate instance has a duration of 10 units and is preceded and followed by another instance of the same predicate. This is * the action physics of the domain described.  * * @section helloroverinitial-state HelloRover-initial-state.nddl *  * The initial state file is used to define the state of the world at the start of planning and the goals the planner is produce a plan to achieve. * The first statement is an include directive. The directive includes the model file we just defined in the previous section.  * *<i> * #include "helloworld-model.nddl * </i><br> * * The <i>PlannerConfig</i> statement initializes our planner. We are creating a new instance of the <i>PlannerConfig</i> object called * <i>plannerConfiguration</i>. The object is passed four arguments during its construction. The first two define the time at which the * planning horizon beings and ends. In this case the horizon begins at <i>0</i> and terminates at <i>100</i>. The next two arguments bound * the amount of effort we permit the planner to expand in looking for a solution. We allow it to take up to <i>500</i> search steps to a maximum * search depth of <i>inf</i> (infinity). We will define search steps and search step as we start running this application. For now, please just note * that we can bound the resources the planner can expend on solving a problem. *  * <i> * PlannerConfig plannerConfiguration = new PlannerConfig(0, 100, 500, +inf); * </i><br> *  * The next statement creates an instance of our <i>YourObject</i> object and we give that instance the name <i>object</i>. In contrast to the  * <i>PlannerConfiguration</i> statement above we do not pass any arguments to <i>object</i> * * <i> * YourObject object = new YourObject(); *</i><br> * * We now have an instance of our <i>YourObject</i> class. This is a timeline instance on which we can place predicate instances. The next line * closes the plan database. Closing makes the commitment that we will not create anymore objects (e.g. timelines and planner configurations). * * <i> * close(); *</i> *  * We are now ready to start specifying the state of our <i>YourObject</i> object instance at the start of planning. In a more complex application we * would also specify the desired state of the object instance when planning finishes. To keep things simple, we specify only the initial state in this * example.  * * <i> * goal(YourObject.helloWorld initialToken);<br> * initialToken.start.specify(0); * </i> * * We have specified a goal which is an instance of the <i>helloWorld</i> predicate and we have named it <i>initialToken</i>. <i>initialToken</i> is a token. We then specify the start time of this token to be <i>0</i>. *  * Lets take a moment to consider what we have defined. The first figure is an object instance diagram that shows the instances we have created together * with the relationships between those instances. We have a <i>plannerConfiguration</i> instance together with a <i>object</i> instance. The <i>object</i>  * instance is associated with a single token instance <i>initalToken</i> *  * @image html hello-rover-object-instances.jpg Object instance diagram of hello world setup. * * The figure below shows the timeline view that results from our initial state definition. We have a single timeline <i>object</i> with a single token * <i>initaltoken</i> which as been constrained to take 10 time steps and to start at timestep 0. * * @image html hello-rover-initial-state.jpg HelloWorld Initial State Diagram * * @section runninghellorover Running the Planner * We will continue cataloging the files in the HelloWorld project in a moment. First, lets start EUROPA2 planning on the model and initial state * files we have just examined. Enter the following command into your terminal within the HelloWold directory.  * <br><br><center><i> * jam HelloWorld * </i></center><br><br>  * Europa2 will report that the NDDL parser is processing the initial-state and model files followed by similar reports by the NDDL compiler * and semantic checker. Processing of the models will complete with the creation of two C++ files and the linking of the "helloworld-planner".  * These steps have translated the NDDL domain definition into C++ code and finally into an exectutable planner. The final stage of the process is  * the actual execution of the planner on the problem and is reported as follows. *  * <i> *  ExecuteTarget RUN_helloworld-planner_g_rt.helloworld-initial-state.xml.PlannerConfig.xml  * </i><br> * * If you immediately rerun the planner you will see only the <i>ExecuteTarget</i> line as the model needs to be compiled only once (until a change * to it is made).  *  * EUROPA2 has placed the plan generated to solve our problem in the following file. Please open it in your favorite text editor.  * <i><br> * *  RUN_helloworld-planner_g_rt.helloworld-initial-state.xml.PlannerConfig.xml.output * * </i><br> * The first section in the file reports on the object instances in our system. The first <i>PlannerConfig</i> object is the planner configuration that we set *  up in the initial state file. This section is just reporting back our settings.  *  * <br><i> *       PlannerConfig:plannerConfiguration************************* <br> *               Variables *************************<br> *                       plannerConfiguration.m_horizonStart=int:CLOSED[0, 0]<br> *                       plannerConfiguration.m_horizonEnd=int:CLOSED[100, 100]<br> *                       plannerConfiguration.m_maxPlannerSteps=int:CLOSED[500, 500]<br> *                       plannerConfiguration.m_maxPlannerDepth=int:CLOSED[+inf, +inf]<br> *               End Variables *********************<br> *       End PlannerConfig:plannerConfiguration*************************<br> * </i><br> *  * The second object reported is the <i>object</i> instance of our <i>YourObject</i> class. It reports ten tokens associated with this object. Lets look at the first. *  * <br><i> *	[ INT_INTERVAL:CLOSED[0, 0] ]<br> *				YourObject.helloWorld() <br> *				Key=17  Master=NONE <br> *					Merged Key=91 <br> *      [ INT_INTERVAL:CLOSED[10, 10] ] <br> * </i><br> * * The first token description begins and ends with a temporal interval specification. It states that this token can begin as early as time <i>0</i> and as late * as time <i>0</i> on the timeline. It can finish as early and as late as time <i>10</i> on our timeline. This makes sense if we thing back to our initial state. We  * added a <i>helloWorld</i> token to the time line as specified its start time to time <i>0</i>. We specified the duration of tokens of this type in the  * domain model file to be <i>10</i>. Ignore for the moment the <i>key</i>, <i>master</i>, and <i>merged</i> key attributes.  * * @image html hello-rover-final-plan.jpg HelloWorld Plan *  * As we look down the file we see nine more <i>helloWorld</i> tokens that occur in sequence, the end time of one is equal to the start time of the next token. Why  * has EUROPA2 produced a plan with ten <i>helloWorld</i> tokens arranged like this? Think back to our domain model and the compatibilities we specified on the  * <i>helloWorld</i> predicate. We specified that each predicate of this type must be proceeded and succeeded by another <i>helloWorld</i> predicate. Europa2 * has satisfied this compatibility by first inserting a <i>helloWorld</i> token next to the token in the initial state. This process was repeated until we hit the * end of the planning horizon, time 100. In the next section, we will trace the operation of the planner on this problem to watch this processing in action. * *   * Please disregard the <i>Merged Tokens</i> and <i>Inactive Tokens</i> areas in this file for the time being. * * @section hellorovertutorialtraceplanner Tracing the Planner (Debug.cfg) *   * We are holding off writing this section until we have solver in a completed state.  * @image html solver-main-control-loop.jpg Solver Main Control Loop (simplified) * * @section hellorovertutorialother Other Files * The directory contains the following files: * <ul> * <li>HelloRover-main.cc This file provides the C++ source code for setting up a default planner. See the solver manual for details. * <li>NDDL.cfg: configuration information for the nddl compiler. See the nddl manual for details. * <li>PlanWorks.cfg: configuration settings for the PlanWorks system. See the Planworks guide for details. * <li>PlannerConfig.xml: default planner configuration. See the solver manual for details. * </ul> * @section hellorovertutorialsummary Summary * You should now be familiar with how to build and run a simple application and the operation of the planner  * on that application and how to go about tracing that operation.  * The HelloWorld example with its <i>makeproject</i> script is also designed to sead the creation of your own projects * by automatically putting the initial infrastructure in place. * * The next section in this tutorial steps through a more sophisticated application based on an interplanetary rover that * operates autonomously gathering rock and other scientific samples and transmitting the information back to earth. */ 