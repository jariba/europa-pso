if ! $(CommonRules_INCLUDED) {
CommonRules_INCLUDED = TRUE ;

#
# Execute run-it : it : it-arg0 it-arg1 it-arg2 ;
#

rule Execute {
  local target = $(1) ;
  local executable = $(2) ;
  local arguments = $(3) ;

  local target_exec_arg ;
  if $(arguments) {
    target_exec_arg = $(executable).$(arguments:J=.) ;
  } else {
    target_exec_arg = $(executable:G=$(target)) ;
  }
  LocalDepends $(target) : $(target_exec_arg) ;
  ExecuteTarget $(target_exec_arg) : [ FAppendSuffix $(executable) : $(SUFEXE) ] : $(arguments) ;
}

rule ExecuteTarget {
  local exec_arg = $(1) ;
  local executable = $(2) ;
  local arguments = $(3) ;

  Depends $(exec_arg) : $(executable) ;
  SEARCH on $(executable) += $(SEARCH_SOURCE) ;
  ARGUMENTS on $(exec_arg) = $(arguments) ;
}

actions ExecuteTarget {
  cd `dirname $(2)`
  ./`basename $(2)` $(ARGUMENTS)
}

#
# utilities
#

# thx to Dag Asheim <dash@linpro.no> from jamming@perforce.com list
#
# Return a list consisting of a string split where a regexp matches
#
# Usage: list = [ Split regexp : string ] ;
rule FSplit
{
  local re = $(1) ;
  if $(re) = "\\" {
    re = "\\\\" ; # A hack: make it easier to split on $(SLASH)
  }
  local match = [ MATCH "^(.*)("$(re)")(.*)" : $(2) ] ;
  local last ;
  local element ;

  if $(match) && $(match[2]) != $(2) {
    for element in $(match) {
      last = $(element) ;
    }
    return [ FSplit $(1) : $(match[1]) ] $(last) ;
  } else {
    return $(2) ;
  }
}

#
# Jambase level extensions [thx to OpenBeOS for "local" rules]
#

# FIsPrefix a : b ;				return whether or not a is a prefix of b

rule FIsPrefix
{
	# FIsPrefix <a> : <b> ;
	# Returns true, if list <a> is a prefix (a proper one or equal) of
	# list <b>, an empty list otherwise.
	local a = $(1) ;
	local b = $(2) ;
	while $(a) && $(a[1]) = $(b[1]) {
		a = $(a[2-]) ;
		b = $(b[2-]) ;
	}

	if $(a) {
		return ;
	} else {
		return true ;
	}
}

# LocalClean target : deps ;	a conditional Clean

rule LocalClean
{
	# LocalClean <targets> : <deps> ;
	# Like Clean, but has only effect in a Jamfile in the
	# directory or any of its subdirectories where jam has been invoked.

	if [ FIsPrefix $(SUBDIR_UP) : $(SUBDIR_DOWN) ] {
		Clean $(1) : $(2) ;
	}
}

# LocalDepends target : deps ;	a conditional Depends

rule LocalDepends
{
	# LocalDepends <targets> : <deps> ;
	# Like Depends, but has only effect in a Jamfile in the
	# directory or any of its subdirectories where jam has been invoked.

	if [ FIsPrefix $(SUBDIR_UP) : $(SUBDIR_DOWN) ] {
		Depends $(1) : $(2) ;
	}
}

# 

rule LinkSharedLibraries
{
	# make library dependencies of target
    # set NEEDLIBS variable used by 'actions Main'

    local _t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;

    Depends $(_t) : $(>:S=$(SUFSHARE)) ;
    NEEDSHARES on $(_t) += $(>:S=$(SUFSHARE)) ;
}

#
# Jambase modifications 
#

# preserve the current directory after returning from included directory
rule SubInclude {
	# SubInclude TOP d1 ... ;
	#
	# Include a subdirectory's Jamfile.

	# We use SubDir to get there, in case the included Jamfile
	# either doesn't have its own SubDir (naughty) or is a subtree
	# with its own TOP.

	if ! $($(<[1]))
	{
	    Exit SubInclude $(<[1]) without prior SubDir $(<[1]) ;
	}

#	Echo SubIncludeIn . $(SUBDIR) ;
	{
		local $(<[1]) = $($(<[1])) ;
		local SUBDIR = $(SUBDIR) ;
		local SUBDIR_TOKENS = $(SUBDIR_TOKENS) ;
		local SEARCH_SOURCE = $(SEARCH_SOURCE) ;
		local LOCATE_SOURCE = $(LOCATE_SOURCE) ;
		local LOCATE_TARGET = $(LOCATE_TARGET) ;
		local SOURCE_GRIST = $(SOURCE_GRIST) ;
		local SUBDIR_UP = $(SUBDIR_UP) ;
		local SUBDIR_ROOT = $(SUBDIR_ROOT) ;
		local HDRGRIST = $(HDRGRIST) ;

		SubDir $(<) ;

#		Echo SubIncluding . $(SUBDIR) ;

		include $(JAMFILE:D=$(SUBDIR)) ;

	}
#	Echo SubIncludeOut . $(SUBDIR) ;
}

#
# "Local" versions
# 

rule File
{
	LocalDepends files : $(<) ;
	Depends $(<) : $(>) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
	MODE on $(<) = $(FILEMODE) ;
	Chmod $(<) ;
}

rule GenFile 
{
	local _t = [ FGristSourceFiles $(<) ] ;
	local _s = [ FAppendSuffix $(>[1]) : $(SUFEXE) ] ;
	Depends $(_t) : $(_s) $(>[2-]) ;
	GenFile1 $(_t) : $(_s) $(>[2-]) ;
	LocalClean clean : $(_t) ;
}

rule HardLink
{
	LocalDepends files : $(<) ;
	Depends $(<) : $(>) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

rule InstallInto
{
	# InstallInto dir : sources ;

	local i t ;

	t = $(>:G=$(INSTALLGRIST)) ;

	# Arrange for jam install
	# Arrange for jam uninstall
	# sources are in SEARCH_SOURCE
	# targets are in dir

	LocalDepends install : $(t) ;
	LocalClean uninstall : $(t) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
	MakeLocate $(t) : $(<) ;

	# For each source, make gristed target name
	# and Install, Chmod, Chown, and Chgrp

	for i in $(>)
	{
	    local tt = $(i:G=$(INSTALLGRIST)) ;

	    Depends $(tt) : $(i) ;
	    Install $(tt) : $(i) ;
	    Chmod $(tt) ;

	    if $(OWNER) && $(CHOWN) 
	    { 
		Chown $(tt) ;
		OWNER on $(tt) = $(OWNER) ;
	    }

	    if $(GROUP) && $(CHGRP) 
	    { 
		Chgrp $(tt) ;
		GROUP on $(tt) = $(GROUP) ;
	    }
	}
}

rule Lex
{
	LexMv $(<) : $(>) ;
	Depends $(<) : $(>) ;
	MakeLocate $(<) : $(LOCATE_SOURCE) ;
	LocalClean clean : $(<) ;
}

rule LibraryFromObjects
{
	local _i _l _s ;

	# Add grist to file names

	_s = [ FGristFiles $(>) ] ;
	_l = $(<:S=$(SUFLIB)) ;

	# library depends on its member objects

	if $(KEEPOBJS)
	{
	    LocalDepends obj : $(_s) ;
	}
	else
	{
	    LocalDepends lib : $(_l) ;
	}

	# Set LOCATE for the library and its contents.  The bound
	# value shows up as $(NEEDLIBS) on the Link actions.
	# For compatibility, we only do this if the library doesn't
	# already have a path.

	if ! $(_l:D)
	{
	    MakeLocate $(_l) $(_l)($(_s:BS)) : $(LOCATE_TARGET) ;
	}

	if $(NOARSCAN) 
	{ 
	    # If we can't scan the library to timestamp its contents,
	    # we have to just make the library depend directly on the
	    # on-disk object files.  

	    Depends $(_l) : $(_s) ;
	}
	else
	{
	    # If we can scan the library, we make the library depend
	    # on its members and each member depend on the on-disk
	    # object file.

	    Depends $(_l) : $(_l)($(_s:BS)) ;

	    for _i in $(_s)
	    {
		Depends $(_l)($(_i:BS)) : $(_i) ;
	    }
	}

	LocalClean clean : $(_l) ;

	if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }

	Archive $(_l) : $(_s) ;

	if $(RANLIB) { Ranlib $(_l) ; }

	# If we can't scan the library, we have to leave the .o's around.

	if ! ( $(NOARSCAN) || $(NOARUPDATE) ) { RmTemps $(_l) : $(_s) ; }
}

rule MainFromObjects
{
	local _s _t ;

	# Add grist to file names
	# Add suffix to exe

	_s = [ FGristFiles $(>) ] ;
	_t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;

	# so 'jam foo' works when it's really foo.exe

	if $(_t) != $(<)
	{
	    Depends $(<) : $(_t) ;
	    NotFile $(<) ;
	}

	# make compiled sources a dependency of target

	LocalDepends exe : $(_t) ;
	Depends $(_t) : $(_s) ;
	MakeLocate $(_t) : $(LOCATE_TARGET) ;

	LocalClean clean : $(_t) ;

	Link $(_t) : $(_s) ;
}

rule MkDir
{
	# MkDir directory ;

	# Make a directory and all its parent directories.

	# Ignore timestamps on directories: we only care if they 
	# exist.

	NoUpdate $(<) ;

	# Don't create . or any directory already created.

	if $(<:G=) != $(DOT) && ! $($(<)-mkdir) 
	{
	    # Cheesy gate to prevent multiple invocations on same dir
	    # Arrange for jam dirs
	    # MkDir1 has the actions 

	    $(<)-mkdir = true ;
	    LocalDepends dirs : $(<) ;
	    MkDir1 $(<) ;

	    # Recursively make parent directories.
	    # $(<:P) = $(<)'s parent, & we recurse until root

	    local s = $(<:P) ;

	    # Don't try to create A: or A:\ on windows

	    if $(NT)
	    {
	        switch $(s)
		{
		case *:   : s = ;
		case *:\\ : s = ;
		}
	    }

	    if $(s) = $(<)
	    {
		# The parent is the same as the dir.
		# We're at the root, which some OS's can't stat, so we mark
		# it as NotFile.

	        NotFile $(s) ;
	    }
	    else if $(s:G=)
	    {
		# There's a parent; recurse.

		Depends $(<) : $(s) ;
		MkDir $(s) ;
	    }
	}
}

rule Object
{
	# locate object and search for source, if wanted

	LocalClean clean : $(<) ;

	MakeLocate $(<) : $(LOCATE_TARGET) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	# Save HDRS for -I$(HDRS) on compile.
	# We shouldn't need -I$(SEARCH_SOURCE) as cc can find headers
	# in the .c file's directory, but generated .c files (from
	# yacc, lex, etc) are located in $(LOCATE_TARGET), possibly
	# different from $(SEARCH_SOURCE).

	HDRS on $(<) = $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ;

	# handle #includes for source: Jam scans for headers with
	# the regexp pattern $(HDRSCAN) and then invokes $(HDRRULE)
	# with the scanned file as the target and the found headers
	# as the sources.  HDRSEARCH is the value of SEARCH used for
	# the found header files.  Finally, if jam must deal with 
	# header files of the same name in different directories,
	# they can be distinguished with HDRGRIST.

	# $(SEARCH_SOURCE:E) is where cc first looks for #include 
	# "foo.h" files.  If the source file is in a distant directory, 
	# look there.  Else, look in "" (the current directory).

	HDRRULE on $(>) = HdrRule ;
	HDRSCAN on $(>) = $(HDRPATTERN) ;
	HDRSEARCH on $(>) = 
		$(SEARCH_SOURCE:E) $(SUBDIRHDRS) $(HDRS) $(STDHDRS) ;

	HDRGRIST on $(>) = $(HDRGRIST) ;

	# propagate target specific-defines

	DEFINES on $(<) += $(DEFINES) ;

	# if source is not .c, generate .c with specific rule

	switch $(>:S)
	{
	    case .asm : As $(<) : $(>) ;
	    case .c :	Cc $(<) : $(>) ;
	    case .C :	C++ $(<) : $(>) ;
	    case .cc :	C++ $(<) : $(>) ;
	    case .cpp : C++ $(<) : $(>) ;
	    case .f :	Fortran $(<) : $(>) ;
	    case .l :	Cc $(<) : $(<:S=.c) ;
			Lex $(<:S=.c) : $(>) ;
	    case .s :	As $(<) : $(>) ;
	    case .y :	Cc $(<) : $(<:S=$(YACCGEN)) ;
			Yacc $(<:S=$(YACCGEN)) : $(>) ;
	    case * :	UserObject $(<) : $(>) ;
	}
}

rule Objects
{
	local _i ;

	for _i in [ FGristFiles $(<) ]
	{
		Object $(_i:S=$(SUFOBJ)) : $(_i) ;
		LocalDepends obj : $(_i:S=$(SUFOBJ)) ;
	}
}

rule Shell
{
	LocalDepends shell : $(<) ;
	Depends $(<) : $(>) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
	MODE on $(<) = $(SHELLMODE) ;
	LocalClean clean : $(<) ;
	Chmod $(<) ;
}

rule SoftLink
{
	LocalDepends files : $(<) ;
	Depends $(<) : $(>) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
	LocalClean clean : $(<) ;
}

rule Yacc
{
	local _h ;

	_h = $(<:BS=.h) ;

	# Some places don't have a yacc.

	MakeLocate $(<) $(_h) : $(LOCATE_SOURCE) ;

	if $(YACC)
	{
	    Depends $(<) $(_h) : $(>) ;
	    Yacc1 $(<) $(_h) : $(>) ;
	    YaccMv $(<) $(_h) : $(>) ;
	    LocalClean clean : $(<) $(_h) ;
	}

	# make sure someone includes $(_h) else it will be
	# a deadly independent target

	Includes $(<) : $(_h) ;
}

} # CommonRules_INCLUDED
