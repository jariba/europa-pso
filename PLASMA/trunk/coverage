#!/usr/bin/perl -w

use File::Find;
use File::Copy;
use strict;

############################
####  Global Variables  ####
############################
my $analysis_file = "coverage-results.txt";
my $gcov_dir = "./gcov";
#they should all be relative paths, otherwise the script won't function
my @idirs = (".");
my $objdir = "obj_cov";
my %results;
my $gcovout;

#############################
########  ANSI Term  ########
#############################
sub red {return "\x1B[31m" . join("",@_) . "\x1B[0m";}
sub green {return "\x1B[32m" . join("",@_) . "\x1B[0m";}
sub yellow {return "\x1B[33m" . join("",@_) . "\x1B[0m";}
sub cyan {return "\x1B[36m" . join("",@_) . "\x1B[0m";}
sub bold {return "\x1B[37;1m" . join("",@_) . "\x1B[0m";}

#############################
####  Primary Functions  ####
#############################
sub gcov
{
	if(/.*\.(cc|hh)$/)
	{
		s/^\.\///;
		my $processing = $_;
		if($processing !~ /^.*\/.*\/.*\..*$/)
		{
			print yellow "Skipping $processing (tree location)\n";
			return;
		}
		my ($rootdir,$srcdir,$name) = $processing =~ /^(.*)\/(.*)\/(.*)\..*$/;
		if(-e "$rootdir/$objdir/$name.da")
		{
			print green "Processing $processing\n";
			my @output = `gcov -o $rootdir/$objdir $_ 2>/dev/null`;
			foreach (@output)
			{
				my ($perc, $lines, $file) = /(\d+\.\d+)% of (\d+) lines executed in file (.*)$/;
				if(defined $perc && defined $lines && defined $file && $file !~ /^\//)
				{
					$results{$file}->[0] = $lines;
					$results{$file}->[1]->{$processing} = $perc;
				}
			}
		}
		elsif(-e "$rootdir/$srcdir/$name.da")
		{
			#later the output will be gobbled up and spit into a file.
			print green "Processing $processing ($name.o misplaced, consider altering Jamfile)\n";
			my @output = `gcov -o $rootdir/$srcdir $_ 2>/dev/null`;
			foreach (@output)
			{
				my ($perc, $lines, $file) = /(\d+\.\d+)% of (\d+) lines executed in file (.*)$/;
				if(defined $perc && defined $lines && defined $file && $file !~ /^\//)
				{
					$results{$file}->[0] = $lines;
					$results{$file}->[1]->{$processing} = $perc;
				}
			}
		}
		elsif(-e "$rootdir/$objdir/$name.bb")
		{
			print yellow "Skipping $processing (for lack of $rootdir/$objdir/$name.da)\n";
		}
		elsif($processing =~ /documentation/)
		{
			print yellow "Skipping $processing (assumed to be documentation)\n";
		}
		elsif(!(-e "$rootdir/$srcdir/$name.cc"))
		{
			print yellow "Skipping $processing (for lack of $rootdir/$objdir/$name.cc)\n";
		}
		else
		{
			print red "Coverage incomplete: missing gcov data for $processing\n";
		}
	}
}

sub movefiles
{
	mkdir $gcov_dir;
	foreach (<*.gcov>)
	{
		open(my $file,$_) or die "$!: $_";
		if(<$file> !~ /0:Source:\//)
		{
			open(my $curr, $_) or die "$!: $_";
			my $missing = 0;
			my ($filename) = <$curr> =~ /.*:(.+)$/;
			foreach (<$curr>) {$missing+= 1 if (/^\s*#/);}
			$results{$filename}->[2] = $missing;
			close($curr);
			
			move($_,"$gcov_dir/$_");
		}
		else {unlink($_);}
		close($file);
	}
}

############################
#######  Core script #######
############################

print cyan "EUROPA code test case coverage analysis script - uses gcov\n";

# ensure required .xml files get built. Cheaper than adding dependancy information to System/test jamfile.
#system("jam -sVARIANTS=COVERAGE -sLIBRARIES=STATIC run-solvers-module-tests") and die red "Build failure";
# create gcov files
#system("jam -sVARIANTS=COVERAGE -sLIBRARIES=STATIC run-all-module-tests") and die red "Build failure";


print cyan "Generating gcov information for all possible files.\n";
find({wanted=>\&gcov, no_chdir=>1},@idirs);

print cyan "Moving *.gcov files to gcov directory.\n";
movefiles;
print cyan "Outputting formatted gcov data.\n";

open($gcovout,">$analysis_file") or die "$!: $analysis_file";
print $gcovout <<MOREINFO;
see $gcov_dir for files generated by gcov.

From the gcov manpage:
   One .gcov file is produced for each source file containing code, which was
compiled to produce the data files. The .gcov files contain the ':' separated
fields along with program source code. The format is

   <execution_count>:<line_number>:<source line text>

Additional block information may succeed each line, when requested by command
line option. The execution_count is - for lines containing no code and #####
for lines which were never executed. Some lines of information at the start
have line_number of zero.

Summary follows:
MOREINFO
;
my $sloc = 0;
my $missed = 0;
sub result_sort
{
	if (!defined $results{$a}->[2])
	{
		print red "Missing information about which lines weren't executed for '$a' assuming all weren't executed.\n";
		$results{$a}->[2] = $results{$a}->[0];
	}
	if (!defined $results{$b}->[2])
	{
		print red "Missing information about which lines weren't executed for '$b' assuming all weren't executed.\n";
		$results{$b}->[2] = $results{$b}->[0];
	}
	$results{$a}->[2] <=> $results{$b}->[2];
}
foreach my $file (sort result_sort keys %results)
{
	printf $gcovout "%5u/%5u lines not executed in: $file\n", ($results{$file}->[2], $results{$file}->[0]);
	$sloc += $results{$file}->[0];
	$missed += $results{$file}->[2];
}
print $gcovout "$missed of $sloc lines unexecuted.\n";
close($gcovout);

print bold "$missed of $sloc lines unexecuted.\n";
print cyan "Test case coverage analysis complete, see $analysis_file.\n";
