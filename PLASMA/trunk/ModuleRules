if ! $(ModuleRules_INCLUDED) {
ModuleRules_INCLUDED = TRUE ;

include [ FDirName $(SUBDIR) VariantRules ] ;

# TRACE_MODULE ?= TRUE ;

# LIBRARIES can be:
#   STATIC
#   SHARED

LIBRARIES ?= STATIC ;

# Module <name> : <modules this module depends on> ;
rule Module {
  local name = $(1) ;
  local modules = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo Module $(name) . $(modules) ;
  }

  local module = $(name:G=module) ;
  NotFile $(module) ;

  LINK_MODULES on $(module) = $(modules:G=module) ;
  LOCATE_OBJECTS on $(module) = [ FDirName $(SUBDIR) objects ] ;

  SubInclude PLASMA $(name) component ;
  SubInclude PLASMA $(name) core ;
  SubInclude PLASMA $(name) documentation ;
  SubInclude PLASMA $(name) test ;
}

# ModuleFiles <name> : <files for this module> ;
rule ModuleFiles {
  local name = $(1) ;
  local files = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModuleFiles $(name) . $(files) ;
  }

  local module = $(name:G=module) ;
  local LOCATE_TARGET = [ on $(module) return $(LOCATE_OBJECTS) ] ;
  ModulePart $(module) : $(files) ;
}

# ModuleCore <name> : <files for this module > ;
rule ModuleCore {
  ModuleFiles $(1) : $(2) ;
}

# ModuleComponent <name> : <files for this module > ;
rule ModuleComponent {
  ModuleFiles $(1) : $(2) ;
}

rule ModuleDocumentation {
  local name = $(1) ;
  local files = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModuleDocumentation $(name) . $(files) ;
  }
}

# ModuleTest <name> : <files for this test> : <modules that this test depends on> ;
rule ModuleTest {
  local name = $(1) ;
  local files = $(2) ;
  local modules = (3) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModuleTest $(name) . $(files) . $(modules) ;
  }

  local links = [ FLinkModules $(module) ] ;

  local link ;
  for link in $(links) {
    switch $(link) {
    case *.core :
      SubDirHdrs [ FDirName $(PLASMA) $(link:S=) core ] ;
    case * :
      SubDirHdrs [ FDirName $(PLASMA) $(link) core ] ;
      SubDirHdrs [ FDirName $(PLASMA) $(link) component ] ;
    }
  }

  local variant ;
  for variant in $(VARIANTS) {
    local C++FLAGS = $(C++FLAGS) [ FVariantC++Flags $(variant) ] ;
    local CFLAGS = $(CFLAGS) [ FVariantCFlags $(variant) ] ;
    local LINKFLAGS = $(LINKFLAGS) [ FVariantLinkFlags $(variant) ] ;

    local exe = [ FVariantName $(name) : $(variant) ] ;

    local outputs ;
    local file ;
    for file in $(files) {
      file = [ FGristFiles $(file) ] ;
      SEARCH on $(file) = $(SEARCH_SOURCE) ;

      local output = [ FVariantName $(file) : $(variant) ] ;
      output = $(output:S=$(SUFOBJ)) ;
      outputs += $(output) ;
      Object [ FGristFiles $(output) ] : $(file) ;
    }

    for library in $(LIBRARIES) {
      local flags ;
      if $(library) = SHARED {
        for link in $(links) {
          LinkSharedLibraries $(exe) : [ FModuleSharedLibraryName $(link:S=) : $(variant) ] ;
        }
        MainFromObjects $(exe)_rt : $(outputs) ;
      } else if $(library) = STATIC {
        for link in $(links) {
          LinkLibraries $(exe) : [ FModuleStaticLibraryName $(link:S=) : $(variant) ] ;
        }
        MainFromObjects $(exe) : $(outputs) ;
      } else {
        Exit ModuleTest unknown library type: $(library) ;
      }
    }
  }
}

################
# internal rules

rule FLinkModules {
  local module = $(1) ;

  if $(TRACE_MODULE) = TRUE {
    Echo FLinkModules $(module) ;
  }

  local modules = $(module:G=) ;
  local found ;
  while $(modules) {
    local mod = $(modules[1]) ;
    if ! $(mod) in $(found) {
      if $(TRACE_MODULE) = TRUE {
        Echo - $(mod) ;
      }
      found += $(mod) ;
      mod = $(mod:S=) ;
      mod = $(mod:G=module) ;
      modules += [ on $(mod) return $(LINK_MODULES:G=) ] ;
    }
    modules = $(modules[2-]) ;
  }

  return $(found) ;
}

rule ModulePart {
  local module = $(1) ;
  local files = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModulePart $(module) . $(files) ;
  }

  local link ;
  for link in [ FLinkModules $(module) ] {
    switch $(link) {
    case *.core :
      SubDirHdrs [ FDirName $(PLASMA) $(link:S=) core ] ;
    case * :
      SubDirHdrs [ FDirName $(PLASMA) $(link) core ] ;
      SubDirHdrs [ FDirName $(PLASMA) $(link) component ] ;
    }
  }

  local variant ;
  for variant in $(VARIANTS) {
    local C++FLAGS = $(C++FLAGS) [ FVariantC++Flags $(variant) ] ;
    local CFLAGS = $(CFLAGS) [ FVariantCFlags $(variant) ] ;
    local LINKFLAGS = $(LINKFLAGS) [ FVariantLinkFlags $(variant) ] ;

    local outputs ;
    local file ;
    for file in $(files) {
      local output = [ FVariantName $(file) : $(variant) ] ;
      output = $(output:S=$(SUFOBJ)) ;
      outputs += $(output) ;
      Object [ FGristFiles $(output) ] : $(file) ;
    }

    for library in $(LIBRARIES) {
      local libname ;
      if $(library) = SHARED {
        libname = [ FModuleSharedLibraryName $(module) : $(variant) ] ;
      } else if $(library) = STATIC {
        libname = [ FModuleStaticLibraryName $(module) : $(variant) ] ;
      } else {
        Exit ModulePart unknown library type: $(library) ;
      }
      if $(library) = SHARED {
        ModuleSharedLibrary $(libname) : $(outputs) ;
      }
      if $(library) = STATIC {
        ModuleStaticLibrary $(libname) : $(outputs) ;
      }
      Depends $(module) : $(libname) ;
    }
  }
}

rule FModuleStaticLibraryName {
  local module = $(1) ;
  local variant = $(2) ;

  return [ FVariantName lib$(module:G=)$(SUFLIB) : $(variant) ] ;
}

rule ModuleStaticLibrary {
  local name = $(1) ;
  local files = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModuleStaticLibrary $(1) . $(2) ;
  }

  if $(files) {
    LibraryFromObjects $(1) : $(2) ;
  }
}

rule FModuleSharedLibraryName {
  local module = $(1) ;
  local variant = $(2) ;

  return [ FVariantName lib$(module:G=)$(SUFSHARE) : $(variant) ] ;
}

rule ModuleSharedLibrary {
  local name = $(1) ;
  local files = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModuleSharedLibrary $(1) . $(2) ;
  }

  if $(files) {
    
  }
}

}
