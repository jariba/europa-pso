if ! $(ModuleRules_INCLUDED) {
ModuleRules_INCLUDED = TRUE ;

include [ FDirName $(SUBDIR) CommonRules ] ;
include [ FDirName $(SUBDIR) VariantRules ] ;

# TRACE_MODULE ?= TRUE ;

# LIBRARIES can be:
#   STATIC
#   SHARED

LIBRARIES ?= STATIC ;

# Module <name> : <modules this module depends on> ;
rule Module {
  local name = $(1) ;
  local modules = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo Module $(name) . $(modules) ;
  }

  local module = $(name:G=module) ;
  NotFile $(module) ;

  LINK_LIBRARIES on $(module) = $(LINKLIBS) ;
  LINK_MODULES on $(module) = $(modules:G=module) ;
  LOCATE_OBJECTS on $(module) = [ FDirName $(SUBDIR) objects ] ;
  INCLUDES on $(module) += $(SUBDIR) ;
  INCLUDES on $(module) += [ FDirName $(SUBDIR) core ] ;
  INCLUDES on $(module) += [ FDirName $(SUBDIR) component ] ;
}

# ModuleFiles <name> : <files for this module> ;
rule ModuleFiles {
  local name = $(1) ;
  local files = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModuleFiles $(name) . $(files) ;
  }

  local module = $(name:G=module) ;
  INCLUDES on $(module) += $(SUBDIR) ;
  ModulePart $(module) : $(files) ;
}

# ModuleCore <name> : <files for this module > ;
rule ModuleCore {
  ModuleFiles $(1) : $(2) ;
}

# ModuleComponent <name> : <files for this module > ;
rule ModuleComponent {
  ModuleFiles $(1) : $(2) ;
}

rule ModuleDocumentation {
  local name = $(1) ;
  local files = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModuleDocumentation $(name) . $(files) ;
  }
}

# ModuleObjects <source files> : <modules that these files depend on> ;
rule ModuleObjects {
  local files = $(1) ;
  local modules = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModuleObject $(files) . $(modules) ;
  }

  local links = [ FLinkModules $(modules) ] ;

  local link ;
  local headers ;
  for link in $(links) {
    local module = $(link:G=module) ;
    headers += [ on $(module) return $(INCLUDES) ] ;
  }

  local variant ;
  for variant in $(ALL_VARIANTS) {
    local C++FLAGS = $(C++FLAGS) [ FVariantC++Flags $(variant) ] ;
    local CFLAGS = $(CFLAGS) [ FVariantCFlags $(variant) ] ;

    local file ;
    for file in $(files) {
      if $(file:S) != $(SUFOBJ) {
        file = [ FGristFiles $(file) ] ;
        SEARCH on $(file) = $(SEARCH_SOURCE) ;

        local output = [ FVariantName $(file:S=) : $(variant) ] ;
        output = $(output)$(SUFOBJ) ;
        local HDRS = $(headers) ;
        ObjectHdrs $(output) : $(headers) ;
        Object $(output) : $(file) ;
      }
    }
  }
}

# ModuleMain <name> : <files for this test> : <modules that this test depends on> : <target to build the exe> ;
rule ModuleMain {
  local name = $(1) ;
  local files = $(2) ;
  local modules = $(3) ;
  local build_target = $(4) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModuleMain $(name) . $(files) . $(modules) . $(build_target) ;
  }

  ModuleObjects $(files) : $(modules) ;

  local links = [ FLinkModules $(modules) ] ;

  local variant ;
  for variant in $(VARIANTS) {
    local outputs ;
    local file ;
    for file in $(files) {
      file = [ FGristFiles $(file) ] ;
      local output = [ FVariantName $(file:S=) : $(variant) ] ;
      output = $(output)$(SUFOBJ) ;
      outputs += $(output) ;
    }

    local exe = [ FVariantName $(name) : $(variant) ] ;
	LINKFLAGS on $(exe) = $(LINKFLAGS) [ FVariantLinkFlags $(variant) ] ;

    for library in $(LIBRARIES) {
      if $(library) = SHARED {
        local link ;
        for link in $(links) {
          LinkSharedLibraries $(exe) : [ FModuleSharedLibraryName $(link) : $(variant) ] ;
          local link_libraries = [ on $(link:G=module) return $(LINK_LIBRARIES) ] ;
          on $(exe)_rt LINKLIBS = [ FMergeList $(LINKLIBS) : $(link_libraries) ] ;
        }
        MainFromObjects $(exe)_rt : $(outputs) : $(build_target) ;
      } else if $(library) = STATIC {
        local link ;
        for link in $(links) {
          LinkLibraries $(exe) : [ FModuleStaticLibraryName $(link) : $(variant) ] ;
          local link_libraries = [ on $(link:G=module) return $(LINK_LIBRARIES) ] ;
          on $(exe) LINKLIBS = [ FMergeList $(LINKLIBS) : $(link_libraries) ] ;
        }
        MainFromObjects $(exe) : $(outputs) : $(build_target) ;
      } else if $(library) = NONE {
        local link ;
        for link in $(links) {
          local _o = [ on $(link:G=module) return $($(variant)_OBJECTS) ] ;
          MainFromObjects $(exe)_no : $(_o) : $(build_target) : true ;
          local link_libraries = [ on $(link:G=module) return $(LINK_LIBRARIES) ] ;
          on $(exe)_no LINKLIBS = [ FMergeList $(LINKLIBS) : $(link_libraries) ] ;
        }
        MainFromObjects $(exe)_no : $(outputs) : $(build_target) ;
      } else {
        Exit ModuleMain unknown library type: $(library) ;
      }
    }
  }
}

# ModuleLibraries <name> : <libraries> ;
rule ModuleLibraries {
  local name = $(1) ;
  local libraries = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModuleLibraries $(name) . $(libraries) ;
  }

  local module = $(name:G=module) ;
  LINK_LIBRARIES on $(module) += -l$(libraries) ;
}

# RunModuleMain <target that when built runs this> : <executable> : <arguments> ;
rule RunModuleMain {
  local tests = $(1) ;
  local executable = $(2) ;
  local arguments = $(3) ;

  if $(TRACE_MODULE) = TRUE {
    Echo RunModuleMain $(tests) . $(executable) . $(arguments) ;
  }

  local variant ;
  for variant in $(VARIANTS) {
    for library in $(LIBRARIES) {
      if $(library) = SHARED {
        local exe = [ FVariantName $(executable) : $(variant) ] ;
        Execute $(tests) : $(exe)_rt : $(arguments) ;
      } else if $(library) = STATIC {
        local exe = [ FVariantName $(executable) : $(variant) ] ;
        Execute $(tests) : $(exe) : $(arguments) ;
      } else if $(library) = NONE {
        local exe = [ FVariantName $(executable) : $(variant) ] ;
        Execute $(tests) : $(exe)_no : $(arguments) ;
      } else {
        Exit RunModuleMain unknown library type: $(library) ;
      }
    }
  }
}

################
# internal rules

rule FLinkModules {
  local module = $(1) ;

  if $(TRACE_MODULE) = TRUE {
    Echo FLinkModules $(module) ;
  }

  local pushed ;
  local modules = $(module:G=) ;
  local found ;
  while $(modules) {
    local mod = $(modules[1]) ;
    if $(TRACE_MODULE) = TRUE {
      Echo - $(mod) ;
    }
    if $(mod) in $(found) {
      if $(LIBRARIES) = NONE {
        modules = $(modules[2-]) ;
        continue ;
      }
      found = [ FRemoveItem $(found) : $(mod) ] ;
      if ! $(mod) in $(pushed) {
        pushed += $(mod) ;
      }
    }
    found += $(mod) ;
    modules = [ FMergeList $(modules[2-]) : [ on $(mod:G=module) return $(LINK_MODULES:G=) ] ] ;
    if $(found) in $(pushed) {
      Exit Cycle Detected in FLinkModules. ;
    }
  }

  if $(TRACE_MODULE) = TRUE {
    Echo FLinkModules . $(found) ;
  }

  return $(found) ;
}

rule ModulePart {
  local module = $(1) ;
  local files = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModulePart $(module) . $(files) ;
  }

  local LOCATE_TARGET = [ on $(module) return $(LOCATE_OBJECTS) ] ;
  ModuleObjects $(files) : $(module) ;

  local variant ;
  for variant in $(ALL_VARIANTS) {
    local outputs ;
    local file ;
    for file in $(files) {
	  file = [ FGristFiles $(file) ] ;
      local output = [ FVariantName $(file:S=) : $(variant) ] ;
      output = $(output)$(SUFOBJ) ;
      outputs += $(output) ;
    }

    local LINKFLAGS = $(LINKFLAGS) [ FVariantLinkFlags $(variant) ] ;
    for library in $(LIBRARIES) {
      local libname ;
      if $(library) = SHARED {
        libname = [ FModuleSharedLibraryName $(module) : $(variant) ] ;
      } else if $(library) = STATIC {
        libname = [ FModuleStaticLibraryName $(module) : $(variant) ] ;
      } else if $(library) = NONE {
        $(variant)_OBJECTS on $(module) += $(outputs) ;
      } else {
        Exit ModulePart unknown library type: $(library) ;
      }
      if $(library) = SHARED {
        local link ;
        for link in [ FLinkModules [ on $(module) return $(LINK_MODULES) ] ] {
          local path = [ on $(link:G=module) return $(LOCATE_OBJECTS) ] ;
          local name = [ FModuleSharedLibraryLinkName $(link) : $(variant) ] ;
          LINKLIBS on $(libname) += $(SHARED_LIBRARY_PATH_FLAG) $(path) -l$(name) ;                                    
        }
        if $(variant) in $(VARIANTS) {
          ModuleSharedLibrary $(libname) : $(outputs) ;
        } else {
          ModuleSharedLibrary $(libname) : $(outputs) : false ;
        }
      }
      if $(library) = STATIC {
        if $(variant) in $(VARIANTS) {
          ModuleStaticLibrary $(libname) : $(outputs) ;
        } else {
          ModuleStaticLibrary $(libname) : $(outputs) : false ;
        }
      }
      if $(library) = NONE {
        if $(variant) in $(VARIANTS) {
          Depends $(module) : $(files) ;
        }
        continue ;
      }
      if $(variant) in $(VARIANTS) {
        Depends $(module) : $(libname) ;
      }
    }
  }
}

rule FModuleStaticLibraryName {
  local module = $(1) ;
  local variant = $(2) ;

  local name = $(module:G=) ;
  local libname = [ FVariantName $(name:S=) : $(variant) ] ;
  return lib$(libname)$(SUFLIB) ;
}

rule ModuleStaticLibrary {
  local name = $(1) ;
  local files = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModuleStaticLibrary $(1) . $(2) ;
  }

  if $(files) {
    LibraryFromObjects $(1) : $(2) : $(3) ;
  }
}

rule FModuleSharedLibraryLinkName {
  local module = $(1) ;
  local variant = $(2) ;

  local name = $(module:G=) ;
  local libname = [ FVariantName $(name:S=) : $(variant) ] ;
  return $(libname) ;
}

rule FModuleSharedLibraryName {
  local module = $(1) ;
  local variant = $(2) ;

  local libname = [ FModuleSharedLibraryLinkName $(module) : $(variant) ] ;
  return lib$(libname)$(SUFSHARE) ;
}

rule ModuleSharedLibrary {
  local name = $(1) ;
  local files = $(2) ;

  if $(TRACE_MODULE) = TRUE {
    Echo ModuleSharedLibrary $(1) . $(2) ;
  }

  if $(files) {
    SharedLibraryFromObjects $(1) : $(2) : $(3)  ;
  }
}

} # ModuleRules_INCLUDED
