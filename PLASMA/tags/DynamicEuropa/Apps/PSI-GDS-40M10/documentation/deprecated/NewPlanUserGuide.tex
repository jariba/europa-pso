% Copyright Notices

% This software was developed for use by the U.S. Government as
% represented by the Administrator of the National Aeronautics and
% Space Administration. No copyright is claimed in the United States
% under 17 U.S.C. 105.

% This software may be used, copied, and provided to others only as
% permitted under the terms of the contract or other agreement under
% which it was acquired from the U.S. Government.  Neither title to nor
% ownership of the software is hereby transferred.  This notice shall
% remain on all copies of the software.

\documentstyle[akj,fullpage,11pt,epsfig]{article}

\input{hsts.itex}

\def\docauthor{Ari K. J\'onsson \and Jeremy Frank}

\begin{document}


\chapter{New Remote Agent Planner \\
Intermediate Version \\ User Guide \\
ROUGH DRAFT -- DO NOT DISTRIBUTE}


\subchapter{Introduction}
%========================
%========================

The Remote Agent (RA) is a complete architecture for autonomous
control of complex systems such as spacecraft.  As one of the three
components of the RA, the Remote Agent Planner uses a declarative
model of the system to expand high-level goal requests into detailed
plans of action that can safely be executed in the system.

The Extendible Uniform Remote Operations Planning Architecture
(EUROPA) is the successor to the original RA planner that flew
on-board the Deep Space One spacecraft.  The goal of the development
of EUROPA is to provide the same key functionality as the original
planner, but using a simple uniform set of concepts and a more easily
extendible implementation.  The result will serve both as a research
tool for developing future planning techniques, and as a basis for
future applications of the Remote Agent planning technology.

In this overview, we describe the Remote Agent planning approach and
provide a user guide for an intermediate version of EUROPA. This
version uses the same basic language to describe models as the
original RA planner.  As a result, some of the added features are not
accessible to the user, and will therefore not be covered in the user
guide.  A new language is under development; it will provide complete
access to new features and make specifying models easier.

We start by giving an overview of the basics of planning, and relating
classical notions to those used in this planner.  We continue with an
overview of the Remote Agent planning approach.  Next, we introduce
the language used to model systems, so that the planner can generate
plans for them.  We then go on to discuss how individual planning
problems are specified, and how the planner will solve them.  The
discussion then turns to advanced features, such as search control and
extending the modeling capabilities.  Finally, we describe how the
user can build different search engines to control the planning
process.

This user guide derives a great deal from the original manual for the
HSTS domain description langauge, by Nicola Muscettola.  The original
manual is available at ???????.



\subchapter{Models, goals, and plans}
%====================================
%====================================


At a very high level, planning can be considered a the process of
generating descriptions of how to operate some system to accomplish
something.  The resulting descriptions are called {\em plans}, and the
desired accomplishments are called {\em goals}.  In order to generate
plans for a given system (which is also referred to as the planning
{\em domain}), a {\em model} of how the system works must be given. 
For example, given a model of a spacecraft, and the goal of collecting
and transmitting experimental data, the resulting plan would describe
the operations needed to gather and send the data.

The EUROPA planner, as its predecessor, the Remote Agent Planner, uses
declarative descriptions of models, plans and goals.  This means that
the same planner can be applied to different systems and problems,
simply by providing different models and goals.  For such declarative
planners\footnote{Declarative planners are in constrast with
special-purpose planners, in which the system model is hard-coded into
the planner.}, the expressiveness of the lanaguages for models, goals
and plans is of great importance.

In traditional planning, models are described in terms of a set of
Boolean state indicators (called {\em fluents}) and a set of actions
that can modify the fluents.  Goals are given in terms of an initial
specification of which fluents are true and which are false, and a set
of different fluent values to achieve.  A plan is then a sequence of
actions that modifies the initial state to get the desired values.  
See Figure \ref{classicPlan}.

%\fitfigure{2in}{An example of a sequential operator plan. {\bf Should
%show a classical sequantial plan with actions mapping states to
%states.}}{classicPlan}

\begin{figure}[btph]
\centerline{ \scalebox{0.65}{\epsffile{fig-1-tire-world.eps}}}
\caption{\label{classicPlan} An example of a sequential operator plan. 
The boxes show the fluents of the domain; shaded boxes indicate that 
the fluent is not true in that state.}
\end{figure}

The basic traditional approach, is too simplistic for real-world
applications.  Consider a complex system like the Deep Space One
spacecraft.  It consists of multiple interacting subsystems, such as
navigation, attitude control, camera, and main engine.  Multiple
subsystems may be active at the same time, each performing a different
activity.  There are also interactions among the subsystems, whether
or not one or both are active.  The camera, for example, cannot be
taking picture while the main engine is running.  Finally, the
classical assumptions concerning the relations between activities and
states do not hold in many cases.  For one, the states that are often
considered inactive, such as pointing at a target, are in fact
activities.  To plan for such complex systems, the expressiveness of
model, plan and goal descriptions must be increased significantly.



\subchapter{The RA Planning Approach}
%====================================
%====================================


The Remote Agent planner was designed to support planning for complex
systems, such as spacecraft and rovers.  In this section, we will
describe the Remote Agent Planner approach, explain how it differs
from classical approaches, and introduce concepts that are used in the
planning approach.  The Remote Agent approach to planning is based on
two key insights; the use of intervals to describe the temporal extent
of activities and states, and the use of timelines to describe
concurrent behavior over time.  Intervals have long been used in
temporal planning to specify activities and states with durations.
Since there are invariably limits on how intervals can interact, the
approach is often referred to as {constraint-based interval planning}.
The use of timelines is an extension of basic constraint-based
planning.  The main purpose of timelines is twofold; they provide a
natural way to describe concurrent processes and the interactions
between them, and they provide a natural representation of system
states changing over time.



\subsubchapter{Activities, and States}

To generate plans for a given system, a {\em model} of the system must
be available to the planner.  This model provides information on the
activities that can take place, on the possible states that the system
(and its subsystems) can be in, and rules and limitations on how
activities and states relate.  Let ust start by looking at activities
and states.

In this planner, the same constructs are used to describe both states
and activities.  These are typically referred to as predicates,
although sometimes the term procedure is also used.  Formally, a {\em
predicate} is a function that returns a Boolean value, used to specify
what is true and what is false.  Informally, predicates are simply
statements about what is true.  The reason is that if $p : \{1,2,3,4\}
\rightarrow \{T,F\}$ is a predicate, then $p(1)$ can be read as $p(1)
= T$, and taken to mean that $p(1)$ is true.

As an example, consider a simple rover that can move among a number of
specified locations.  A predicate can be used to describe where the
rover is, by mapping the possible locations to true or false.  Let us
call this predicate {\tt at}.  If one of the locations is a {\tt
rock}, then {\tt at(rock)} indicates that the rover is at the rock.
As another example, a predicate can also be used to describe between
what places the rover is travelling.  Let us call this predicate {\tt
going}, and have it take two locations as arguments.  Then the
statement {\tt going(lander,rock)} means that the rover is travelling
from the lander to the rock.

The rover example demonstrates that the same construct can be used to
describe states and activities.  One reason for doing so is
simplicity; there is no need to make an arbitrary syntactic
distinction between activities and states.  Another reason is that in
many systems, the distinction between activities and states becomes
blurred at higher levels of abstractions.  Let us assume that our
rover has an arm capable of picking up rock samples.  The arm can be
moved to different spots around each location, to take samples.  In
order to take a sample, the arm must be at a fixed spot.  This can be
modeled in terms of two predicates {\tt moveArm} and {\tt armAt}.  At
a first glance, one might think of the move as an activity and the arm
placement as a state.  However, maintaining the placement of the arm,
as the rock is grabbed, is actually an activity.

The uniform description of activities and states in terms of
predicates allows us to avoid any confusion about what are states and
what are activities.  Furthermore, since many systems are in fact
active at all times, a uniform description of the activity in terms of
predicates is very useful.  This has led to the use of {\em procedure}
as a synonym to {\em predicate} in some documentation of the Remote 
Agent planner.



\subsubchapter{Temporal Intervals, Variables, Tokens}

Planning is inherently based on time.  Therefore, a statement of the
form {\tt at(rock)} is invariably qualified with temporal information
about when it holds.  There are a number of different ways to specify
such temporal information.  One extreme is to specify a single
timepoint, indicating that the predicate is true at that timepoint.  
This approach is depicted in Figure \ref{singleTimepointPic}.

%\fitfigure{2in}{{An example of a plan fragment where activities and 
%states are associated with single timepoints.  \bf To replace ${\tt 
%at(rock)}_3$ example.}}{singleTimepointPic}

\begin{figure}[btph]
\centerline{
\scalebox{0.65}{\epsffile{fig-2.2-point-rep.eps}}}
\caption{\label{singleTimepointPic} An example of a plan fragment where activities and 
states are associated with single timepoints.}
\end{figure}

Another extreme is to qualify the statement with all points at which 
the predicate is true.  Figure \ref{allTimepointPic} shows what such a 
representation might look like.

%\fitfigure{2in}{An example of a plan fragment where each activity or
%state is associated with a list of all timepoints at which it holds.
%{\bf To replace: ${\tt at(rock)} [3,4,5,6,7,120,121,122,\ldots ]$ is
%the start of specifying all points at which {\tt at(rock)} is
%true}}{allTimepointPic}

\begin{figure}[btph]
\centerline{
\scalebox{0.65}{\epsffile{fig-2.1-list-rep.eps}}}
\caption{\label{allTimepointPic} An example of a plan fragment where each activity or
state is associated with a list of all timepoints at which it holds.}

\end{figure}
Regardless of which of these extreme approaches is used, time must be
specified with discrete time values.  In other words, time will be
measured with integer timesteps.  In the first case, a finite set of
timesteps is necessary to limit the enumeration of states while in the
second approach it limits the enumeration of timepoints for each
state.

In the Remote Agent planning paradigm, intervals are used to qualify
statements.  Therefore, each basic statement consists of a start time,
a predicate and an end time.  For example, Figure
\ref{intervalTimepointPic} shows the rover being at the rock between
timepoints 3 and 7.  To maintain the effectiveness of the interval
representation, it is assumed that the interval is always maximal.  In
our example, this would mean that the rover was not at the rock at
time 2, and not at the rock at time 8.

%\fitfigure{2in}{An example of a plan fragment where activities and 
%states are associated with temporal intervals.  {\bf To replace ${\tt 
%%at_(rock)}\_[3,7]$ example.}}{intervalTimepointPic}

\begin{figure}[btph]
\centerline{
\scalebox{0.65}{\epsffile{fig-2-interval-rep.eps}}}
\caption{\label{intervalTimepointPic} An example of a plan fragment where activities and 
states are associated with temporal intervals.}
\end{figure}

It should be noted that although the current EUROPA representation 
uses integral time quanta, this interval representation permits 
real-valued timepoints.  Furthermore, it is easy to adapt the planner 
to that representation.

Specifying fixed times is not always feasible, and it is not always
the most effective way to build plans.  As a result,the planner allows
the start and end timepoints of such intervals to be represented by
variables.  For example, one can specify ${\tt at(rock)}\_{[?s,?e]}$,
where $?s$ and $?e$ are variables.  If the variables values are
limited to $?s \in [3,5]$ and $?e \in [4,7]$, as an example, then
${\tt at(rock)}\_{[?s,?e]}$ specifies that the rover will arrive at
the rock between times 3 and 5 (inclusive) and stay until between
times 4 and 7 (inclusive).  This is shown in Figure \ref{flexTime},
which shows how the flexible start and end times correspond to a set
of possible scenarios for the interval.

%\fitfigure{2in}{How flexible duration start and end times correspond
%to different execution possibilities.}{flexTime}

\begin{figure}[btph]
\centerline{ \scalebox{0.65}{\epsffile{fig-3-flexible-rep.eps}}}
\caption{\label{flexTime} How flexible start and end times correspond
to different execution possibilities.  In the upper left corner we 
have a flexible interval describing the possible start and end times 
of an {\tt at(rock)} state.  Below that we see the possible starting 
points marked with {\tt s} and the possible end times marked with 
{\tt e}.  Finally, on the right hand side, we see examples of the 
permitted intervals.}
\end{figure}

There are two main reasons for permitting such flexibility.  One is
that it is often more effective to build plans by limiting unnecessary
commitment, which cannot be done if the underlying planning approach
requires complete commitment.  The other reason is that flexibility is
useful for many real-world situations.  Consider the rover moving from
the hill to the rock.  The navigation calculations may estimate the
travelling time to be 18 time units, but wheel slippage may increase
that time by up to 50\%.  Rather than breaking the plan if the travel
time goes beyond 18 time units, or forcing the activity to use all of
the worst-case estimate duration of 27, the RAP approach allows the
travel time to be specified as being between 18 and 27 time units.  A
smart agent can take advantage of such flexibility during the plan
execution.

To specify permitted ranges for activity intervals, {\em constraints}
on the interval durations can be specified.  In general, constraints
specify a set of valid assignments to a set of variables.  The set of
variables is fixed for each constraint, and is called the {\em scope}
of the constraint.  As an example of how duration constraints may be
specified, consider the last rover example.  The bound on the
traveling time restricts the duration of {\tt going(hill,rock)} to the
interval $[18,27]$.  In general, bounding the duration of an interval
corresponds to a simple arithmetic constraint.  To enforce that the
duration of an interval {\tt state\_[?s,?e]}\ is within the bounds
$[d,D]$, we simply specify a constraint:
 $$d \leq {\tt ?e} - {\tt ?s} \leq D$$
  The scope of this constraint is $\Set{{\tt ?s}, {\tt ?e}}$.

The use of fixed duration constraints is convenient and effective.
However, interval durations may be affected by other constraints, and
it quickly gets cumbersome to express all such relations in terms of
the start and end times.  For example, the bound on the rover's travel
time might depend on the amount of power available.  To support
reasoning directly about such interactions, a variable is used to
describe the duration of an interval.  As a result, any interval is
subject to the constraint
  $${\tt ?s} + {\tt ?d} = {\tt ?e}$$
  where {\tt ?s} and {\tt ?e} are variables representing the start and
end times, and {\tt ?d} is a variable representing the duration.

The use of variables to support flexibility extends beyond the 
temporal aspects of an interval.  Consider the goal that the rover be 
at the rock.  In order for the rover to be at the rock, the rover must 
get there, which is typically accomplished with some movement 
activity, like {\tt going(lander,rock)}.  But, if the rover turns out 
to not to have been at the lander before going to the rock, selecting 
this particular movement would result in an unnecessary detour to the 
lander.  Therefore, we allow variables in the arguments to predicates, 
e.g., ${\tt going}(?from,{\tt rock})$.

Taking all of this together, we get a construct that describes sets of
states and activities over temporal intervals.  Such constructs are
called {\em tokens}.  For now, we will assume that each token refers
to a single statement, i.e., that it describes a possible state or
action that persists throughout the duration of the interval.  Such
single-valued tokens are called {\em value tokens}, and unless we
explicitly say otherwise, any reference to a token should be taken to
mean a value token\footnote{There are other classes of tokens, such as
constraint tokens, which describe sets of permitted evolutions over
intervals.}.

A token has a predicate name (such as {\tt at}), a pair of timepoint
variables for the start and the end ($?s$ and $?e$), a duration
variable ($?d$) and a set of argument variables, one for each argument
to the predicate in question (say $?l$ for the location)\footnote{Each
token has one more variable, an object variable, which we will get to
soon.}.  To represent a token as a formula, we will, for now, use a
convention that will later lead to a language for specifying tokens.
The basic notation is:
  $$s \ \  {\tt pred} \ \  d \ \  (x_1, \ldots, x_k) \ \ e$$
where $s$, $d$ and $e$ specify the start time, duration and end time
respectively, ${\tt pred}$ is the predicate name, and $x_1$ through
$x_k$ specify the parameters.  Each of the $s$,$d$,$e$,$x_i$ may be
specified either by providing a variable name, e.g., $?s$, or by
providing the set of possible values for that variable.  The value set
can be a singleton, e.g., $7$, a set of values, e.g., $\Set{1,7,9}$ or
an interval, e.g., $[0,10]$.  Using this representation for tokens, we
can now specify a simple plan, as shown in Figure \ref{simpleRAPlan}. 
In this notation, the temporal variables $s$, $d$ and $e$ are
optional; the default value set for each of them is $[0,\infty]$.  We
can therefore use ${\tt at(rock)}$ as a shortcut for $[0,\infty] {\tt
at} [0,\infty] (rock) [0,\infty]$.

%\fitfigure{2in}{A simple plan describing the rover staying at the rock
%until somewhere between time units 4 and 8, then going to the lander,
%arriving between 18 and 22 and staying there until timepoint 25. {\bf
%Need to replace the ugly one that I made.}}{simpleRAPlan}

\begin{figure}[btph]
\centerline{
\scalebox{0.65}{\epsffile{fig-5-simple-plan.eps}}}
\caption{\label{simpleRAPlan} A simple plan describing the rover staying at the rock
until somewhere between time units 4 and 8, then going to the lander,
arriving between 18 and 22 and staying there until timepoint 25.}
\end{figure}

Finally, let us note that not all instantiations of token variables
are valid.  For example, the duration bound of a {\tt going(?org,
?dest)} state will likely depend on the origin and destination of the
movement.  In other words, if {\tt ?d} represents the duration
variable, there is a constraint on the valid combinations of values
for {\tt ?org}, {\tt ?dest}, and {\tt ?d}.  Such limitations are
enforced by constraints on the variables appearing in a token. 
Consequently, tokens typically have a set of constraints associated
with them; the scope of each constraint is a subset of the variables
of that token.



\subsubchapter{Attributes and Timelines}

Complex systems, like rovers, invariably have a number of interacting
states and activities.  A natural approach to describing such systems
is in terms of {\em attributes}.  Typically, an attribute will
describe the state of a component or subsystem, ongoing system
activity, or other things that concern the system or a subsystem.
Since the state or activity of a component will change over time, an
attribute describes a state variable that changes values over time.
The rover, for example, might have a number of different attributes,
describing the different subsystems and other aspects of it.  Let's
assume the rover has an arm and two sample storage containers.  The
rover could then be modelled as having a location attribute, an arm
activity attribute, and an attribute describing the state of each
storage area.

Each attribute has a set of predicates that are used to describe the
state or activity in question.  In terms of an attribute being a state
variable, the predicates define the possible values.  For example, the
location attribute of the rover has the {\tt at} and {\tt going}
predicates.

Typically, for any given attribute, there are restrictions on how the
its state can change over time.  For example, the rover cannot
transition from {\tt at(rock)} directly to {\tt at(hill)}.  If we
consider the set of all instantiations of all predicates associated
with a given attribute as nodes in a graph, valid transitions can be
specified as directed arcs in this graph.  The result is a state
transition diagram that defines the set of possible evolutions of a
given attribute.  Figure \ref{goAtStatesFig} shows a simple state
transition diagram for the rover location attribute.

%\fitfigure{3in}{A state transition diagram describing the set of legal
%transitions (and thus evolutions) of the location
%attribute.}{goAtStatesFig}

\begin{figure}[btph]
\centerline{
\scalebox{0.65}{\epsffile{fig-6-state-transition.eps}}}
\caption{\label{goAtStatesFig} A state transition diagram describing the set of legal
transitions (and thus evolutions) of the location
attribute.}
\end{figure}

A {\em timeline} is a logical structure used to represent and reason
about the development of an attribute over a period of time.  As
certain aspects of the description may not be fully specified, e.g.,
token variables may not have been assigned single values, a timeline
can represent a set of possible evolutions.  In its simplest form, a
timeline is a sequence of tokens, each describing an activity or a
state over some period of time.  Two adjacent tokens may have a {\em
slot} between them, i.e., room where additional tokens may possible be
added.  For an example, consider the simplified picture of a timeline
in Figure \ref{simpleTimeline}

%\fitfigure{2in}{A simple example of a timeline with a slot between two
%tokens. {\bf Replaces:}{\tt at(rock) ... at(hill) 24}}{simpleTimeline}
%  The figure represents a timeline where the rover starts out at the
%rock at time 0, is at the hill at time 24, and may do something in
%between.

\begin{figure}[btph]
\centerline{
\scalebox{0.65}{\epsffile{fig-7-empty-slot.eps}}}
\caption{\label{simpleTimeline} A simple example of a timeline with a slot between two
tokens.}
\end{figure}


Timelines describe attribute histories over periods of time.  When
planning, all timelines describe the same period.  This period is
called the {\em planning horizon} (or simply the {\em horizon}).  All
planning activity goes on within this time period\footnote{Having a
planning horizon does not force the planner to generate only plans
that completely fill the horizon.  It does, however, limit planning to
be within that horizon.}.


\subsubchapter{Classes and Objects}

An entity like the rover has multiple attributes.  In addition, there
may be multiple rovers involved in the planned operations.  To group
related attributes together and to support multiple instantiations, we
consider the rover as an object.  A class hierarchy is then used to
describe the types of objects in the world.  A {\em class} is formally
defined as a set of attributes.  The attributes can either stem from
being specified for a class, or by inheritance.  For example, we could
define a class of rovers, say {\tt class SimpleRover}, that only has a
location attribute.  Rovers with a single arm could constitute a
subclass {\tt class RoverWithArm} that also has an arm state
attribute.  Finally, we could define a class of specific rovers, {\tt
class SampleRover}, that also has two sample container attributes.

An {\em object} is an instance of a class.  Our example rover would be
an object of class {\tt SampleRover}.  While classes have attribute
specifications, those attributes are instantiated in an object of that
class.  As a result, we typically use timelines to describe the
attributes of instantiated objects.

The notion of objects leads to one additional variable for each token,
namely the object to which the token applies.  Consider an operation
involving multiple rovers.  One of the goals may be to have a rover at
the rock for a given time period, but any rover will do.  In terms of
a token describing this situation, there is an open decision about the
timeline on which to put the token.  To represent such flexibility in
where tokens go, each token has a variable representing the set of
possible objects it may apply to.  This variable is called the {\em
object variable}.




\subsubchapter{Planning Domain Axioms}

The world is filled with rules and limitations, both universal and
manmade.  As a result, many candidate plans are impossible,
unsafe or invalid.  We have already seen examples of constraints on
valid token variable instantiations, in addition to limits on valid
attribute evolutions, enforced by state transition graphs.  So far,
these rules have been limited to single tokens and single attributes.
We now turn our attention to the much more general class of limits on
valid interactions between different attributes and objects.  

To demonstrate possible interactions between different attributes, let
us assumed that our rover has a simple arm, and that the state of the
arm is described by an {\tt armState} attribute.  Noting that this is
only a very simple example, not a proposed mission, let us assume that
the arm can be in only two states: {\tt off} and {\tt waving}.

In the Remote Agent planning paradigm, a uniform representation is
used to specify all rules and limitations of a planning domain.  These
are called {\em planning domain axioms}.  The planning domain axioms
are used to represent everything from simple instantiation constraints
to complex interaction rules.  Nonetheless, planning domain axioms can
be distilled into two parts:
  \begin{itemize}
  \item Token constraints:  Specify which combinations of token
variable instantiations result in a valid token.
  \item Configuration rules: Specify the context in which a token can
appear in plan.
  \end{itemize}
  The duration and instantiation constraints discussed above are
examples of token constraints, while the rules implied by the state
transition graphs are examples of configuration rules.

The EUROPA system supports arbitrary token constraints, but, like
other planning systems, it limits configuration rules to a certain
structure.  In classical planning, for example, the configuration
rules for actions are limited to:
  \begin{itemize}
  \item Preconditions: Rules about states that must hold when the
action is executed.
  \item Effects: Rules about how the state of the world changes, as a
result of executing an action.
  \end{itemize}
  The structure used in the Remote Agent planning paradigm
significantly extends the structure of traditional classical planning
rules.  It is also more expressive than the structure used by most
other constraint-based planning systems.

In the Remote Agent planning paradigm the planning domain axioms are
specified in terms of {\em compatibilities} or {\em compats} for
short.  The basic idea is that a compatibility will specify the set of
plan elements that are necessary for having a given token in the plan. 
Consider a state like {\tt going(x,y)} for our sample rover.  The
planning domain axioms for this state must enforce the following:
  \begin{itemize}
  \item The duration is limited to the appropriate bound on travel
time for going from the origin to the destination.
  \item The location of the rover must have been at the origin
immediately prior to this.
  \item The location of the rover will be at the destination
immediately following this.
  \item The arm must be off during this.
  \end{itemize}

To describe such restrictions, compatibilities specify rules that
apply to specific token instantiations.  There are many equivalent 
ways in which compatibilities can be described, as we shall see 
later.  In this guide, we will focus on the simplest approach that is 
sufficient to represent all possible compatibility rules.  In this 
approach, a compatibility consists of:
  \begin{itemize}
  \item A header that specifies the token and its variables
  \item A set of constraints specifying when the compatibility applies
  \item A set of token constraints that restrict possible 
  token instantiations
  \item A set of configuration rules specifying other tokens that 
  must exist in the plan
  \end{itemize}

The {\em rule header} describes a token and names the associated
variables.  In the case of providing a rule for the {\tt going} token,
this header names the temporal, duration, object and parameter
variables that come with each such token.  The role of the header is
simply to specify the context (i.e., the predicate and the variables).
The {\em guard conditions} specify constraints on some of the token
variables.  These conditions determine when the rule is applicable.  
The {\em configuration rules} and the {\em token constraints} are the 
consequences of the rule being applicable.  The token constraints 
limit the possible combinations of values for token variables, while 
the configuration rules limit the set of valid plans by requiring 
certain states and activities to appear with specific relations to the 
token to which the rule applies.

To formalize this notion, each compatibility can be described as a
rule of the form:
  \begin{eqnarray*} 
  x_s \ P_{x_o} x_d (x_1,\ldots,x_k) x_e; G_1(x_1), \ldots, G_k(x_k)
\\
  \rightarrow C_1(Y_1), \ldots, C_m(Y_m); \tau_1 S_1(Z_1), \ldots,
\tau_n S_n(Z_n)
  \end{eqnarray*}
  where $\Set{x_1,\ldots,x_k,x_s,x_d,x_e, x_o}$ is the full set of
variables for the token, parameter variables, then start time,
duration, end time and object variables respectively, and
  \begin{itemize}
  \item each $Y_i$, and $Z_i$ is a subset of these variables,
  \item each $G(x_i)$ is a guard constraint of the form $x_i \in D_i$
where $D_i$ is a set of values for $x_i$,
  \item each $C_i(Y_i)$ is a constraint on the values of the variables
in $Y_i$
  \item each $\tau_i$ is quantitative temporal relation between two
intervals (the set of all possible relations will be given later)
  \item each $S_i(Z_i)$ is a specification of a token
  \end{itemize}
  This form of compatibilities is called a {\em conditional
compatibility}, since the application is conditional on the guarding
constraints $G_i$ being satisfied.

This rule is actually a shortcut for a well-defined logical rule which
essentially states that for any token $T_P$, with the predicate $P$,
such that the parameter variables satisfy the guard unary constraints
$G_i$, the token variables must satisfy each of the constraints $C_i$,
and for each $\tau_i S_i(Z_i)$ there must exist another token $T_i$ in
the plan, such that $T_i \subseteq S_i(Z_i)$ and the temporal relation
$T_P \tau T_i$.

The compatibility structure may look involved, but it is fairly simple
in practical use.  In terms of a compatibility, the above-mentioned
restrictions on {\tt going} can be specified as follows:
  \begin{eqnarray*} 
  {\tt going}_{o} d (x,y); 
  &\rightarrow & 
   d = {\tt calcTravelTime}(x,y); \\
  && {\tt metBy} \  {\tt at}_o(x), \\
  && {\tt meets} \  {\tt at}_o(y), \\
  && {\tt containedBy} \  {\tt off}_o() 
  \end{eqnarray*}
  The configuration rules can easily be represented graphically, with
arrows noting the temporal relations, and nodes describing the tokens
involved.  The ${\tt going}(x,y)$ configuration rule is shown in
Figure \ref{simpleCompatFig}.

%\fitfigure{3in}{A graphical picture of a simple compatibility for {\tt
%going(x,y)}.  The duration constraint is shown next to the {\tt
%going}activity, the configuration rules are shown as temporal
%relations and tokens that must exist in the plan.}{simpleCompatFig}

\begin{figure}[btph]
\centerline{
\scalebox{0.65}{\epsffile{fig-8-compat.eps}}}
\caption{\label{simpleCompatFig} A graphical picture of a simple
compatibility for {\tt going(x,y)}.  The duration constraint is shown
next to the {\tt going} activity, the configuration rules are shown as
temporal relations and tokens that must exist in the plan.}
\end{figure}

In the above example, there is only one configuration that supports
the {\tt going(x,y)} activity.  In many cases, however, different
configurations may support a given state or activity.  We could, for
example, imagine that the rover could also move from one place to
another, while waving, as long as the duration of the {\tt going}
activity is limited to 10 time units.  Such planning domain axioms can
be represented by {\em disjunctive compatibilities}.    Disjunctive 
compatibilities are well-defined concepts, but the formal description 
is significantly more involved than the simple conditional rule.

% Typically, a
% disjunctive compatibility is of the form:
%   \begin{eqnarray*} 
%   x_s \ P_{x_o} x_d (x_1,\ldots,xk) x_e; G_1(x_1), \ldots, G_k(x_k)
% \\
%   \rightarrow C_1(Y_1), \ldots, C_m(Z_m); \Gamma_1, \ldots, \Gamma_n
%   \end{eqnarray*}
%   where each $\Gamma_i$ is of the form $\tau_{i,1} S_{i,1}(Z_{i,1}),
% \ldots, \tau_{i,m_i} S_{i,m_i}(Z_{i,m_i})$.

However, we note that any disjunctive compatibility can just as well
be represented by a set of conditional compatibilities, provided that
additional parameters are used to distinguish between the available
options.  In the case of {\tt going}, we can add a third parameter,
which takes on the value {\tt true} if the rover will be waving and
{\tt false} otherwise.  The conditional compatibilities can then be
specified as follows:
  \begin{eqnarray*}
  {\tt going}_{o} d (x,y,w); w = {\tt true} 
 &  \rightarrow &
    d = {\tt calcTravelTime}(x,y); \\
  &&   {\tt metBy} \  {\tt at}_o(x), \\
  && {\tt meets} \  {\tt at}_o(y), \\
  && {\tt containedBy} \  {\tt off}_o() 
  \end{eqnarray*}
  and
  \begin{eqnarray*} 
  {\tt going}_{o} d (x,y);  w = {\tt false} & \rightarrow & 
  d = {\tt calcTravelTime}(x,y), \\
  && d <= 20 ;  \\ 
  && {\tt metBy} \  {\tt at_o(x)}, \\
  && {\tt meets} \  {\tt at_o(y}, \\
  && {\tt containedBy} \  {\tt waving}_o()
  \end{eqnarray*}

Looking at these conditional compatibilities, it is easy to see that
certain aspects of the two configurations are the same.  Since there
is no reason that two or more conditional compatibilities cannot apply
to the same token, we can separate out the common elements and put
them together in a third compatibility.  This gives us the following
  \begin{eqnarray*} 
  {\tt going}_{o} d (x,y,w); &\rightarrow &
   d = {\tt calcTravelTime}(x,y), \\
  && {\tt metBy} \  {\tt at_o(x)}, \\
  && {\tt meets} \  {\tt at_o(y}, 
  \end{eqnarray*}
  and 
   \begin{eqnarray*} 
  {\tt going}_{o} d (x,y,w); w = {\tt true}
  &\rightarrow &
   {\tt containedBy} \  {\tt off}_o()
  \end{eqnarray*}
  and
  \begin{eqnarray*} 
  {\tt going}_{o} d (x,y,w);  w = {\tt false}
  &\rightarrow & 
   d <= 20 ; \\
  && {\tt containedBy} \  {\tt waving}_o() 
  \end{eqnarray*}
  This representation makes it easy to specify smaller and simpler
rules that together define the same limitations as larger disjunctive
compatibilities.

Each configuration rule gives rise to a set of pairs, each of which is
of the form $\tau S(Z)$, where $\tau$ is a quantitative temporal
relation and $S(Z)$ is a token specification using $Z$, a subset of
the given token variables $X$.  Each such pair is commonly referred to
as a {\em subgoal}.  Disregarding the complication that the rover may
be able to wave enroute, consider {\tt going(rock,hill)} as a goal
that is to be achieved by the rover.  In order to do this, the rover
must also satisfy other conditions, namely to be at the {\tt rock}
before commencing the {\tt going} action, to be at the {\tt hill}
immediately following it, and to keep the arm {\tt off} during the
travel.  The term subgoals stems from the common notion that such
conditions can be viewed as additional goals to be achieved by the
rover.

At a first glance, it may seem odd to view being at the hill after the
{\tt going} activity as a goal.  After all, being on the hill is what
the going activity is meant to achieve.  The reason for viewing such
an ``effect'' as a subgoal is that compatibilities are deliberately
non-directional as far as time is concerned.  This makes it possible
to use the same method for planning, regardless of whether it is done
temporally backwards, forwards or even sideways.  This is in stark
contrast to traditional STRIPS planning where a different technique
(goal regression) is defined for planning backwards in time than for
planning forwards in time.

%%NOTE: The point here is not of heuristic choice but of different
%% algorithms - this is orthogonal to search control issues





\subsubchapter{Plans and Candidate Plans}

Let us assume that a planning domain has been specified, in terms of
classes, attributes, predicates and domain axioms, as described here
above.  At a high level, this domain describes the kinds of objects we
can have, the attributes they have, and how the various states and
activities can interact.  Given such a domain, the goal of a planner
is to generate a valid plan, i.e., an evolution of object attribute
states and activities, such that a given specification of the goals is
achieved.  The issues we now need to address are: What constitutes a
valid plan, how are goals specified, and how can the planner reason
its way from goals to a plan.  The construct that ties all these
concepts together is that of a {\em candidate plan}, which consists of
the following:
  \begin{itemize}
  \item A horizon, specifying the time frame for which we are planning;
  \item a set of objects, i.e., instances of the domain classes;
  \item a timeline for each attribute of each object, each of which is
a sequence of one or more tokens that belong on that timeline;
  \item a set of tokens currently not associated with timelines (free
  tokens);
  \item a set of constraints on the variables of the tokens; these
include the temporal ordering constraints that are implicit in the
sequence of tokens on timelines.
  \end{itemize}

The horizon and the set of objects are typically viewed as fixed
members of candidate plans, i.e., they are not changed by the planning
process\footnote{The system supports the addition of new objects
during the planning process, but we will only cover that functionality
in an appendix on advanced topics.}.  The sequence of tokens on the
timeline for each object attribute describes a set of possible
evolutions of that attribute over the planning horizon.  For an
example, consider a timeline for the rover location:
  $${\tt at(lander)} \ldots {\tt at(hill)} \ldots {\tt at(lander)}$$
  This timeline describes a set of possible evolutions of the rover
locations, namely those in which the rover is at the lander twice, and
visits the hill in between.  Recall that between tokens on timelines
there are slots into which additional tokens can be put.  A a result,
a given timeline does not specify a necessary evolution, it describes
a set of possible evolutions.

In a candidate plan, some tokens may not have been assigned inserted
into timelines yet.  Those are called {\em free tokens}.  Free tokens
differ from timeline tokens in two ways.  First, they have not been
scheduled on a timeline, i.e., the sequencing relation to other tokens
has not been decided.  For example, if {\tt at(rock)} was a free token
that was to be inserted into the above sample timeline, then the
available options might be to put it before the first {\tt
at(lander)}, between that token and {\tt at(hill)}, and so forth.  The
second distinction is that a free token may not have been assigned to
a particular object, and is therefore not associated with a particular
timeline.  Consider having two rovers with equal capabilities.  The
free token {\tt at(rock)} could be accomplished by either of them. 
This would be represented by the object variable of this token having
two possible values.

The final element in the candidate plan is a set of constraints on
token variable instantiations.  Typically, these are constraints that
arise from planning domain axioms.

The planning process maps one candidate plan to another, with the goal
of generating a valid plan.  The operations available to the planning 
process  are the following:
  \begin{itemize}
  \item Modify the set of values for a variable
  \item Insert a token into a timeline
  \item Free a token from a timeline
  \end{itemize}
  A {\em search engine} controls the application of these operations.
The candidate plan will be automatically updated, in response to these
operations, so as to enforce the constraints and rules specified in
the planning domain axioms.  Most of this automatic updating is in
terms of adding or removing subgoals, along with the applicable
constraints.  Let us therefore start by looking at the concept of
subgoaling.

Recall that one can express configuration rules as conditional
compatibilities, each of which maps a set of possible instantiations
of a predicate into a set of constraints and subgoals.  Given a
particular token, say $p([3,7],{a,b,c})$, the conditional
compatibilities determine a set of applicable subgoals and
constraints.  If the value sets of the variables are modified, then
the set of applicable subgoals may change.  The changes are monotonic
in the sense that if the variable value sets are reduced, then more
subgoals and constraints may be added.  Similarly, if the value sets
are extended, subgoals and constraints may be removed.  Due to this
property, we will view the reduction and the extension of variable
value sets as separate operations.

To satisfy all applicable subgoals, any candidate plan is
automatically updated to include tokens that satisfy applicable
subgoals.  The applicable subgoals are directly determined by the
domain axioms, with one exception.  On each timeline, the first and
last tokens (which may be the same token) have a special status. 
Consider the first token on a timeline, and any subgoal rules of the
form ${\tt met\_by}\ {\tt token}$.  Since any token used to satisfy
this subgoal will be considered outside of the planning horizon, this
subgoal is in fact not applicable.  Similarly, subgoals of the form
${\tt meets}\ {\tt token}$ are not applicable to the last token on a
timeline.

To see an example of how this all comes together, let us assume we
have a candidate plan for our rover, with a timeline that contains two
tokens:
  $${\tt at(rock)} \ldots {\tt at(hill)}$$
  The compatibilities for the {\tt at}\ state are as follows:
  \begin{eqnarray*} 
  {\tt at}_{o} (x); 
  &\rightarrow & 
  {\tt metBy} \  {\tt going}_o(?,x), \\
  && {\tt meets} \  {\tt going}_o(x,?)
  \end{eqnarray*}
  Looking at {\tt at(rock)}, we see that we get one applicable
subgoal, since the {\tt metBy}\ subgoal is inapplicable.  Similarly,
for the {\tt at(hill)}, we get another applicable subgoal.  To satisfy
these subgoals, two new free tokens are added to the candidate plan:
{\tt going(rock,?)}\ and {\tt going(?,hill)}, along with the
appropriate temporal constraints, namely that {\tt going(rock,?)}\
starts as soon as {\tt at(rock)}\ ends, and that {\tt going(?,hill)}\
comes immediately before {\tt at(hill)}.  If one of the {\tt at}\
tokens is later removed from the timeline (or the candidate plan
altogether), the corresponding subgoal is also removed.

In EUROPA, the candidate plans all satisfy a simple invariant: All
applicable subgoals are satisfied for all tokens on timelines.  The
automatic updating enforces this invariant, based on subgoaling.  This
is done as follows:
  \begin{itemize}
  \item Restrict a variable value set: If the token is on a timeline,
add free tokens to satisfy any subgoals that become applicable as a
result of the restriction.
  \item Extend a variable value set: If the token is on a timeline,
delete any tokens generated to satisfy subgoals that are no longer
applicable, due to the change in the value set.
  \item Insert a token on a timeline: Add new free tokens to satisfy
all applicable subgoals for the inserted token.
  \item Remove a token from a timeline: Delete all tokens that were
added to satisfy subgoals for this token.
  \end{itemize}

The goal of the planning process, which is driven by a {\em search
engine}, is to apply these operations, mapping one candidate plan to
another, until a valid plan is found.  Formally, the definition of a
valid plan is in terms of the executive that executes the plan.  This
is because different executive have different capabilities.  We will
return to this issue later; until then, a {\em valid plan} (or simply
a {\em plan}) is a plan candidate that satisfies the following
conditions:
  \begin{itemize}
  \item There are no free tokens
  \item All parameter variables have been assigned single values
  \end{itemize}


\subsubchapter{Summary}

In this section, we have given a brief overview of the Remote Agent
planning paradigm.  The key concepts we have covered are:
  \begin{description}
  \item[Predicate] 
  \item[...]
  \end{description}

Armed with these concepts, we can now turn our attention to the
planning system itself, how it can be used, how it works and how it
can be extended.







\subchapter{Planning Domain Models}
%==================================
%==================================

As we noted here above, in order to plan the operations of a given
system, we need a model of how the system works.  This includes the
specification of classes of objects, attributes, predicates that
describe states and activities, and axioms the define which plans are
feasible and valid.  In addition, many systems give rise to predicates
with parameters that take values from special sorts (types), which
must therefore also be defined as part of the model.  The model will
therefore specify:
  \begin{itemize}
  \item the object classes and their attributes
  \item the domain-specific value sorts
  \item the predicates (describing activities and states)
  \item the planning domain axioms
  \end{itemize}

In the EUROPA system, this system model, called the {\em planning
domain model}, is described with a language called the {\em Domain
Description Language}, or {\em DDL} for short.  The language is based
on the Lisp syntax, so most components are described as parenthesized
lists.  In this section, we will introduce this language, and explain
how it is used to specify the different components of a model.  It
should be pointed out that the original language definition was more
general than what is currently supported, resulting in seemingly
unnecessary keywords and delimiters.  This issue, which is only a
syntactic issue, will be addressed with an object-oriented replacement
language that is under development.

Before we get into the language itself, let us give a quick overview
of how we present the syntax and examples of the language.  We will
use angle brackets to denote grammar terms (variables).  These may
then be further broken down by grammer rules, or explained verbally.
The most common construct is that of a list, so the grammar term {\tt
<list-of-X>}, where {\tt X} is another construct, is reserved for
describing a parenthesized list of {\tt X} items.  For example, {\tt
<list-of-names>}, where {\tt name} is an arbitrary symbolic
description, can be substituted by {\tt (foo bar boo far)}.  Any
non-bracketed terms are keywords, except, of course, in examples
showing how the language can be used.


Finally, we should note that white spaces are interchangable in this
language, so the formatting used in the following definitions and
examples is only a suggestion.


\subsubchapter{Classes and Attributes}

Basic domain classes and their attributes (or state variables) are
specified in a single definition of the form:
  \begin{verbatim}
(Define_Object_Class <class-name>
  :state_variables
    <list-of-attribute-defs>
  )  \end{verbatim}
  The paranthesis-delimited list of attribute declarations consists of
one or more attribute definitions, each of the form:
  \begin{verbatim}
  (Controllable <attribute-name>) \end{verbatim}

As an example of a simple class definition, consider a very simple
rover whose only concern is its location:
  \begin{verbatim}
(Define_Object_Class Rover_Class
  :state_variables (
     (Controllable location)
  )
)  \end{verbatim}

Class attributes can be inherited from one class to another, although
multiple inheritance is not supported.  To define a subclass, the user
simple notes the superclass in the object class definition:
  \begin{verbatim}
(Define_Object_Class <class-name>
  :superclass
    <super-class-name>
  :state_variables
    <list-of-attribute-defs>
)  \end{verbatim}
  For example, the class of rovers with manipulation arms could be
specified as a subclasss of the basic rover:
  \begin{verbatim}
(Define_Object_Class Armed_Rover_Class
  :superclass
     Rover_Class
  :state_variables (
    (Controllable arm)
  )
)  \end{verbatim}
  A rover object of this class would then have a location timeline and
an arm timeline.


\subsubchapter{Domain Sorts}

The planning system supports a range of different built in sorts
(types), such as integers, reals and boolean values.  In addition, the
user can specify additional sorts as part of the domain model.  Some
user-defined sorts are implicit; namely, those that represent classes
of domain objects; a domain class automatically gives rise to a sort
that has the same name as the class.  For example, the object class
definition for {\tt Rover\_Class} gives rise to a new object sort,
called {\tt Rover\_Class}.  The elements of that sort will be all
objects of the rover class.  Other user-defined sorts are explicitly
defined.  The core planning system allows label sorts, named value
sorts and interval sorts to be defined.  However, the current modeling
language limits the specification of new named sorts to label sorts.

Label sorts are used to specify symbolic values.  In a label sort,
each value has a unique name, but no other semantics.  To define a
label sort, the sort name and the item names are specified:
  \begin{verbatim}
(Define_Label_Set <sort-name> <list-of-names>)\end{verbatim}
  The sort name must be distinct from other sort names (including
builtin sort names, such as ``Integer'', ``Real'', and ``Bool'', and from
object sort names defined by {\tt Define\_Object\_Class}).
In our simple rover example, the set of locations might be expressed
as labels:
  \begin{verbatim}
(Define_Label_Set Location_Label (lander rock hill sand))\end{verbatim}

In addition to the builtin sorts and the label sorts, intervals of the 
builtin numeric sorts can be specified.  These are described by:
  \begin{verbatim}
  <numeric-sort>[<low> <high>] \end{verbatim}
where {\tt <numeric-sort>}\ is replaced by either {\tt Integer}\ or
{\tt Real}, and {\tt <low>} and {\tt <high>} are replaced by
appropriate numbers.  For example, {\tt Integer[0 100]}\ refers to the
set of integers between 0 and 100, inclusively.  Such intervals can be
used as sorts.

  Adherence to specified sorts is enforced throughout the planning
process.  Variables participating in constraints must have the
appropriate sorts; for example, variables participating in arithmetic
constraints must be integer or real variables. Variables participating
in equality constraints can be of any sort, but both must be of the
same sort.




\subsubchapter{Value Sets}

A number of constructs are used throughout the domain description
language.  The most common is that of a value set. Value
sets\footnote{Those are often called domains, but we'll avoid that
word due to it being used to describe the planning domain.} are
typically used to specify the sets of possible values for variables.
Since all variables are of specific sorts, value sets also have
specific sorts.  

There are four basic ways to describe value sets:
  \begin{itemize}
  \item Provide a single value
  \item List the values in the set
  \item Provide an interval defining the set
  \item Denote that the set consists of values defined in the sort of
the value set
  \end{itemize}

Before we get to describing the value sets, let us quickly point out
how values are specified in this language.  Integer values are written
as simple numbers (87), while real values are either written as simple
real numbers with a decimal point (87.0), or in power notation
(3.0e8).  Two special keywords are used to describe infinite integer
values, {\tt \_plus\_infinity\_} corresponds to positivie infinity
($+\infty$), while {\tt \_minus\_infinity\_} represents negative infinity
($-\infty$).

To describe a value set as a listing of values, the common set
notation is used, with the exception that no commas are betwen
entries.  For example:
  \begin{verbatim}
  { on off}  \end{verbatim}
  would describe the set consisting of two values from a label sort.

Describing value sets as intervals only applies to numerical sorts,
for obvious reasons.  The classical interval notation, using square
brackets, is used.  In the case of an integer sort,
  \begin{verbatim}
  [1 10] \end{verbatim}
describes the set 
   $$\Set{0,1,2,3,4,5,6,7,8,9,10}$$  
In the case of a real sort,
  \begin{verbatim}
  [1 10] \end{verbatim}
  is considered to consist of the infinite set of real values from 0
to 10, inclusively.

To describe value sets as having all values of the associate sort, the
keyword {\tt?\_any\_value\_} or a ``*'' can be used.




\subsubchapter{Predicates}

Predicates are used to uniformly represent activities and states.  To
define a predicate, the following command is used:
\begin{verbatim}
(Define_Predicate <name> <optional-list-of-param-defs>)
\end{verbatim}
  where each entry in the list of parameter definitions, if any are 
provided, is of the form
\begin{verbatim}
(<param-sort> <param-name>) 
\end{verbatim}
  The {\tt <param-sort>}\ is either the name of a sort (builtin or
user specified) or a numerical interval as described above.  The
definition specifies a parameter to be of the given sort, and
associates the given name with that parameter.

To give an example of how predicates are defined, let us again look
towards our simple rover.  In terms of its locatoin attribute, the
rover can either be at some location, or be going from one location to
another.  The predicates that specify these activities can be defined
as follows:
  \begin{verbatim}
(Define_Predicate At (
    (Location_Label Curr_Loc)
  )
)

(Define_Predicate Going (
    (Location_Label From_Loc) 
    (Location_Label To_Loc)
  )
)
  \end{verbatim}

If we look at the extension of our rover, having an arm that can
either wave or be off, we can describe these with predicates that take
no argument:
  \begin{verbatim}
(Define_Predicate Wave)
(Define_Predicate Off) \end{verbatim}

The defined predicates are used to describe the activity or state of
attributes.  Therefore, a set of predicates must be associated with
each attribute.  This is done by defining the attribute values.  To 
facilitate using the same predicate in multiple 
attributes\footnote{This has hardly ever been used in practice, but 
the langauge definition supports this.}, the attribute values are 
defined as follows:
  \begin{verbatim}
(Define_Member_Values <list-of-attribute-specs>  <list-of-preds>)
\end{verbatim}
  where each {\tt <attribute-spec>}\ is a parenthesized
class-attribute pair, i.e., an expression of the form:
\begin{verbatim}
  (<class> <attribute>) \end{verbatim}
  where {\tt <class>} is a class name, {\tt <attribute>} is the name
of an attribute of that class.  The final component, {\tt
<list-of-preds>} is simply a list of names of predicates that have
been defined earlier.  In most cases, the predicate membership is
being defined for only one attribute of one class at a time, so the
most commonly used form of this declaration is:
  \begin{verbatim}
(Define_Member_Values ((<class> <attribute>))  <list-of-preds>)
\end{verbatim}

As an example of how this declaration is used, we can define the
possible location states and activities for the rover as follows:
  \begin{verbatim}
(Define_Member_Values ((Rover_Class location)) 
    (At Going))  \end{verbatim}
  Similarily, we can define the possible states of the rover arm:
  \begin{verbatim}
(Define_Member_Values ((Rover_Class arm))
    (Off Wave)) \end{verbatim}



\subsubchapter{Domain Axioms - Compatibilities}

The domain sorts, attribute and predicate definitions provide all that
is needed to build complete plans.  However, most of these plans are
unlikely to be valid plans.  Domain axioms define which plans are
valid.  In the Remote Agent planning paradigm, domain axioms are
specified using compatibilities, as described above.  These
compatibilities are complex constructs which have a great deal of
expressive power.  Furthermore, we have already seen two types of
compatibilities, conditional and disjunctive.  Nonetheless, each
compatibility is naturally composed of three parts: A description of
which token instantiations it applies to, a set of constraints that
limit the set of valid token instantiations further, and finally the
configuration rules which describes the conditions under which these
token instantiations can appear in a plan.

The general form of a compatibility declaration is the following:
  \begin{verbatim} 
(Define_Compatibility
  (SINGLE (<attribute-spec>) (<token-spec>))
  <optional-duration-spec>
  <optional-list-of-parameter-constraints>
  <optional-subgoals-spec>
)  \end{verbatim}
  The attribute specification and the token specification\footnote{The
DDL grammar actually supports a list of attribute specifications,
followed by a list of token specifications, hence the paranthesis
around each entry.  However, in order for variable references to be
well-defined, only one token specification can appear in a
compatibilitiy.  Additional specifications will result in an error.}
define the set of token instantiations to which the compatibility is
applicable.  We will refer to this as the set of {\em target tokens}
for this compatibility.  The optional duration specification defines a
restriction on the duration of all target tokens, while the optional
list of parameter constraints defines a set of restrictions on the
variables in the target tokens.  Together, these describe the
instantiation restrictions for the target tokens Finally, the optional
specification of subgoals defines the set of allowable plan
configurations in which one of the target tokens can appear.

We will now decompose this construct further, looking at each of the
three components, the head, the constraints and the subgoals.



\subsubsubchapter{Target Token Specification}

The target token specification is the first part of the compatibility
definition.  It takes the form:
\begin{verbatim}
  (SINGLE (<attribute-spec>) (<token-spec>))  \end{verbatim}

We have already seen attribute specifications, which are expressions
of the form: 
  \begin{verbatim}
  (<class> <attribute>) \end{verbatim}
  where {\tt <class>} is a class name, and {\tt <attribute>} is the
name of an attribute of that class.

Token specification have not been described before.  These constructs
combine information about the names of token parameter variables, and
the guard constraints that determine the set of target tokens to which
the compatibility applies.  Recalling the formal definition of a
compatibility, we have
  \begin{eqnarray*} 
  x_s \ P_{x_o} x_d (x_1,\ldots,xk) x_e; G_1(x_1), \ldots, G_k(x_k)
\\
  \rightarrow C_1(Y_1), \ldots, C_m(Z_m); \tau_1 S_1(Z_1), \ldots,
\tau_n S_n(Z_n)
  \end{eqnarray*}
  where $\Set{x_1,\ldots,x_k,x_s,x_d,x_e, x_o}$ is the full set of
variables for the token, parameter variables, then start time,
duration, end time and object variables respectively.  The token
specification essentially specifies the head of this rule.

The standard token variables, those common to all tokens, have
reserved names in the domain description language. These names are:
  \begin{description}
  \item[?\_start\_time\_] refers to the variable representing the start 
  time of the token
  \item[?\_end\_time\_] refers to the variable representing the end 
  time of the token
  \item[?\_duration\_] refers to the variable representing the duration 
  of the token
  \item[?\_object\_] refers to the variable representing the object to 
  which the token applies
  \end{description}
  These variables do not appear in token specifications.  The token
specification therefore only describes the token predicate and the
predicate parameters.

The current domain description language allows a great deal of
information to be expressed in the target token specification.  The
two key components are the naming of parameter variables and the
specification of a guard constraint.  Unfortunately, the language does
not allow both to be used simultaneously for the same parameter. 
Consequently, each variable is described with a {\tt var-spec}\
construct which is either a name of the form {\tt ?<name>} or a value
set {\tt <value-set>}, as described above.  In this language,
different expressions are used for token specifications, depending on
whether the predicate in question has parameters or not.  If the
predicate {\tt <pred>} takes no arguments, then a corresponding token
specification is of the form:
  \begin{verbatim}
  (<pred-name>) \end{verbatim}
  If, however, the predicate does take arguments, the expression used
is of the following form (note the extra parenthesis):
  \begin{verbatim}
  ((<pred-name> <list-of-var-specs>)) \end{verbatim}
  This unfortunate context-sensitivity is inhereted from an early
version of this language, in order for this version of the planner to
be backwards compatible.

For examples of token specifications, let us once again consider our
simple rover.  The token specification for a token for the {\tt Wave}\
predicate would simply be {\tt (Wave)}.  For more complex predicates,
such as {\tt Going}, a wide variety of token specifications can be
constructed.  For example,
  \begin{verbatim}
  ((Going (?_any_value_ ?_any_value_))) \end{verbatim}
  would refer to any instantiation of the {\tt Going}\ predicate.  The
token specification
  \begin{verbatim}
  ((Going (?from ?to))) \end{verbatim}
  would also refer to all instances of the predicate, but it would
also provide names for the arguments.  These names can then be used to
refer to the corresponding arguments.  The specification
  \begin{verbatim}
  ((Going (?from rock))) \end{verbatim}
  would refer to any instantiation where the rover is going from some
place to the rock, and the {\tt ?from}\ variable can be used to refer
to the origin.  Similarly,
  \begin{verbatim}
((Going ({rock hill} ?dest))) \end{verbatim} refers to any
instantiation where the rover is going from either the rock or the
hill to a destination, to which the variable {\tt ?dest} refers.  Note
that since the constrained parameter cannot be named, it will be
impoossible to refer to the place of origin in the body of the
compatibility.



\subsubsubchapter{Instantiation Constraints}

Recall that instantiation constraints limit the permitted combinations
of token variable values, thus restricting the set of permissible
instantiations of the target tokens.  The domain description language
supports a general mechanism for specifying constraints on token
variables.  For convenience, two shortcut mechanisms are provided to 
capture commonly used cases.

In general, the instantiation constraints are given as a list of
constraints, using the form:
  \begin{verbatim}
  :parameter_functions
  <list-of-constraint-specs> \end{verbatim}
  As can be seen from the keyword used in the current domain
description language, the general syntax for specifying instantiation
constraints is based on the notion of one variable being affected by a
function that may depend on other variables.  The actual constraints
are not limited to affecting single variables, but due to this notion
of constraints as functions, the general format for specifying
constraints, i.e., for {\tt <constraint-spec>}\ is the following:
  \begin{verbatim}
  (<var-name> <- <constraint-name> <list-of-var-specs>)
\end{verbatim}
where {\tt <constriant-name>}\ is one of a large set of constraints
supported by the planning system, and the {\tt <var-name>}s, including
those in any {\tt <var-specr>}s, refer to either variables named in a
token specification or one of the builtin variables.  Note that the
list of arguments to the constraint, {\tt list-of-var-specs}\ can be
empty, in which case an empty list should still be specified, i.e.,
{\tt ()}.  

A variation on the general syntax is used for one of two shortcuts. 
This shortcut is used to enforce an equality constraint between two
variables.  It is specified by using a double arrow, instead of the
single arrow:
  \begin{verbatim}
  (<var-name> <-> <var-name>)  \end{verbatim}
  It should be noted that this is equivalent to the expression:
  \begin{verbatim}
  (<var-name> <- eq(<var-name>))  \end{verbatim}

Finally, the second shortcut, the optional duration constraint, is
specified outside of the {\tt :parameter\_functions} declaration. 
This constraint limits the duration of a target token to a given
bound.  The form used to specify this is:
  \begin{verbatim}
  :duration_bounds [<low> <high>]  \end{verbatim}

Putting together what we have so far, we can provide simple
compatibilities for some of our sample rover predicates.  Let us first
look at the {\tt At}\ predicate, and assume that there is a minimum
duration for the rover staying at a given location, say 10.  This can
be specified with the following compatibility:
  \begin{verbatim}
  (Define_Compatibility
    (SINGLE ((Rover_Class location)) ((At (?loc))))
    :duration_bounds [10 _plus_infinity_]
   )  \end{verbatim}
  Let us now assume that the duration of a {\tt Going}\ token depends
on the origin and destination of the movement activity.  Furthermore,
let us assume that this information has been encoded in a constraint
called {\tt calcTravelTime}.  Then, we can write the follwing
compatibility for the {\tt Going}\ tokens:
  \begin{verbatim}
  (Define_Compatibility
    (SINGLE ((Rover_Class location)) ((Going (?from ?to))))
    :parameter_functions (
      (?_duration_ <- calcTravelTime(?from ?to))
    )
  )  \end{verbatim}




\subsubsubchapter{Subgoals}

The final component of a compatibility is the configuration rule,
which specifies a set of other tokens that must exist within a plan,
in order for a target token to appear in that plan.  Recall that in
our discussion of planning domain axioms above, we described two ways
to specify such configuration rules.  One was to specify conditional
compatibilities, using the applicability guards to specify which
target tokens the compatibility applies to.  The other approach was to
specify disjunctive comaptibilities, which give a set of possible
configurations, only one of which must be satisfied.  The current
version of the domain description language permits both kinds of
configuration rules to be specified, and even to be intermixed to a
certain extent.

Let us start by looking at the simplest configuration rules, the basic 
conditional ones.  In these, the list of subgoal specifications is 
given in the following form:
  \begin{verbatim}
  :compatibility_spec
  (AND
    <sequence-of-subgoal-specs>) \end{verbatim}
  where {\tt <sequence-of-subgoal-specs>}\ is a list of subgoal
specifications, without the surrounding parenthesis that lists have.
Each {\tt <subgoal-spec>} is an expression of the form:
  \begin{verbatim}
    (<temp-rel> <subgoal-token-spec>)
\end{verbatim}
  The temporal relation specifies how the subgoal relates temporally
to the target token.  The possible temporal relations are discussed
here below.  The subgoal token specification is similar to a general
token specification, but provides slightly more generality and also
some limitations.  The form is:
  \begin{verbatim}
  (SINGLE ((<class-spec> <attr-name>)) 
          (<pred-name>)) \end{verbatim}
  in the case where the predicate has no arguments.  Otherwise it is: 
  \begin{verbatim}
  (SINGLE ((<class-spec> <attr-name>))
          ((<pred-name> <list-of-var-specs>))) \end{verbatim}
  
In subgoal token specifications, each variable specifications must be
a value set specification, a reference to a variable appearing in the
target token specification, or one of the reserved variable names.  In
the last case, where standard variable names are used, the standard
variables refer to the target token.  The class specification is,
however, slightly more general than it is in the target token
specifications, as a variable can be used instead of a class name. 
This variable must be either a parameter from the target token, or the
standard variable {\tt ?\_object\_}, referring to the object to which
the target token has been assigned.

For an example of how this works, let us look at the 










The general form for a configuration rule is the following:
  \begin{verbatim}
  :compatibility_spec
  <compat-spec> \end{verbatim}
  where each {\tt <compat-spec>}\ is a conjuction:
  \begin{verbatim}
  (AND <sequence-of-compat-specs>)  \end{verbatim}
  a disjunction:
  \begin{verbatim}
  (OR <sequence-of-compat-specs>) \end{verbatim}
  a conditional disjunction:
  \begin{verbatim}
  (<var-name> OR <sequence-of-labelled-compat-specs>) \end{verbatim}
  or a subgoal specification
  \begin{verbatim}
  (<temp-rel> <subgoal-token-spec>) \end{verbatim}

[[Are nested conditionals allowed?]]












The main part of a compatibility, the configuration constraints, is
specified in terms of an and-or tree of subgoals.  Arbitrary nesting
of and-or trees is supported, with each conjunction and disjunction
being of the form:
\begin{verbatim}
    (AND <branches>)
    (OR <branches>)
\end{verbatim}
Where the branches are either conjunctions/disjunctions, or subgoals. 
Each subgoal is specified by a temporal relation and a specifciation
for a sbuggoal token.  There are two types of subgoals; value (single)
token goals, and constraint (multiple) token goals.  The most commonly
used type is that of value (single) subgoals:
\begin{verbatim}
    (<temp-rel> (SINGLE ((<class-name> <attribute-name>))
                        (<pred-name> <arg-list>)))
\end{verbatim}

The {\tt <arg-list>} is a list of variable references and/or value 
domain specifications.  The length of the list must match the number 
of arguments defined for the predicate in question.  The variable 
references are simply the names of token variables.  The domain 
specifications describe sets of values.  The possible options are:
\begin{itemize}
\item Single values:  A numerical value or the name of the label
\item Bounds: Two numerical values, enclosed in brackets
\end{itemize}

The temporal relation, {\tt <temp-rel>} is one of the following:
\begin{itemize}
\item before (d D)
\item after (d D)
\item starts\_before (d D)
\item starts\_after (d D)
\item ends\_before (d D)
\item ends\_after (d D)
\item starts\_before\_end (d D)
\item ends\_after\_start (d D)
\item contains (d D) (e E)
\item contained\_by (d D) (e E)
\item parallels (d D) (e E)
\item paralleled\_by (d D) (e E)
\item meets
\item met\_by
\item equals
\end{itemize}

In order to satisfy a value (single) subgoal, the plan must include a 
token that matches the subgoal description, such that the specified 
temporal relation is satisfied.  

Constraint (multiple) subgoals are used to limit the set of tokens
that may appear over certain time periods.  The syntax is similar to
value (single) subgoals, except for the keyword ``multiple'', the fact
that a list of token descriptors is permitted, and that parameter
variables cannot\footnote{This is a temporary condition, due to the
fact that the new planner does not yet support variables in constraint
tokens.} appear in the argument list.  As a result, the syntax is:
\begin{verbatim}
    (<temp-rel> (MULTIPLE ((<class-name> <attribute-name>))
                          (<pred-name> <arg-list>)
                                     ...
                          (<pred-name> <arg-list>)
                          ))
\end{verbatim}


To put all this together into concrete examples, let us start by 
looking at a very simply compatibility for the rover going from one 
location to another.  This compatibility specifies that this must be 
preceded by the rover being at the origin location and succeeded by 
the rover being at the destination location.  The temporal relations 
describing immediate predecessors and successors are {\tt met\_by} and 
{\tt meets} respectively:
\begin{verbatim}
(Define_Compatibility
  (SINGLE ((Rover_Class location)) ((Going (?from ?to))))
  :compatibility_spec
  (AND
   (met_by (SINGLE ((?_object_ location)) ((At (?from)))))
   (meets (SINGLE ((?_object_ location)) ((At (?to)))))))
\end{verbatim}
To satisfy this compatibility, for any instance of {\tt Going(x,y)},
the plan must contain {\tt At(x)} and an {\tt At(y)} intervals on the
same rover's location timeline, such that the end of the {\tt At(x)}
interval is equal to the start of the {\tt Going(x,y)} interval, and
the start of the {\tt At(y)} interval is equal to the end of the {\tt
Going(x,y)} interval.

Attention should be drawn to the use of object variables in the
object/class component of the subgoal specification.  It is necessary
to use the object variable to guarantee that the subgoals apply to the
same rover, not some other rover of the same class.

A natural extension to this compatibility would be to constrain the
duration of the jorney to depend on the origin and destination. 
Assuming that we had a constraint called {\tt travelTimeBound} to
enforce this, the compatibility could be extended to:
\begin{verbatim}
(Define_Compatibility
  (SINGLE ((Rover_Class location)) ((Going (?from ?to))))
  :parameter_functions
  ((?_duration_ <- travelTimeBound(?from ?to)))
  :compatibility_spec
  (AND
   (met_by (SINGLE ((?_object_ location)) ((At (?from)))))
   (meets (SINGLE ((?_object_ location)) ((At (?to)))))))
\end{verbatim}

Finally, to demonstrate how constraint (multiple) subgoals may be 
specified, let us consider a rover with a manipulation arm.  During 
travel, the arm must either be in {\tt off} or {\tt ready} mode.  This 
coulde be specified as follows:
\begin{verbatim}
(Define_Compatibility
  (SINGLE ((Rover_Class location)) ((Going (?from ?to))))
  :parameter_functions
  ((?_duration_ <- travelTimeBound(?from ?to)))
  :compatibility_spec
  (AND
   (met_by (SINGLE ((?_object_ location)) ((At (?from)))))
   (meets (SINGLE ((?_object_ location)) ((At (?to)))))
   (contained_by (MULTIPLE ((?_object_ arm)) ( OFF READY )))))
\end{verbatim}



\subsubchapter{Conditional Subgoals}

Although this intermediate version of the Remote Agent planner shares
the modeling language with the original planner, it is based on an
internal representation and reasoning that is somewhat different from
the original planner.  These internal changes were driven by the need
to simplify and clarify the reasoning process and provide
functionality that was not supported in earlier versions.  The shared
language somewhat limits the use of advanced functionality, but a
slight language extension allows us to use one of them, conditional
subgoals.

In the simplest terms, a conditional subgoal is one that depends on 
the possible values for a predicate parameter.  For example, it would 
enable us to specify a constraint that the rover can only go to the 
hill directly from the lander:
\begin{verbatim}
(Define_Compatibility
  (SINGLE ((Rover_Class location)) ((Going (?from ?to))))
  :parameter_functions
  ((?_duration_ <- travelTimeBound(?from ?to)))
  :compatibility_spec
  (AND
   (?to OR
     (hill (met_by (SINGLE ((?_object_ location)) ((At (lander)))))
     (* (met_by (SINGLE ((?_object_ location)) ((At (?from)))))
   (meets (SINGLE ((?_object_ location)) ((At (?to)))))))
\end{verbatim}

{\bf [[ find better example - check if * syntax is valid ]] }

The way this works is that if the rover is going from one place to
another, then the model will differentiate on whether the target is
the hill or some other place.  If it is the hill, the requirement is
that the rover was previously at the lander, if it is not the hill,
then there is no restriction on where the rover was (other than it
being somewhere).

It is easy to see that conditional subgoals subsume disjunctions, and
AND-OR trees in general.  In addition, conditional subgoals allow
parameter constraints and subgoals to be specified conditionally,
which would simplify the above example by replacing the disjunction
with the conditional addition of an equality constraint (essentially,
{\tt ?from == hill}\footnote{This syntax is not supported by DDL, this
would have to be replaced with {\tt ((?from <- eq(hill)))}.  However,
this is irrelevant as DDL does not support conditional subgoals in 
this fashion.}).

In this intermediate version of the planner, disjunctions are in fact
replaced by conditional subgoals.  Consider an arbitrary AND-OR tree. 
This tree gives rise to a fixed number of possible combinations,
simply by turning it into disjunctive normal form.  Let us say that we
end up with $n$ disjunctions.  We can then replace the AND-OR tree
with $n$ conditional subgoals, using a single extra variable in the
predicate parameters.  This extra variable, which is called a {\em
discrimination variable} has $n$ possible values and its value
determines which of the disjunctive subgoals is chosen.

It should be noted that the mapping from AND-OR trees to a flat set of
disjunctions with a single discrimination variable will not necessarily
result in more efficient search.  However, the uniform representation
of choices as varaibles can significantly simplify and speed up the
internal reasoning.  In addition, the use of labels to mark the
disjunctions can provide exactly the same functionality as the AND-OR
tree.  Finally, the direct specification of conditional subgoals,
instead of using AND-OR trees, will never be less effective than the
AND-OR tree and will often lead to more efficient search.



\subsubchapter{Issues in Domain Modeling}

Every possible predicate instantiation must be covered by some
compatibility constraint.  The simplest way to achieve this is to 
have a compatibility of the form:
\begin{verbatim}
(Define_Compatibility
   (SINGLE ((<class> <attr>)) ((P (?X1 ... ?Xk))))
    ...)
\end{verbatim}
for every predicate {\tt P}.  The reason for this is to avoid the
possible ambiguity of predicate instantiations without compatibility
constraints\footnote{The semantics are ambiguous since a predicate
instance without a compatibility could either be interpreted as
providing no constraints or forbidding it completely.  Since empty
compatibilities (having no subgoals) describe target tokens that can 
appear in all situations, the lack of a compatibility should indicate 
that the described target token is not permitted.  However, this 
conflicts with the older interpretation that no compatibility means 
no constraints.}.

Although it is not mandatory, a good rule of thumb is that each
predicate instance should give rise to a predecessor subgoal and a
successor subgoal.  This is useful to avoid unexpected effects and
serves to guarantee completeness.

The original planner provided the means to define objects in the
model.  The current system does not support this.  The reason is that
there was a requirement for supporting dynamic objects, which must be
handled by the plan database, not the model.  In order to handle older
models, any object definitions in the model are simply turned into
class definitions.  This leads to a common problem with mismatches in
class specifications, which extends to more than just objects and
classes.  A general description of this problem follows.

Class mismatch is a common problem in older models, and this is
further aggravated by the automatic translation of objects into
classes.  Considere a class $C$ and a subclass $S$.  A common mistake
is to specify the compatibilities in terms of the subclass $S$, while
specifying a planning problem in terms of the superclass $C$.  This
instance of $C$ is not automatically an instance of the subclass $S$,
which means that subgoals specified in terms of $S$ have no planning
time object with which they are associated.  In older models, it is
common to see a class $C$ and then an object $O$ of class $C$, where
all compatibilities are defined in terms of $O$.  If, during planning,
the only instantiated timelines are those belonging to an instance of
the class $C$, the subgoals in terms of $O$ have no place to go. 
While the original planner did not make the distinction between the
object $O$, defined as part of the model, and an arbitrary object of
class $C$, defined during planning, the new system correctly makes
this distinction.  As a result, it is recommended that all
compatibilities be written in terms of the highest-level class to
which they apply.




\subchapter{Goals and Initial States}
%====================================
%====================================


Given a model of a system, autonomous planners can be used to find
plans to achieve different goals.  The goals can vary greatly, from
simple achievement of a certain state to performing a complex set of
tasks.  Traditionally, such goals have been specified in terms of an
initial state, which describes what is true at the beginning of the
plan, and a set of achievement goals, which describes what should be
true at the end of the plan.  In the Remote Agent planning paradigm,
much more complex goals can be specifed, including goals with temporal
constraints and maintenance conditions.  In this section, we turn our
attention to how to specify the goals, and which plans will achieve
those goals.


\subsubchapter{Initial State and Goals as Candidate Plans}

The key observation about initial state and goal specification is that
together they actually define a plan fragment, i.e., an incomplete
plan candidate.  This is true in both traditional planning frameworks
and the Remote Agent Planner framework.  However, classical planning
frameworks typically do not handle arbitrary partial plans as inputs,
the problem instance specification syntax and the planning algorithms
are limited to specifying initial and final states.  In the RA
planning paradigm, any partial plan can be specified as the initial
state, and the planning algorithm will handle it correctly.  This
permits a much greater expressiveness in the specification of the
planning goals.

As a result of the above, describing a planning problem instance is
equivalent to specifying a (possibly) partial plan.  In the current
version of the new RA planner, plans are described in a very simple
and limited language.  In the near future, a more expressive language
will be provided.  There are four main components to specifying a plan
candidate (initial state); the time horizon for that plan, the objects
in that plan, the given entries on the timelines for the objects and
the free goals that have not been assigned to a timeline.  Let us now 
look at each of these in turn:

Any plan must have a specified horizon.  The horizon is specified as 
the first entry in a plan description, a bracketed pair of numbers:
\begin{verbatim}
   [<start> <end>]
\end{verbatim}
For example:
\begin{verbatim}
   [ 0 200]
\end{verbatim}
indicates that the planning horizon extends from time 0 to time 200 
(inclusive).

Objects and timelines are currently specified with a single construct. 
For each specified objects, all associated timelines must be given
start and end tokens.

\begin{verbatim}
[ 0 200 ]

Object_Timelines Rover_Class Bobo (
    location (
        At(lander)
        ...
        At(hill)
        ...
        At(rock)
    )
)

\end{verbatim}







\subchapter{Using the Sample Planner}
%==================================
%==================================
This chapter describes briefly a planner which is constructed using the Plan Library.
The document provides a description of how to invoke the planner and a description
of how the planner searches the space of possible plans.

\subsubchapter{Introduction}
This planner serves two purposes.  First, it provides users of RAP with a planner
that can solve simple problems.  Second, it provides planner designers with a simple
example of how a planner can be constructed.  Designers should refer to the Plan Library
and Building a Planner sections for more details.  This planner is not meant to
be used for anything other than instructive reasons.  However, it certainly can serve
as the basis for a more sophisticated backtrack-based planner.

\subsubchapter{Using the Sample Planner}
The planner invocation is:\\
samplePlanner -m modelFile [-p {0,1}] [-f {0,1}] [-w {0,1}] [-n nodes] -i initStateFile] [-h heuristicFile] [-o {low,medium,high}] 

The various options to the planner are given below.  The description indicates whether the
argument is required or not.

\begin{description}
    \item[-p \{0,1\}] This input indicates whether the model is checked for parse errors only,
    or whether the model is parsed and planning subsequently begins.  By default, samplePlanner
    assumes -p 0, which indicates that planning will begin; if the user passes -p 1, then
    only parsing will occur.  This is an optional argument.

    \item[-f \{0,1\}] fail flag; if this argument is 0 (false), then the planner will
    exit with a 1 if there is no plan, and 0 if there is a plan; if 1, then the planner
    will exit 0 whether or not there is a plan.  The default is 0.  This is an optional
    argument.

    \item[-w \{0,1\}] This flag specifies whether warnings are
    displayed during the planning process.  If the flag is 1
    (true), then warnings are displayed; if the flag is 0 (false)
    the warnings are suppressed.  The default is 1; this is an
    optional argument.

    \item[-n nodes]  This flag, followed by an integer, limits the number of states
    the planner will investigate before search is halted.  This argument is useful
    when testing, as it places an upper bound on the amount of time the user must wait
    before getting some sort of result.  If this flag is not used, the planner will search
    until either a plan is found or the planner verifies that no plan exists.  This is
    an optional argument.

    \item[-m modelFile] This input argument is required, and indicates the name of the model
    file.  The model file contains the description of the model that is used in planning.
    The model file may refer to other files containing aspects of the model.
    This argument is not optional.

    \item[-i initStateFile] This input file contains a description of the initial state
    that the planning process begins in.  This input file is required if -p 0 is used, i.e.
    if planning occurs subsequent to parsing.

    \item [-h heuristicFile] This input file is optional, and contains heuristic directives
    which are used in planning.  

    \item [-o \{low,medium,high\}] This input argument is
    optional, and indicates how much output the planner produces
    during planning.  Low output indicates the plan depth, what
    action was taken (binding a variable or inserting a token),
    and whether the actions were retracted or not.  Medium output
    also prints a list of free tokens and unbound variables. 
    Additionally, medium output indicates whether the commitment
    is a unit decision or whether it was made by consutling the
    heuristics table.  If the heuristics were used, the priority
    of the commitment is printed.  High output also prints the
    timelines for each attribute after every action, either making
    or retracting a planning decision.
\end{description}

\subsubchapter{The Sample Planner Algorithm}
The samplePlanner is a chronological backtracking algorithm.  It employs a combination of
static and dynamic variable ordering heuristics, and employs static value ordering heuristics.
The variable ordering heuristics work as follows:
\begin{itemize}

\item If a decision exists with either 1 or 0 choices, that decision
will be made next by the planner; such a decision results in the
message ``Making a Unit decision'' when the output level is medium or
high.  If many such decisions exist, one will be arbitrarily selected. 
Notice that this means that several unit decisions may be made before
a decision with no choices is found; this causes backtracking to
occur.

\item If there are no unit decisions, then all decisions are sorted by
priority.

\item If the highest priority decision is of priority 0, then a
dynamic variable ordering heuristic selects the decision with the
fewest remaining choices.  Notice that the count of choices for
variables (values) and the count of choices for tokens (slots) are
treated equally by this heuristic.  If several such decisions exist,
an arbitrary decision from among these is selected.

\item Otherwise, a decision of the highest priority is selected to
make next.  If several such decisions exist, an arbitrary decision
from among these is selected.

\end{itemize}

The value ordering heuristics which are used express a partial
ordering of the values.  The planner tries values in the order in
which they appear in the value ordering heurisitcs.  If some values
are not listed in the value ordering heuristic, then they are tried in
arbitrary order, after the listed values have been tried.

\subsubchapter{Sample Planner Output}
This section describes some features of the output of the planner.  As mentioned previously,
the planner has 3 output modes, which provide different ``granularity'' output to the user.
In this section, we describe in more detail what the various pieces of this output mean.

\subsubsubchapter{Low Volume Output}
Low volume output provides only basic information about what the planner is doing.
A sample of low volume output appears below.

{\tt
\noindent ...\\ 
At depth 28\\
Nr Of Nodes = 27\\
For variable Downlink\_Window-6 , have 1 values\\
Binding a Variable\\
At depth 29\\
Nr Of Nodes = 28\\
For value token F\_and\_P\_Observation\_HI( [0,+INF], \{ObsNo, ObsLo, ObsHi\}, [0,+INF], \{0\}) , have 1 slots\\
Inserting a Value Token\\
At depth 30\\
Nr Of Nodes = 29\\
Assignment of variable failed, no value found\\
Freeing token \\
Insertion of Record( \\
\indent [0,89964000], \\
\indent [0,90000000], \\
\indent [0,+INF], \\
\indent \{ObsNo, ObsLo, ObsHi\}, \\
\indent \{ObsNo, ObsLo, ObsHi\}, \\
\indent \{Rec\_Bef\_Rec\}, \\
\indent \{CS\_Aft\_Rec, Rec\_Aft\_Rec, PB\_Aft\_Rec\}, \\
\indent \{FP\_HI, FP\_LO, Mos\_HI, Mos\_LO\}, \\
\indent \{0\}) \\
onto slot 0 failed, removing it.\\
At depth 30\\
Nr Of Nodes = 29\\
Insertion of value token failed, no slot found\\
...
}

At each search state, the planner indicates the ``depth'', that is,
the number of variable bindings and token insertions that have been
performed, and the number of ``nodes'', or the number of partial
assignments to variables that have been searched to date.  The planner
then prints the number of possible values for the next decision, be it
a token insertion or a variable binding.  In these cases, \\
{\tt Record( \\
\indent [0,89964000], \\
\indent [0,90000000], \\
\indent [0,+INF], \\
\indent \{ObsNo, ObsLo, ObsHi\}, \\
\indent \{ObsNo, ObsLo, ObsHi\}, \\
\indent \{Rec\_Bef\_Rec\}, \\
\indent \{CS\_Aft\_Rec, Rec\_Aft\_Rec, PB\_Aft\_Rec\}, \\
\indent \{FP\_HI, FP\_LO, Mos\_HI, Mos\_LO\}, \\
\indent \{0\})}\\
\noindent is the token type for a free record token, and {\tt
Downlink\_Window-6} refers to the 6th parameter of a {\tt
Downlink\_Window} token.  When all values of a variable or all slots for
a token are exhausted, a message to that effect is printed.

If we consider the record token type, we see that the domains of the parameter
variables are printed as part of the token type.  {\tt $[0,89964000]$} indicates
an interval, while {\tt \{ObsNo, ObsLo, ObsHi\}} indicates a list of variables
in a label set.  

\subsubsubchapter{Medium Volume Output}

Medium volume output provides considerably more information about the
planner's operations.  For instance, when the planner makes a unit decision
(i.e. a decision with either one or zero values remaining) this is printed,
as is shown below:

{\tt
\noindent ...\\
Making a Unit decision\\
For variable Scan\_Idle-3 , have 1 values\\
At depth 2\\
Nr Of Nodes = 3\\
...}

When the planner makes a decision by consulting the heuristics table, this
is also indicated, along with the priority of the decision, as shown
below:

{\tt
\noindent... \\
Making a Static Heuristic decision of priority 93\\
For variable Record-6 , have 3 values\\
At depth 86\\
Nr Of Nodes = 87\\
...}

Medium output also includes information about the remaining decisions to be made.
Notice that these decisions will change over time, as the insertion of new tokens
leads to the generation of other tokens and associated variables.  This information
is as a predicate-index pair for a variable, or as a token type for free
tokens.  Variables are followed by the current derived domain of that variable.
An example of this output follows:

{\tt
\noindent
Token Network Information.\\
  \#objects = 4\\
  \#tokens =  22\\
  \#constraints = 28\\
Free tokens:\\
valtok = F\_and\_P\_Observation\_HI( [0,+INF], \{ObsNo, ObsLo, ObsHi\}, [0,+INF], \{0\})  
T:([[1,31535999],[2,+INF]])\\
Unbound Decision variables:\\
F\_and\_P\_Observation\_HI-4 = \{0\}\\
}

There is an additional piece of information in the token types, indicated by the\\
{\tt T:([[1,31535999],[2,+INF]]}.\\
\noindent  This reflects the constraints on the start
and end times of the free token.
In this example, the variable {\tt F\_and\_P\_Observation\_HI-4} has a derived domain
with only one element.  This means that as a result of propagation there is only one
element of the domain which is permitted for this variable; it will eventually be made
as a unit decision, unless the domain is emptied in a future propagation step.

\subsubsubchapter{High Volume Output}
High volume output provides the most complete information on the planning process.
In addition to the output described above, the planner also prints each of the timelines
described in the model.  A timeline printout looks like this:

{\tt
\noindent
Object with 1 attributes.\\
Attribute 2\\
***---***---***---***---***\\
Timeline Information.\\
***---***---***---***---***\\
Timeline Consistency is 1\\
\{0\}\\
Comm\_Idle( \{0\})\\
$[0,31536000]$\\
$[0,31536000]$\\
Comm\_Idle( \{0\})\\
\{3.1536e+07\}\\
}

The timeline consists of ranges of legal times for timepoints and token types.
Looking at the above output,  we see that the timeline starts at 0, and the
duration of the first {\tt Comm\_Idle} token is not yet known.  Also notice that
there are two timepoints with nothing between them.  This indicates that there
is an empty slot on this timeline which other tokens can be inserted into.

In addition, there are some elaborations to the information printed when the
planner makes decisions.  The planner prints the value of the variable which
is bound at each decision point, as shown below:

{\tt
\noindent... \\
Making a Unit Decision\\
For variable Record-3 , have 1 values\\
At depth 86\\
Nr Of Nodes = 87\\
Trying to assign 3600 to variable Record-3\\
...}

The planner also prints the number of the slot which is tried for token insertion
decisions, as shown below:

{\tt
\noindent... \\
Making a Unit decision\\
For value token F\_and\_P\_Observation\_HI( \\
\indent [0,+INF], \\
\indent {ObsNo, ObsLo, ObsHi}, \\
\indent [0,+INF], \\
\indent {0}) , \\
\\have 1 slots\\
At Plan Depth = 29 :\\
Nr Of Nodes = 28\\
Trying to insert F\_and\_P\_Observation\_HI( \\
\indent [0,+INF], \\
\indent {ObsNo, ObsLo, ObsHi}, \\
\indent [0,+INF], \\
\indent {0})\\
onto slot 1\\
...}

Finally, each time a value or slot fails, the planner prints a message saying
that the value or slot did not work, as shown below:
{\tt
...\\
\noindent\\
Back to Plan Depth = 97 :\\
Assignment to variable F\_and\_P\_Observation\_HI-4 failed, retracting it.\\
Assignment to variable F\_and\_P\_Observation\_HI-4 failed, no value found.\\
}



\subchapter{About the Planning Process}
%=====================================
%=====================================


%% AKJ: write this




\subchapter{Heuristics}
%=====================
%=====================

%%% AKJ:  Jeremy should fix various things, see saved comment pages


An
important part of the search algorithm includes the consultation of
{\em heuristics} which dictate what variable to work on next, or what
value to try and assign to a variable next.  Heuristics are rules
which are used to guide search algorithms to make good decisions about
how to proceed.  In this section we briefly describe heuristics, then
discuss how to specify heuristics for the planner.
We first describe the role heuristics play in search algorithms.
We then describe the syntax of the heuristics which can be specified
for RAP.  Following the syntax, we provide a range of examples of
heuristics, using some simple compatibilities to motivate the examples.
Finally, we provide a more detailed example of how to specify forward
and backward state-space search using RAP heuristics.
  
\subsubchapter{Introduction}

Most search algorithms are actually algorithm templates, in that the
overall algorithm framework is designed to provide certain nice
theoretical guarantees, but some details are left unspecified.  RAP
comes provided with planners employing {\em constructive} search
algorithms, which build solutions by assigning one variable at a time,
and trying values for these variables one at a time until all options
are exhausted.  These search algorithms leave unspecified the method
of selecting the next variable, as well as the method of ordering
the values.  {\em Heuristics} are used to guide search algorithms by
influencing these choices.  {\em Variable ordering} heuristics are
used to determine which variable to work on next.  {\em Value ordering}
heuristics are used to decide what order the values are to be tried.

The RAP framework requires planners to make only 2 types of decisions:
Insert a token onto the timeline or bind a variable.  Since a planner
may have to choose from among many decisions of each type, all
decisions have associated with them a {\em priority} which planners use
to order variables.  Variable binding decisions contain an ordered
list of values, which expresses the desired order for trying the
values during search.  The list need not contain all the possible
values for the variable.  Decisions corresponding to free tokens
are somewhat different.  The ``values'' of these decisions are the
slots on the timeline where the token is to be inserted.  These slots
can change as search proceeds, so simply enumerating the order of the
slots will not suffice.  Instead, heuristics are expressed in terms of the
properties of the slots.  The {\em primary} slot order heuristic is a
preference of whether the token should be inserted onto an empty slot
or a full slot, or no preference.  The {\em secondary} slot order heuristic
is a preference for putting the slot nearer to the start horizon, the end
horizon, as close as possible to the action which created the free token
as a subgoal, or no preference.  

%Heuristic information is specified for decisions in one of two ways.
%The first method is to describe the {\em context} in which the
%heuristic information applies.  For variables, this context is limited
%to a single {\em token type}.  For tokens, the context includes the
%token type of the token, and a specification of the token's origins.
%A token originates in the initial state, or as a subgoal of a master
%token with a specified token type and a temporal relation.  The second
%way to provide heuristic guidance is to specify {\em default}
%heuristic information.  This information is automatically associated
%with any decision for which an explicit context is not provided.

Heuristics in RAP are specified to apply in a particular {\em
context}.  That way, decisions which occur in different contexts can
be given different heuristic information, so that the search algorithm
can respond to the changing state of the partial plan during search.
For variables, this context is a description of the token the variable
belongs to.  For tokens, the context includes the token itself, and a
description of the token's origins, be it another token or as part of
the initial state.  Token descriptions are given as {\em token types};
context information can also include {\em temporal relations}.  We
will discuss context more below.

It is important to make a point about heuristics.  What we have
described above is the type of heuristic information which can be
expressed in RAP.  However, it is up to the designer of the search
algorithm to {\em use} the information and describe {\em how} it is
used.  As an example, consider the priority of a decision.  Are high
priority decisions more important, or low priority decisions?  This is
up to the designer of the search algorithm.  The sample planners
provided with RAP order decisions with high priority numbers first,
but this can be changed; search algorithms could even randomly sample
the available decisions using the priorities as a bias.  

Having said this much, we briefly describe the technical
implementation of heuristics.  Heuristic information is stored in a
{\em PlanHeuristic} object.  The PlanHeuristic object is constructed
before planning, and information in the PlanHeuristic is extracted and
used during planning.  The PlanHeuristic object only acts as a
database; it is up to another object to interpret the heuristics and
use the resulting information during the search for plans.  The
planner provided with RAP does this using the Planner Library, which
contains functions which order decisions and values according to the
directives retrieved from PlanHeuristic.  As an example, PlanHeuristic
stores elements of a set referring to different slot ordering
directives, but functions in the Planner Library actually sort the
slots.  For more information, the reader is referred to the appendix
on Sample Planner architecture, the Planner Library (PlanLib), and
PlanHeuristic.

\subsubchapter{The Heuristic Syntax}
Heuristics are specified for decisions in one of two ways.
The first method is to describe the {\em context} in which the
heuristic information applies.  For variables, this context is limited
to the {\em token type} of the predicate that the parameter belongs
to.  For tokens, the context includes the token type of the token
itself, and a specification of the token's origins.  A token
originates in the initial state, or as a subgoal of a master token
with a specified token type and a temporal relation.  The second way
to provide heuristic guidance is to specify {\em default} heuristic
information.  This information is automatically associated with any
decision for which an explicit context is not provided.

Currently, the syntax prohibits the specification of different
heuristic information for the same decision in the same context.
This restriction prevents the specification of a priority and value or
slot ordering information for the same decision, with the same
context, in two separate directives.  This restriction also
prohibits the specification of {\em overlapping} contexts when
providing heuristic information.  For variables, this means that two
specifications of heuristic information for the same parameter of the
same predicate or the same object variable can't have overlapping
token types provided as contexts.  For tokens, two specifications for
tokens originating in the initial state can't have overlapping token
types.  For tokens due to subgoals, the situation is a bit more
complex.  In this case, either the subgoal token types can't overlap,
the subgoal token types can overlap but the master token types can't
overlap, or both token types can overlap but the temporal relations
for the two heuristic specifications must be different.

Notice that this restriction prohibits certain types of heuristic
specifications.  For instance, consider the heuristics specifying the
priority of a token with a single parameter having two values.
Specifying a priority for the token in each of its two configurations
prevents the specification of a different priority when the parameter
variable has not taken on a single value; if the token appears free,
its priority will be the default token insertion priority.  
The implicit assumption is that heuristics are made when something
is known about the context in which the heuristic applies; if nothing
is known, then default heuristic is assumed to be good
enough for guidance.

The syntax permits two types of default heuristics to be specified. 
The first are defaults which allow users to specify only priority or
ordering information for decisions.  In these cases, the default
heuristic information is associated with the ``missing'' heuristic
directive.  For instance, a heuristic directive providing a priority
for a token insertion decision will result in the default slot order
heuristic also being associated with that token insertion decision. 
The second are default heuristics which are overridden by more precise
specifications.  A default entry is used to specify the priority for a
series of decisions related to a compatibility.  In particular, the
default heuristic declares priorities for all variables of a master
token, and any subgoal of that master token.  These defaults can be
overridden by more specific directives.  The functions which retrieve
priorities will first check the list of specific directives, and if no
match is found, will check the default directives.

In addition, the syntax permits abbreviations for specifying
heuristics for tokens.  The reason for this is that it is often
convenient to specify heuristics for tokens in many contexts
at once.  The syntax allows for the following abbreviations:
\begin{enumerate}
    \item Heuristics can be specified for a subgoal with a specified
    master and any temporal relation.
    \item Heuristics can be specified for a subgoal with any master
    and any temporal relation.
    \item Heuristics can be specified for a token no matter what it's
    origin.
\end{enumerate}

Care should be taken when using these abbreviations; it is easy to
specify overlapping heuristics with them, which will result in errors.  
Figure
\ref{abbr} shows how the various heuristic specifications are related.
\begin{figure}[btph]
\centerline{
\scalebox{0.65}{\epsffile{heuristic.abbrev.eps}}}
\caption{\label{abbr} Hierarchy of abbreviations for
token heuristics.}
\end{figure}

The rest of this section is organized as follows.  We will first describe
the syntax of some basic concepts, such as priorities, slot orders, temporal
relations, and token types.  Afterwards, we will show how to build complete
heuristic specifications.

A note on the type: {\em emphasized} symbols are non-terminals in the grammar,
{\tt typeface} are terminals.  

\subsubchapter{Indices and labels}
An {\em index} is an integer.  The index refers to the position of a parameter
to a predicate; indices begin at 1.  
A {\em label} is an alias for an index.  Labels are given
in the definition of predicates; see the DDL specification for more details.

\subsubchapter{Priorities}
A {\em priority} is a real number between 0 and $10^9$.  The semantics of
priorities are chosen by the implementer of the planner; see Planner Library
(PlanLib) documentation for more details.

\subsubchapter{Token Types}
Token types are used frequently when specifying heuristics for tokens.
The specification of a {\em TokenType} is

{\em predicate} {\tt(}{\em domain-spec domain-spec...domain-spec}{\tt )}

where {\em predicate} is the name of a predicate specified for the
model in question. A {\em domain-spec} is either *, {\tt Value}, an
{\em inteval-domain} or an {\em enumerated-domain}.  A * stands for
the full sort of the parameter variable.  Values are numbers or
elements of sorts, and are meant to represent domains of a single
value.  An interval domain is specified as follows:

{\tt [Value Value]}

while enumerated domains are specified    

{\tt \{Value Value ... Value\}}

Token type specifications can be abbreviated.  Since each predicate name
must be distinct, it is possible to omit some or all of the arguments
from token type specifications.  So, for instance, a token
Go(?from,?to,?rate) can be abbreviated as simply Go(), or, if it is necessary
to specify the value of the ?to argument but not the ?rate argument,
Go(*,Lake).  {\bf Note that JDF finds this sort of abbreviation pretty
confusing.}

See the documentation on Token Types, Domains, Sorts, and Values for more details.

\subsubchapter{TempRelTypes}

Temporal relations of {\em tempRelType} are currently limited to {\tt Other}, {\tt
Before} or {\tt After}.  {\tt Before} indicates that the context in which a 
heuristic applies requires the master for a token be ordered before
the subgoal, and {\tt After} requires that the master be ordered
after the subgoal.  {\tt Other} is used for relations such as Contained
or Contained-by, where there is no absolute ordering of the two tokens
in question.

\subsubchapter{Value Order}
Value orders are specified {\tt (}{\em Value Value ... Value}{\tt)}.
Each value must be a member of the sort specified for the relevant
variable; see the documentation on Sorts and Values for more details.


\subsubchapter{SlotOrder}
The {\tt em slot-order} heuristics for tokens are specified as
follows:\\ {\tt(}{\em primary-order}{\tt)} or {\tt(}{\em primary-order 
secondary-order}{\tt)}.

The {\em primary-order} is one of the following: {\tt none, full,
empty, full empty, empty full}.\\ The optional {\em secondary-order}
is one of the following: {\tt near, early, late, early\_first\_only, near\_closest\_only}.
%where primary order is a
%list containing the keywords {\tt full} and {\tt empty} or the single
%keyword {\tt none}, and the secondary order is one of the keywords
%{\tt early, late, near}.  The primary slot order can contain only one
%keyword, and must contain at least one keyword \footnote{We may lift
%this restriction later.}.  The secondary order is optional.
The primary order specifies the relative ordering of full and empty
slots.  The secondary order refers to a tie-breaker ordering on top of
the primary directive.  {\tt early} specifies that slots should be
ordered by how close they are to the start horizon, {\tt late}
specifies that slots should be ordered by how close they are to the
end horizon, and {\tt near} specifies that slots should be ordered by
how close they are to the master token which spawned the subgoal.  
The distance between two slots is defined formally as the
distance between the earliest start times of the slots; i.e. if $A$
and $B$ are the slots, and $e(s_A)$ and $e(s_B)$ represent the
earliest start times for the slots, then $d(A,B)=e(s_A)-e(S_B)$
\footnote{ The astute reader will note that this is NOT a metric,
since $d(A,B) = -d(B,A)$.}.  The slot ordering is accomplished by
computing the distance between the slot that the master is inserted on
and the possible slots where the subgoal might be inserted.  
The
keyword {\tt early-first-only} results in consideration of only the
earliest slot on the timeline, and the keyword {\tt near-closest-only}
results in consideration of only the slot closest to the master token
but occuring temporally before the master.  Consequently, {\tt near} and
{\tt near-closest-only} can't be specified as the slot order for
tokens whose context lacks a master token specification.

It should be noted that some slot ordering directives 
result in {\em incomplete} heuristics.  That is, they prevent
consideration of certain slots; in some cases, plans may exist
employing these slots, but the use of these heuristics will result in
these plans being ignored by the planner, and in some cases may prevent
any legal plan from being found.
These slot orders are: {\tt (full), (empty), (full early\_first\_only)} 
or {\tt (full near\_closest\_only)}. 

\subsubchapter{Default priorities}
The heurisitics file permits the specification of default priorities
and slot orders; no default value order for variables is permitted.
These defaults must appear at the beginning of the heuristics file.
These are specified as follows:

\begin{tabbing}
========================\====\====\====\====\kill
{\tt Default\_Slot\_Order}        \>      {\em slot-order} \\
{\tt Default\_Token\_Priority}    \>      {\em priority}\\
{\tt Default\_Variable\_Priority} \>      {\em priority}
\end{tabbing}

The heuristics file can also contain default priorities for 
the variables and subgoals of master tokens with a designated
token type. These are specified as follows:
 
\begin{tabbing}
=======================\===========\========\========\========\====\kill
{\tt Default\_Compatibility\_Priority}\>    {\em TokenType} \> {\em priority}
\end{tabbing}

A specification of this type means that variable binding decisions
stemming from a token with the given token type will have the default
priority, and subgoals of a master with the given token type will 
have the default priority, {\em unless} there are specific heuristics
which override the default.  

\subsubchapter{Token Heuristics}
%Token heuristics come in several flavors.  The simplest token heuristics ignore all
%contextual information, such as whether the token existed in the initial state or
%was derived as a subgoal, what the master token type is for subgoals, and so on.
%More elaborate heuristics specify this contextual information, while the most
%sophisticated include information about the temporal relation between the master
%token type and the subgoal.  
Token heuristics are presented as follows.  We first describe the syntax
for heuristics where the full context is given in the specification.
Next, we describe syntax for the abbreviated specifications.

\subsubsubchapter{Full Context Specifications}
The heuristic specification for a token in the initial state or created by a 
generator is: 

\begin{tabbing}
===========\===========\========\========\========\====\kill
{\tt [Initial\_Token} \>    {\em TokenType}{\tt]} \> {\em priority} \> {\em slot-order}\\
{\tt [Initial\_Token} \>    {\em TokenType}{\tt]} \> {\em slot-order}\\
{\tt [Initial\_Token} \>    {\em TokenType}{\tt]} \> {\em priority}\\
\end{tabbing}

Heuristics for slave tokens dependent on a temporal
relationship to a token type are specified as follows.  In these
specifications, the first token type specified is the master token
type, while the second is the subgoal token type:

\begin{tabbing}
========\===========\===========\========\========\========\====\kill
{\tt[}{\em TokenType} \> {\em tempRelType} \>    {\em TokenType}{\tt]} \> {\em priority} \> {\em slot-order}\\
{\tt[}{\em TokenType} \> {\em tempRelType} \>    {\em TokenType}{\tt]} \> {\em slot-order}\\
{\tt[}{\em TokenType} \> {\em tempRelType} \>    {\em TokenType}{\tt]} \> {\em priority}\\
\end{tabbing}

\subsubsubchapter{Abreviated Specifications}

The heuristic specification for a subgoal token of a specific master
token type is specified as follows.  In these specifications, the
first token type specified is the master token type, while the second
is the subgoal token type.  Recall that this is an abbreviation for
three heuristics directives, one for each temporal relation possible
between the master and the slave.

\begin{tabbing}
========\====\===========\========\========\========\====\kill
{\tt[}{\em TokenType} \>  {\tt Any} \>    {\em TokenType}{\tt]} \> {\em priority} \> {\em slot-order}\\
{\tt[}{\em TokenType} \>  {\tt Any} \>    {\em TokenType}{\tt]} \> {\em slot-order}\\
{\tt[}{\em TokenType} \>  {\tt Any} \>    {\em TokenType}{\tt]} \> {\em priority}\\
\end{tabbing}



The heuristic specification for a subgoal token of {\em any} master is
specified as follows.  Note that this is an abbreviation for a series
of heuristic specifications, one for each possible master and each
possible temporal relation between the subgoal and the master.

\begin{tabbing}
========\===========\========\========\========\====\kill
{\tt[Subgoal} \>    {\em TokenType}{\tt]} \> {\em priority} \> {\em slot-order}\\
{\tt[Subgoal} \>    {\em TokenType}{\tt]} \> {\em slot-order}\\
{\tt[Subgoal} \>    {\em TokenType}{\tt]} \> {\em priority}\\
\end{tabbing}


The heuristic specification for a slave token where the heuristic
ignores contextual information is as follows.  Note that this is an
abbreviation for a series of heuristic specifications, one for each
possible master and each possible temporal relation between the
subgoal and the master, and an additional specification covering the
appearance of this token type in the initial state as well.

\begin{tabbing}
===========\===========\========\========\========\====\kill
{\tt [Free\_Token} \>    {\em TokenType}{\tt]} \> {\em priority} \> {\em slot-order}\\
{\tt [Free\_Token} \>    {\em TokenType}{\tt]} \> {\em slot-order}\\
{\tt [Free\_Token} \>    {\em TokenType}{\tt]} \> {\em priority}\\
\end{tabbing}


\subsubchapter{Variable Heuristics}
Specification of heuristics for parameter variables is as follows (in these cases,
{\em index} can be replaced with {\em label}):

\begin{tabbing}
========\=========\===========\========\========\========\====\kill
{\tt[}{\em tokenType} \> {\em index}{\tt]} \> {\em priority} \> {\tt(}{\em value-order}{\tt)}\\
{\tt[}{\em tokenType} \> {\em index}{\tt]} \> {\em priority} \\
{\tt[}{\em tokenType} \> {\em index}{\tt]} \> {\tt(}{\em value-order}{\tt)}\\
\end{tabbing}

Specification of heuristics for object variables is as follows:

\begin{tabbing}
========\============\==============\========\========\========\====\kill
{\tt[}{\em tokenType}{\tt]} \> {\em priority} \> {\tt(}{\em value-order}{\tt)}\\
{\tt[}{\em tokenType}{\tt]} \> {\em priority} \\
{\tt[}{\em tokenType}{\tt]} \> {\tt(}{\em value-order}{\tt)}\\
\end{tabbing}

Specification of variables which should not be bound by the planner are as follows
(note that only a predicate name is required, not a full token type):
\begin{tabbing}
========\=========\===========\========\========\========\====\kill
{\tt No\_Branch }\> {\em predicate} \> {\em index}\\
{\tt No\_Branch}\> {\em predicate}\\
\end{tabbing}


\subsubchapter{Examples}
In order to make the notion of heuristics somewhat more concrete, 
in this section we provide examples of heuristics specifications.
We begin with a single compatibility as a motivating example;
refer to the section of the manual on DDL for more information.
This compatibility
gives rise to several variables and tokens which will manifest as
decisions to be made by a search algorithm.  In order to guide the
search, we will have to express heuristics describing when we would
like the search to handle the decisions, and what order we want to try
the values of these decisions.  The compatibility we use follows:

\begin{tabbing}
==\==\==\==\==\=====================\====\====\====\====\kill
(Define\_Compatibility\\
\>  (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>\>      ((F\_and\_P\_Idle ({\em ?before}))))\\
\>    :duration\_bounds [1 \_plus\_infinity\_]\\
\>    :compatibility\_spec\\
\>  (AND\\
\>\>   ({\em ?before}  OR\\
\>\>\>   ({\em FP\_LO\_Bef} met\_by (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>\>\>\>        ((F\_and\_P\_Observation\_LO (?\_any\_value\_ ?\_any\_value\_ ?\_any\_value\_)))))\\
\>\>\>    ({\em FP\_HI\_Bef} met\_by (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>\>\>\>         ((F\_and\_P\_Observation\_HI (?\_any\_value\_ ?\_any\_value\_ ?\_any\_value\_))))))\\
\>   )\\
)\\
\end{tabbing}
This compatibility's master contains only a single variable, which is
a discrimination variable which controls the disjunction that the
compatibility expresses.  We have called the discrimination variable
{\em ?before}, and assumed that it has values {\em FP\_LO\_Bef} and
{\em FP\_HI\_Bef}.  If this variable takes on value {\em FP\_LO\_Bef},
then the F\_and\_P\_Idle token is to be met by an
F\_and\_P\_Observation\_LO token, and so on.

We shall begin with some simple heuristics for variable decisions which might
arise from this compatibility.  For instance, the heuristic specification
\begin{tabbing}
=============\=====\=================\==============\========\========\====\kill
{\tt[F\_and\_P\_Idle(*)} \> {\tt ]} \> {\tt 10} \\
\end{tabbing}
indicates that inserting a token with the F\_and\_P\_Idle predicate should
have priority 10, but no value order is specified.  Notice that this value applies
no matter what value the parameter of the F\_and\_P\_Idle has taken on.  We
can specify different priorities for different contexts; in this case,
the context corresponds to values of the parameter of the token.  Consider
the following heuristics:
\begin{tabbing}
=================\=====\========\==============\========\========\====\kill
{\tt[F\_and\_P\_Idle(FP\_LO\_Bef)} \> {\tt 1]} \> {\tt 10} \\
{\tt[F\_and\_P\_Idle(FP\_LO\_Aft)} \> {\tt 1]} \> {\tt 8} \\
\end{tabbing}
This means that if the F\_and\_P\_Idle token's parameter is restricted
to FP\_LO\_Bef then the priority of inserting the token is 10, and if
the parameter is restricted to FP\_LO\_Aft then the priority is 8. 
These heuristics prefer to insert these tokens at different times
during search according to their context.

Notice that there is an interesting issue with regard to specifying
context for heuristics.  In the above example, we have assumed that
the parameter of the F\_and\_P\_Idle is bound before the token
insertion takes place.  What about when the token hasn't had its
parameter bound yet?  In this case, the token priority will be
whatever the default free token priority is.  Currently, there is no
facility to specify heuristics which distinguish between these 
three cases.

Suppose we wanted to specify a heuristic which preferred that the
search try and place a F\_and\_P\_Observation\_LO token immediately
before the F\_and\_P\_Idle token.  This is done by putting a value
order on the {\em ?before} variable.  We can implement the value
ordering as follows:
\begin{tabbing}
============\=====\=================\==============\========\========\====\kill
{\tt[F\_and\_P\_Idle(*)} \> {\tt 1]} \> {\tt (FP\_LO\_Bef)} \\
\end{tabbing}
indicates that the value FP\_LO\_Bef should be tried before any other value.  
Note that since FP\_LO\_Bef
Since
there is only one value, this gives us the required value ordering.  Alternatively,
we can enumerate all of the values in the value ordering, as follows:
\begin{tabbing}
============\=====\=================\==============\========\========\====\kill
{\tt[F\_and\_P\_Idle(*)} \> {\tt 1]} \>{\tt (FP\_LO\_Bef FP\_LO\_Aft)} \\
\end{tabbing}
Notice that the previous two directives provide the value ordering only, and
do not specify the priority for this variable.  If we wanted to specify both
priority and value ordering information, we would need a single directive,
such as 
\begin{tabbing}
============\=====\=====\=====\========\========\====\kill
{\tt[F\_and\_P\_Idle(*)} \> {\tt 1]} \> {\tt 10} \> {\tt (FP\_LO\_Bef FP\_LO\_Aft)} \\
\end{tabbing}

Now let us turn to the specification of token heuristics.  
We will begin with the fully grounded heuristics for this compatibility, then 
discuss how to abbreviate these heuristics.  A specification of the form
\begin{tabbing}
==========\==============\=================\==============\========\========\====\kill
{\tt [Init\_Token} \> {\tt  F\_and\_P\_Idle(*)]} \> {\tt 10} \\
\end{tabbing}
indicates that an F\_and\_P\_Idle token in the initial state has a priority of 10.
If we want to elaborate on this with a slot ordering heuristic requiring that such
tokens only be inserted onto full slots, in any order, we would do the following:

\begin{tabbing}
==========\==============\======\========\========\========\====\kill
{\tt [Init\_Token} \> {\tt  F\_and\_P\_Idle(*)]} \> {\tt 10} \> {\tt (full)}\\
\end{tabbing}

To express a fully grounded heuristic for a token which represents a subgoal, 
remember that we need to identify the full context; the master token type, the
temporal relation, and the subgoal token type.  Since the compatibility we
are using as an example has the F\_and\_P\_Idle token as the master, let's
look at a heuristic for a subgoal, such as

\begin{tabbing}
============\========\======================\==============\========\========\====\kill
{\tt[F\_and\_P\_Idle(*)} \> {\tt Before} \> {\tt  F\_and\_P\_Observation\_LO(* * *)]} \> {\tt 10} \\
\end{tabbing}

This heuristic says that if an  F\_and\_P\_Idle token leads to a free
F\_and\_P\_Observation\_LO subgoal token constrained to appear after it,
the priority of inserting the F\_and\_P\_Observation\_LO is 10.  
If we wanted to specify a slot ordering heuristic for this token indicating
that we should first try full slots, then empty slots, and always prefer
to put the token as close to the master token as possible, we would do so like
this:
\begin{tabbing}
===========\=======\=======================\===\========\========\====\kill
{\tt[F\_and\_P\_Idle(*)} \> {\tt Before} \> {\tt  F\_and\_P\_Observation\_LO(* * *) ]} \> {\tt 10}  \> {\tt (full empty, near)}\\
\end{tabbing}

We will now demonstrate how some of the abbreviations work.
Suppose we modify the compatibility, to permit F\_and\_P\_Observation\_LO
tokens to come either before or after F\_and\_P\_Idle tokens:

\begin{tabbing}
==\==\==\==\==\=====================\====\====\====\====\kill
(Define\_Compatibility\\
\>  (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>\>      ((F\_and\_P\_Idle ({\em ?before, ?after}))))\\
\>    :duration\_bounds [1 \_plus\_infinity\_]\\
\>    :compatibility\_spec\\
\>  (AND\\
\>\>   ({\em ?before}  OR\\
\>\>\>   ({\em FP\_LO\_Bef} met\_by (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>\>\>\>        ((F\_and\_P\_Observation\_LO (?\_any\_value\_ ?\_any\_value\_ ?\_any\_value\_)))))\\
\>\>\>    ({\em FP\_HI\_Bef} met\_by (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>\>\>\>         ((F\_and\_P\_Observation\_HI (?\_any\_value\_ ?\_any\_value\_ ?\_any\_value\_))))))\\
\> \> ({\em ?after}  OR\\
\>\>\>   ({\em FP\_LO\_Aft} meets (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>\>\>\>        ((F\_and\_P\_Observation\_LO (?\_any\_value\_ ?\_any\_value\_ ?\_any\_value\_)))))\\
\>\>\>    ({\em FP\_HI\_Aft} meets (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>\>\>\>         ((F\_and\_P\_Observation\_HI (?\_any\_value\_ ?\_any\_value\_ ?\_any\_value\_))))))\\
\>   )\\
)\\
\end{tabbing}

Now we could have specifications for occurences of F\_and\_P\_Observation\_LO both 
before and after F\_and\_P\_Idle.  But suppose we didn't care about the temporal
relationship when specifying the priorities.  We can abbreviate 
\begin{tabbing}
=============\=======\=======================\===\========\========\====\kill
{\tt[F\_and\_P\_Idle(* *)} \> {\tt Before} \> {\tt  F\_and\_P\_Observation\_LO(* * *) ]} \> 10\\  
{\tt[F\_and\_P\_Idle(* *)} \> {\tt After} \> {\tt  F\_and\_P\_Observation\_LO(* * *) ]} \> 10\\  
\end{tabbing}

as

\begin{tabbing}
=============\=======================\===\========\========\====\kill
{\tt[F\_and\_P\_Idle(* *)} \> {\tt Any} {\tt  F\_and\_P\_Observation\_LO(* * *) ]} \> 10\\  
\end{tabbing}

Now, suppose further that F\_and\_P\_Observation\_LO subgoals can be created by
another compatibility with a predicate, say, F\_and\_P\_Init.  (For brevity, we won't
write the compatibility for this new predicate.)  Suppose further that, when expressing
heuristics for F\_and\_P\_Observation\_LO, we do not care whether it is a subgoal of
an F\_and\_P\_Init or an F\_and\_P\_Idle token; all that we are concerned with is that
all F\_and\_P\_Observation\_LO tokens which are subgoals (as opposed to ones in the initial
state) have the same priority.  We write an abbreviated specification as follows:
\begin{tabbing}
=============\=======================\===\========\========\====\kill
{\tt [Subgoal} \> {\tt  F\_and\_P\_Observation\_LO(* * *) ]} \> 10\\  
\end{tabbing}

Finally, if we don't even care to distinguish F\_and\_P\_Observation\_LO tokens
generated as subgoals from ones generated in the initial state, we can abbreviate
even further, and write 

\begin{tabbing}
=============\=======================\===\========\========\====\kill
{\tt [Free\_Token} \> {\tt  F\_and\_P\_Observation\_LO(* * *) ]} \> 10\\  
\end{tabbing}

{\bf Examples of erroneous specifications?}

\subsubchapter{Classical Planning Algorithms and RAP}
There are two classical search algorithms which are commonly used in
planning in the STRIPS domain.  The first is progression, or
forward-chaining search.  In this algorithm, actions are taken to
modify the initial state repeatedly until the goal is reached.
Heuristics for forward search are designed to choose the next action
or actions in the plan to progress towards the goal state.  One
example of this is A* with admissible heuristics.  Admissibility
guarantees that the first path from the initial state to the solution
is (one of) the shortest paths.

The second classical planning algorithm is goal-regression search.
In this form of search, the idea is to begin with the goals, and 
search backwards, finding actions which make the goals true, then
establishing the preconditions of those actions as the new goals.
Heuristics for backwards search are designed to correctly pick
the actions which achieve the goals in such a way as to move closer
to having the inital state established.  An example of a regression
planner is UCPOP.

\subsubsubchapter{Representation, Models and Initial States}
Unlike other planners and planning paradigms, RAP represents planning
problems as Dynamic Constraint Satisfaction Problems (DCSP)s.  The
planning algorithm, then, is solving a DCSP; it has no notion of how
variables correspond to parts of subgoals.  Also unlike other planning
approaches, RAP usually employs fully symmetric domain axioms.  That
is, if state A can be followed by state B, then there will be domain
axioms stating that A can meet B, and that B can be met by A.  These
fully symmetric axioms are necessary because otherwise the planning
process may not work properly.  Suppose that the axiom that B was met
by A was not in place as part of the model, and suppose that some other
state leads to state B.  There may be no subgoal stating that B must
be preceeded by A, and consequently the planner may find an invalid
plan.

As a result of this generality, it is possible to write planners and
specify heuristics which lead to either forward or backward
search-like behavior, as well as many other types of search besides.
However, there are a number of subtleties involved in making this work
properly.  One of these subtleties involves the specification of
heuristics.  Currently, heuristics are stored in a PlanHeuristic
object, and enforced using utilities in Planner Library.  These
heuristics can specify a limited form of dynamic variable and value
ordering heuristics.  The dynamicity comes from the specification of a
context in which the heuristics apply.  For instance, the priority of
inserting a token can be a function of what master token led to that
token's creation, and more importantly, the temporal relationship
between the master and the slave.  The heuristics play an important
role in enforcing forward or backwards search.

A second factor involves initial states and goals.  In classical
planning, ``forward'' search refers to planning from the initial state
``towards'' the goals by instantiating actions whose preconditions are
met.  ``Backwards'' search refers to planning from the goals
``towards'' the initial state, by selecting actions which establish
unjustified propositions.  In RAP, forward and backward search refer
to the direction in which timelines are expanded.  Forwards search can
be seen as expanding timelines from the start horizon towards the end
horizon, while backwards search can be seen as expanding timelines
from the end horizon towards the start horizon.  Normally, we assume
that there are tokens at the start and end of timelines, and these
play the role of initial and final states.  While this is not
strictly necessary, it helps preserve the analogy between the
two paradigms.

\subsubsubchapter{RAP Heuristics for Classical Planning}

Because of symmetric domain axioms, establishing the proper direction 
of plan expansion is done by choosing the correct priorities for 
free tokens with certain contexts.
Recall that this context can incorporate the
master token type and temporal relationship between the master and the
subgoal.  Consider the following compatibilities, which demonstrate
symmetry:
\begin{tabbing}
==\==\==\==\==\=====================\====\====\====\====\kill
(Define\_Compatibility\\
\>  (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>\>      ((F\_and\_P\_Idle ({\em ?before}))))\\
\>    :duration\_bounds [1 \_plus\_infinity\_]\\
\>    :compatibility\_spec\\
\>  (AND\\
\>\>   ({\em ?before}  OR\\
\>\>\>   ({\em FP\_LO\_Bef} met\_by (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>\>\>\>        ((F\_and\_P\_Observation\_LO (?\_any\_value\_ ?\_any\_value\_ ?\_any\_value\_)))))\\
\>\>\>    ({\em FP\_HI\_Bef} met\_by (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>\>\>\>         ((F\_and\_P\_Observation\_HI (?\_any\_value\_ ?\_any\_value\_ ?\_any\_value\_))))))\\
\>   )\\
)\\


(Define\_Compatibility\\
\>  (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>\>     ((F\_and\_P\_Observation\_LO (?id ?data-rate ?length))))\\
\>    :duration\_bounds [1 \_plus\_infinity\_]\\
\>    :compatibility\_spec\\
\>    (met\_by (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>        ((F\_and\_P\_Idle ))))\\
\>    (meets (SINGLE ((DNP\_Science Fields\_and\_Particles ))\\
\>\>        ((F\_and\_P\_Idle ))))\\
)\\
\end{tabbing}

In this case, the F\_and\_P\_Idle and F\_and\_P\_Observation\_LO
tokens will generate eachother during search.  Preserving the proper
directionality of search will require specifying priorities for
insertion which ensure that the proper token is inserted.  (Note that
there is an implied compatibility for F\_and\_P\_Observation\_HI, but
it has been omitted as it isn't necessary for the example.)  Let us
make the following assumptions: first, search is conducted by a
backtracking planner.  Second, priority is used to perform variable
ordering, and finally, tokens with higher priority are ordered before
tokens with lower priority.  The following priorities result in 
forward search:

\begin{tabbing}
=============\=======\=======================\===\========\========\====\kill
{\tt[F\_and\_P\_Idle(*)} \> {\tt Before} \> {\tt  F\_and\_P\_Observation\_LO(* * *) ]} \> 10 \\
{\tt[F\_and\_P\_Idle(*)} \> {\tt After} \> {\tt  F\_and\_P\_Observation\_LO(* * *) ]} \> 0 \\
=======================\=======\=============\===\========\========\====\kill
{\tt[F\_and\_P\_Observation\_LO(* * *)} \> {\tt Before} \> {\tt  F\_and\_P\_Idle(*)]} \> 10 \\
{\tt[F\_and\_P\_Observation\_LO(* * *)} \> {\tt After} \> {\tt  F\_and\_P\_Idle(*)]} \> 0 \\
{\tt[F\_and\_P\_Observation\_LO(* * *)} \> {\tt 1]} \> 10 \\
\end{tabbing}

Recall that the syntax specifies the master token type, the temporal
relation, the subgoal (being the free token which the planner must
eventually do something about), and the priority.  The temporal
relation indicates the relation between the master and the slave; {\tt
F\_and\_P\_Idle Before F\_and\_P\_Observation\_LO} means that the free
F\_and\_P\_Observation\_LO token is constrained to occur after the
F\_and\_P\_Idle, which has already been inserted into the plan.  By
ensuring that the priority of free subgoals constrained to occur
after their masters are higher than subgoals occuring before their
masters, we ensure that search proceeds in a forward direction.
As an additional point, we must bind the discrimination variable
of the F\_and\_P\_Idle  before inserting the tokens in the
``backwards'' direction, because this is necessary to continue
generating tokens in the forward direction.

Implementing backwards search is also simple; we only need to specify
that subgoals occuring before their masters have higher priority than
subgoals occuring after their masters.  The full specification of
backwards search priorities for this example would look like this:

\begin{tabbing}
=============\=======\=======================\===\========\========\====\kill
{\tt[F\_and\_P\_Idle(*)} \> {\tt Before} \> {\tt  F\_and\_P\_Observation\_LO(* * *) ]} \> 0 \\
{\tt[F\_and\_P\_Idle(*)} \> {\tt After} \> {\tt  F\_and\_P\_Observation\_LO(* * *) ]} \> 10 \\
=======================\=======\=============\===\========\========\====\kill
{\tt[F\_and\_P\_Observation\_LO(* * *)} \> {\tt Before} \> {\tt  F\_and\_P\_Idle(*)]} \> 0 \\
{\tt[F\_and\_P\_Observation\_LO(* * *)} \> {\tt After} \> {\tt  F\_and\_P\_Idle(*)]} \> 10 \\
{\tt[F\_and\_P\_Observation\_LO(* * *)} \> {\tt 1]} \> 10 \\
\end{tabbing}

This example is somewhat complex, because F\_and\_P\_Observation\_LO can
be sandwiched by F\_and\_P\_Idle tokens, and vice versa.  Thus, we needed
to specify four priorities.  If there are disjunctions, even more care must
be taken to capture all possible forward directions for search.
In addition, if there are disjunctions for both predecessor and successor
tokens, then the disjunction variables must also be assigned priorities
appropriately.  In the above example, the variable {\em ?before} is used to
choose what token appears before an F\_and\_P\_Idle. 



\begin{figure}[btph]
\centerline{
\scalebox{0.65}{\epsffile{searchdirection.eps}}}
\caption{\label{searchdir} }
\end{figure}

%%% AKJ: We'll stop here for the time being; might want to separate
%%% appendices and other advanced information


\end{document}


\subchapter{Adding Constraint Procedures}
%=======================================
%=======================================

%% AKJ: Write



\subchapter{Building Planners}
%============================
%============================


The RAP system is organized in such a way that designers can build their
own planners.  This chapter contains a brief introduction
on how to build planners which use RAP. 

\subsubchapter{Introduction}

The chapter is organized as follows.  We first discuss a few concepts
which designers should be familiar with already if they have used RAP,
but which are particularly important when building planners.  
Next we discuss what it means to do planning in RAP.  
We then
discuss the modules of RAP which are most critical to understand when
building planners.  The modules are organized in a hierarchical
fasion, so that planners need only use a few modules directly.  A
summary of each module is given below, after which we discuss in more
detail how these modules are used to assemble planners.  Notice that
we do not list one module for each concept, because the mapping is
not perfect, and because some concepts are implemented with modules
which are not a critical part of the interface.  We first summarize
each module, then discuss modules in more detail as we show how they
function in a planner architecture.

In this chapter the reader will notice that many times we have capitalized
words such as Token, and sometimes we have occurences of words which
are both capitalized and uncapitalized, such as Value.  When a word is
capitalized, it refers to an instance of a class which is defined in
RAP.  When the same word is not capitalized, it refers to an intuitive
concept.  Value is most often (ab)used in this way, although list and
set are both capitalized and uncapitalized.  We have tried to avoid this as much
as possible, and we hope it doesn't cause undue confusion.  

\subsubchapter{Concepts}
\begin{description}
    \item[Attribute and Timeline]  An attribute is a state of the world in which
    the planner operates.  A Timeline is the sequence of values the attribute takes
    on at any given instant during planning.
    \item[Token] A Token specifies a constraint on the values of a Timeline over
    an interval.  Value Tokens assert that the Timeline takes on a single value,
    while Constraint Tokens assert that the Timeline may take on any sequence
    of values, as long as those values are in a designated subset.  
    A free Token is one which hasn't been
    inserted onto a Timeline.  An inserted Token has one or both timepoints
    assigned to a Timeline.
    \item[Predicate] A Token consists of a Predicate and several parameters.
    One way to think of the predicate is as a function which performs some
    operation.  The value of a Token is given by the Predicate and the values
    of the parameters.
    \item[Index] The index of a parameter of a Predicate.
    \item[Timepoint] A timepoint is the start or end of a Token.
    \item[Slot] A slot is an interval on a Timeline defined by two timepoints
    with no timepoint occuring between them.
    Slots can be either empty, meaning no value Token is inserted on the slot,
    or full.
    \item[Variable] A Variable is either a parameter of a Token, a timepoint
    or a duration of a Token, or an object variable specifying a set of Timelines that
    a Token may be assigned to.
    \item[Domain] The Set of possible options for a Variable.
    \item[Value] A Value is a general class of possible values that a Variable
    can be assigned.
    \item[Id] A unique identifier for an object.  Most objects in RAP have Ids,
    and associated IdManagers keep track of the actual objects.  It is much safer and less
    expensive to pass Ids around than the objects they refer to, and this is almost
    universally the case when building planners.  For the duration of this
    chapter, it is assumed that when we discuss Predicates,
    Tokens or Variables, we actually mean their Ids.
    \item[TokenNetwork] The TokenNetwork maintains the list of free Tokens and 
    unbound Variables, in addition to keeping track of which Tokens have been
    assigned to which Timelines and any constraints resulting from these
    assignments. 
    \item[Decision] A decision is an encapsulating object that 
    can represent free Tokens and unassigned Variables.  Decision 
    objects also contain any heuristic information specified for the 
    decision in question.
    \item[PlanHeuristic] A PlanHeuristic is a database of heuristic information
    which specifies preferences for which Decision to make next, and which
    order to try the values for a Decision.
    \item[Priority] An indication of the importance of working on a Variable
    or Token.  Priorities are specified in the PlanHeuristic.
    \item[SlotOrder] A SlotOrder is a List of possible orderings to apply to the
    slots for a free Token decision.  SlotOrders are specified in the PlanHeuristic.
    \item[Consistent]  A plan is consistent if no constraints are violated by
    any assignment of Tokens or Values of Variables, and is inconsistent otherwise.
    \item[Valid] A Timeline is valid if there are no empty slots with a legal duration
    larger than 0, and is invalid otherwise.  A plan is valid if all of its Timelines
    are valid.
\end{description}

\subsubchapter{Planning with RAP}
To talk about planning in RAP, we first describe the state of RAP at
any given instant, then discuss how that state can change.  Basically,
a state of RAP is given by the set of Timelines, the Constraint
Network, the set of free Tokens, and the set of unbound Variables.
The Timelines indicate what Tokens have been assigned (i.e. a partial
plan), the free Tokens are those Tokens yet to be assigned to a
Timeline (i.e.  unsatisfied goals or justifications for actions in the
partial plan), and the unbound Variables represent aspects of Tokens
which have not yet been fully specified.  The Constraint Network, of
course, reflects the restrictions which affect what legal Values
Variables can take on, and where Tokens can be inserted.  The plan can
either be consistent or inconsistent, and valid or invalid.

Given this description, it is reasonably clear how the state of the
system can change.  Free Tokens can be assigned to Timelines, fully
inserted Tokens can be removed from Timelines, and Variables can be
bound and unbound.  Consequently, an RAP planner must be able to do
the following things:

\begin{itemize}
    \item Determine whether or not any free Tokens or unbound Variables remain.
    \item Decide which free Token or unbound Variable to work on.
    \item Retrieve slots for free Tokens or timepoints.
    \item Decide what slot to insert a free Token or timepoint into.
    \item Retrieve the Set of Values for a Variable.
    \item Decide what Value to assign to an unbound Variable.
    \item Determine that a complete, legal plan has been generated.  If the plan is 
    consistent and valid, there are no free Tokens and no unbound Variables,
    then the planning task is complete.
    \item Determine that an illegal plan (either inconsistent or invalid) has been
    generated.  This is an indication that something about the plan must be changed.
\end{itemize}

\subsubchapter{Modules and Interfaces}
The following modules provide the necessary interface to the rest of
RAP in order to enable planners to work properly.  Most of the
operations can be performed using the TokenNetwork.  While Tokens,
Variables, SlotInfo, Domains and Values are returned by the
TokenNetwork, they can be treated as first-class objects which are
either assigned or passed as parameters to other functions, and so we
will not discuss them in detail here.  Frequently, collections of
objects are returned in a container of one type or another, so we briefly
mention various important container classes.  Decisions 
are objects which can be used to more easily manipulate the output of
the TokenNetwork, and PlanHeuristic permits the specification of heuristics
for search.

\begin{description}
    \item[TokenNetwork] The TokenNetwork maintains the list of free Tokens and 
    unbound Variables, in addition to keeping track of which Tokens have been
    assigned to which Timelines and any constraints resulting from these
    assignments. 

    \item[Containers and Iterators] The TokenNetwork invariably returns collections
    of objects as either Lists or Sets.  Lists and Sets are frequently accessed using
    iterators.  The designer should refer to the documentation
    on Containers and understand the interface to these two container classes
    and how iterators are used to manipulate them.

    \item[Variable,Domain] A Variable is an object which contains
    all relevant information concerning an assignable choice point
    within the plan.  One of these pieces of information is the
    Domain, which contains the Set of Values that a Variable can
    take on.

    \item[Decision] An object representing either an unbound Variable or free Token,
    and all heuristic information specified for a decision of the relevant type.

    \item[PlanHeuristic] A database of heuristic information for Variable binding
    and Token insertion Decisions.  This includes priority information for use in
    choosing which Decision to make next, and either Variable or slot ordering for
    use in ordering the options for the Decision.    
\end{description}

\subsubchapter{TokenNetwork}
The TokenNetwork is the main interface a planner uses to communicate with the rest of
RAP.  TokenNetwork contains interface functions which:
\begin{itemize}
    \item Check whether the current plan is consistent and valid.
    \item Retrieve a List of free Value Tokens.
    \item Retrieve a List of Constraint Tokens with at least one uninserted timepoint.
    \item Retrieve a List of SlotInfo structures indicating where a Token may be inserted.
    \item Insert a Value Token onto a slot.
    \item Insert a Token's timepoint onto a slot.
    \item Remove a Token from a Timeline.
    \item Remove a Token timepoint from a Timeline.
    \item Retrieve a List of unbound Variables.
    \item Change the Domain of a Variable (i.e. assign and unassign the Variable).  
\end{itemize}

Notice that, with these functions alone, it is possible to perform
almost all of the functions required to write a planner.  For example,
checking whether the planner is finished is accomplished by the
following code fragment \footnote{This fragment of code and other
fragments in this document may not execute, as some details are left
unshown; they are meant only to demonstrate the concepts described in
the text.}:

\begin{tabbing}
====\====\====\====\====\====\====\====\====\====\====\kill
TokenNetwork\& toknet;\\
List$<$TokenId$>$ tokList;\\
List$<$VarId$>$ varList;\\
tokList=toknet.getFreeValueTokens();\\
varList=toknet.getUnderconstrainedVariables();\\
{\bf if}(\\
\> (varList.isEmpty()) \&\&\\
\> (tokList.isEmpty()) \&\&\\
\> (toknet.isConsistentAndValid() == {\bf true}))\\
\> \> {\bf return true}\\
\end{tabbing}

There are a few remaining details which are covered in the next
sections on SlotInfo and Variables, Domains and Values.

\subsubchapter{SlotInfo}
When inserting value Tokens or Token timepoints onto Timelines, the TokenNetwork requires
both the Token or timepoint Variable and a description of the slot which the Token
or timepoint is being inserted into.  The slot description is packages as a SlotInfo
object.

%When retrieving a List of slots for a Token, the designer has the choice of many different
%options.  The option which is specified tells the TokenNetwork how much work to perform
%up front when deciding where a Token can go.  For example, the designer can decide to ask
%for every slot on the Timeline.  Clearly, some of these slots will be impossible, but
%it will be up to the planner to attempt each slot in turn and discover that it will not
%work.  There are a number of other options, each of which forces the TokenNetwork to
%perform more and more stringent checks on the slots.  Refer to the documentation on
%TokenNetwork and Timeline for more details.

\subsubchapter{Variables, Domains and Value}
When a planner must assign a Value to a Variable, the planner must
first retrieve the legal Values that the Variable may take on.  This
is done by retrieving the current Domain of the Variable from the
Variable itself.  The Domain contains a Set of Values, and it is
frequently easiest to retrieve this Set from the Domain.  The planner
can then iterate through this Set, trying each Value in turn.

Assigning Values in RAP is accomplished by setting the Domain to
contain only a single Value.  One way to accomplish this is to set a
temporary Domain such that it contains only a single Value, then tell
the TokenNetwork to restrict the Domain of this Variable 
to contain only the values of the temporary Domain.
Since it is frequently the case that such changes of a Variable's
Domain need to be reversed, the TokenNetwork provides a function to
restore the Domain of Variables.

The following code fragment shows how all of these pieces work
together.  This fragment retrieves the Values for a Variable,
restricts the Domain of the Variable to each Value in turn, then
recursively calls a planner.  If the planner call returns with
failure, the full Domain of the Variable is restored.  The
documentation on Variable, Domain, and Set contain full descriptions
of the interface functions used in this code fragment.

\begin{tabbing}
====\====\====\====\====\====\====\====\====\====\====\kill
TokenNetwork\& toknet;\\
VarId variable;\\
Domain varDom,single;\\
Set values;\\
SetIterator$<$Value$>$ valueIt;\\
Value current;\\
varDom=variable$->$getDerivedDomain();\\
values=varDom.getMembers();\\
valueIt=values;\\
{\bf while} valueIt.isGood()\{\\
\> current=valueIt.item();\\
\> single.setToSingleton(current);\\
\> toknet.setVariableDomain(variable,single);\\
\> callPlanner(toknet);\\
\> // Assume that the call to the planner returns with failure\\
\> toknet.resetVariableDomain(variable);\\
\> valueIt.step();\\
\}\\
\end{tabbing}

\subsubchapter{PlanHeuristic}
A PlanHeuristic is an object which contains heuristic information
specified about the Tokens and Variables which the planner must assign.  
The PlanHeuristic can represent information about
the order in which the planner decides either what to work on
next (e.g. variable ordering) or what order to try assignments
(e.g. value ordering.)  This information is represented both
for Variables and Tokens.  Currently, PlanHeuristic only represents
static ordering information; we give a brief overview of this
information in the next section, but refer the reader to the documentation
on PlanHeuristic for more details.

Priorities are used to represent preferences about which Token to
attempt to insert or which Variable to bind next.  Lists of Values are
used to represent Value ordering for Variable assignments.  The
ordering of candidate slots for Tokens and Token timepoints is
currently handled using SlotOrder.  A SlotOrder is a label which
indicates the order in which slots should be tried.  PlanHeuristic
currently permits one of 20 SlotOrders to be associated with a Token
or timepoint.  These orders express preferences for full slots before
empty slots, and secondary slot ordering of earliest first, latest
first or nearest first.  Again, we refer the designer to the
PlanHeuristic documentation for details.

It is currently up to the planner to decide how to order the slots
which are retrieved from the TokenNetwork.  For example, the code
fragment below sorts the slots for a free Value Token according to the
following directive: All full slots should be tried before any empty
slots.  In the case of ties, slots should be sorted earliest-first.

\begin{tabbing}
====\====\====\====\====\====\====\====\====\====\====\kill
TokenNetwork\& toknet;\\
TokenId token;\\
List$<$SlotInfo$>$ retList,tempList;\\
ChangeListIterator$<$SlotInfo$>$ it;\\
SlotInfo temp;\\
int i,numSlots;\\
tempList=toknet.getSlots(token);\\
   
//The list is returned in earliest-first order.\\
//To ensure that all full slots occur first,\\
//traverse the list, putting the empty slots at the end\\
  
it=tempList;\\
numSlots=tempList.getLength();\\
for(i=1;i$<=$numSlots;i++)\{\\
\>     temp=it.item()\\
\>      if(toknet.isSlotEmpty(temp))\{\\
\> \>         it.deleteItemAndStep();\\
\> \>           tempList.pushLast(temp);\\
\>     \}\\
\>     else it.step();\\
\}\\
return tempList;\\
\end{tabbing}

Generally speaking, it is up to the writer of the planner to decide
how any information in the PlanHeuristic is actually used.
For instance, when deciding what the planner will work on next,
the designer can either pick the Token or Variable with the
largest Priority, or use the Priorities to bias a random selection
routine which determines what action the planner takes next.

\subsubchapter{Decisions}
With the functionality of TokenNetwork, Variable, Value, Domain
and the containers List and Set, it is possible to build a simple
planner.  However, such a planner is likely to be somewhat unwieldy,
in that the planner must retrieve Lists of unbound Variables, free
Value Tokens, and Constraint Tokens, then manipulate these
lists separately during planning.  Decisions are
objects which are ``wrapped'' around Variables and Tokens, providing
planners with a single type of object to manipulate.  

A Decision represents all pertinent information about all remaining
activities which the planner must complete before a plan is finished.
Part of this information is any heuristic guidance which might be
specified.  This heuristic information is present in the PlanHeuristic
object, described previously.  When a Decision is constructed, the
planner must retrieve information from the PlanHeuristic to insert
into the Decision.  For example, the code fragment below shows how
to construct Decisions for free Value Tokens.

\begin{tabbing}
====\====\====\====\====\====\====\====\====\====\====\kill

TokenNetwork\& toknet;\\
PlanHeuristic\& heur;\\
List$<$TokenId$>$ vtoks;\\
ListIterator$<$TokenId$>$ vit=vtoks;\\
List$<$Decision$>$ decs;\\
TokenId curtok;\\
Priority tokPriority;\\
SlotOrder tokOrder;\\
PredicateId tokPred;\\
Decision curDec;\\
{\bf while}(vit.isGood())\{\\
\>    curtok=vit.item();\\
\>    tokPred=toknet.getPredicateType(curtok);\\
\>    tokPriority=heur.getTokenInsertionPriority(tokPred);\\
\>    tokOrder=heur.getSlotOrder(tokPred);\\
\>    dec=Decision(curtok,tokPriority,tokOrder);\\
\>    decs.pushLast(curDec);    \\
\>    vit.step();\\
\>    \}\\
return decs;\\
\}
\end{tabbing}

\subsubchapter{Interfaces}
Designers can build many different planners using RAP.  However,
building planners using the interfaces to RAP directly may be somewhat
clumsy.  Doing so requires access to a few different modules.
Consequently, in the future there will be interfaces to RAP which
encapsulate much or all of the necessary functionality to build a
planner in one place.  The aim of such interfaces is twofold:
\begin{itemize}
    \item To centralize as much of the functionality required to build planners in one
    piece of code.
    \item To simplify the interface, and consequently the process of building 
    planners, by hiding some details from planner designers.
\end{itemize}

Constructing an interfaces which hides some of the details may make it
difficult or impossible to build certain classes of planners. 
However, the process of building planners supported by the interface
will, hopefully, be made much easier.

We have provided with the RAP system one example of such an interface.  Called
PlanLib, this interface is not a module so much as a collection of functions and
utilities which provide designers with the ability to construct chronological
backtracking-style planners.  Readers will find an overview of PlanLib in the
Appendix; for more details, refer to the PlanLib Interface Design Document.






\subchapter{Appendix: Changes from Classical RA Planner}
%=======================================================
%=======================================================

\subsubchapter{Domain Description Language}

In the classical RA planner, objects were specified as part of the
model.  The problem with this approach is that it prevents objects
from being dynamically generated.  As a result, objects are defined in
the initial state.  In classical RAP, objects were defineed with a
{\tt Define\_Object} directive.  This directive is still supported, but
rather than defining an object, it defines a subclass.  A warning is
issued when the {\tt Define\_Object} is used, as it serves no purpose
other than possibly generating modeling errors; it is there for
backwards compatibility.



\subchapter{Appendix: Planner Library}
%======================================
%======================================

The RAP system is organized in such a way that users can build their
own planners.  However, building a planner from scratch simply using the
interfaces to the Token Network, Model Manager, PlanHeuristic and other
modules may be somewhat daunting.  The modules which are provided with RAP can be easily
encapsulated in other modules which provide additional functionality, therby
providing a more convenient and intuitive interface with can be used to
build planners.  In this appendix we discuss one way of doing this,
which we have named PlanLib.

\subsubchapter{Introduction}
The Planner Library contains 
support for retrieving decisions from the Token Network, and ordering
those decisions according to any information which might be present
in the PlanHeuristic.  In addition, the Planner Library provides support
for identifying any ``forced'' decisions, i.e. those with either one or
no remaining choices.  Called {\em unit} decisions, these either 
reflect commitments which can be made without guessing, or indicate an
inconsistency, which requires reversing some earlier decision.
Finally, the Planner Library provides a single example of a dynamic
variable ordering heuristic.  This is an instance of the so-called
Minimum Values Remaining heuristic.

An important aspect of planning with RAP is a method for handling continuous
variables.  RAP does not support methods for searching continuous variables
such as conjugate gradient directly, and permitting branching search on
these variables will lead to planners which take infinite time.  Consequently,
the Planner Library supports specification of variables which should not be
assigned explicitly by the planner during search.  PlanLib functions which
return lists of decisions from the TokenNetwork accept a list of specifications
of these variables, and ensure that these variables are not returned
to the planner.


\subsubchapter{Interface}
In this section, we briefly describe the interface functions for PlanLib.  We only
provide an intuitive description; readers interested in more details should consult
the PlanLib Interface Design Document.

\begin{description}
\item[getDecisionsFromTokenNetwork]        
        This function returns a list of decisions from the TokenNetwork.  
    The list contains a Decision object for each
        free token and unbound variable in the TokenNetwork, unless the variable matches a specification
        given in the list of nonBranchSpecs.  Each Decision contains any heuristic information
        present in the PlanHeuristic which is associated with an unbound variable or token insertion decision
        of the appropriate type.  
        

\item[getPartitionedDecisionsFromTokenNetwork]        
        This function also retrieves decisions from the TokenNetwork.  However, the decisions are
    partitioned according to whether there are no values remaining, one value remaining or
    more than one values remaining for the planner to test.  The decisions are appended to lists
    which are passed as arguments to the function.  This function also returns a boolean
    value which indicates whether there are any decisions with no values remaining.  If there
    are any such decisions, then the return value will be false, and only the list of
    decisions with no values remaining will be non-empty.  Otherwise, the return value is true,
    and the lists of decisions with one or more than one value remaining may be non-empty.
    The decisions with one or no values remaining will not have any heuristic information in
    them.
       

\item[sortDecisionsByPriority]        
        This function sorts a list of Decisions by priority and returns the resulting sorted list of Decisions. 
        If  priorityOrderFlag==orderMaxFirst, then the list is returned sorted with decisions of
        maximum priority sorted first.  If priorityOrderFlag==orderMinFirst, then the list is
        sorted with decisions of minimum priority first.
        Ties are broken arbitrarily.


\item[getSlotsFromOrder]        
        This function returns a list of slots for a value token in order indicated by SlotOrder for the token. 
    The SlotOrder type is the internal representation used for the primary and secondary slot orders
    which were discussed in the chapter on Heuristics. 
        The order slots are returned depends on the value of SlotOrder;
        for a detailed description, see the PlanHeuristic documentation.  If an unknown slot order
        is passed to this function, an error will be generated.        

\item[getStartSlotsFromOrder]        
        Returns a list of slots for the start timepoint of a token in order indicated by SlotOrder for the token.
        The order slots are returned depends on the value of SlotOrder as described earlier in this document.  
        If an unknown slot order is passed to this function, an error will be generated.
        

\item[getEndSlotsFromOrder]        
        Returns a list of slots for the end timepoint of a token in order indicated by SlotOrder for the token.  
        The order slots are returned depends on the value of SlotOrder;
        for a detailed description, see the PlanHeuristic documentation.  If an unknown slot error
        is passed to this function, an error will be generated.
        

\item[getSlotNr]        
        Retrieves the nth slot from slotList.  If the index is too large (or too small!) an error will be
        generated.
       

\item[getUnitDecision]
        Returns a decision with either 1 or 0 remaining options (slots or values) remaining, or
        noDecision if no such decision exists.  No heuristic information is included in this decision.
        

\item[getUnitDecisionList]        
        Returns a list of decisions with one remaining value, or returns a list of one decision
        with no remaining values.  No heuristic information is included in this list of decisions.
        

\item[getDecisionsWithMinimumRemainingValues]        
        Returns those elements of the list of decisions passed as input with the minimum number
        of remaining choices.  The number of choices is the number of slots for a value token
        or constraint token timepoint decision, or alternately the number of values for a variable
        decision.  Decisions with the same number of choices are grouped arbitrarily.
        
\end{description}

\subsubsubchapter{A Sample Planner Using PlanLib}
The functions defined above can be used to construct the components of a planner.  For example, 
the top-level specification of a backtracking planner might look like this \footnote{This planner
is written recursively.  Consequently, it can't be used for non-chronological backtracking.
A planner written using a List or Vector to mimic the call stack can be turned into a non-chronological
backtracker, and may also be more efficient.}:
\newpage
\begin{tabbing}
====\====\====\====\====\====\====\====\====\====\====\kill
{\bf bool} buildPlan(ModelId\& model,TokenNetwork\& toknet,PlanHeuristic\& heur, int planDepth)\{\\
\> List$<$Decision$>$ openInsts;\\
\> Decision dec;\\
\> planDepth++;\\
\> {\bf if} (toknet.isProvenInconsistent()) \\
\> \> {\bf return false};\\
\> openInsts=getDecisionsFromTokenNetwork(toknet,heur);\\
\> {\bf if} (openInsts.isEmpty()==false)\{\\
\> \> dec=isUnitDecision(toknet);\\
\> \> {\bf if} (dec==noDecision)\{\\
\> \> \> openInsts=sortDecisionsByPriority(openInsts,orderMaxFirst);\\
\> \> \> dec=openInsts.getFirst();\\
\> \> \> {\bf if} (dec.isVariableBindingDecision())\{\\
\> \> \> \> {\bf return} bindVariable(model,toknet,heur,dec,planDepth);\\
\> \> \> {\bf else return} insertFreeValueToken(model,toknet,heur,dec,planDepth);\\
\> \> \> \}\\
\> \> \}\\
\> \}\\
\> {\bf else return true};\\
\}
\end{tabbing}

This planner is designed to handle only value tokens and variables.  The planner makes calls
to other functions which handle the loops over the possible values of the variables or the
possible slots for the value tokens.  These helper functions are the bindVariable
and insertFreeValueToken functions; they are given below.
\newpage

\begin{tabbing}
====\====\====\====\====\====\====\====\====\====\====\kill
{\bf bool} insertFreeValueToken\\
\> \> (ModelId\& model,TokenNetwork\& toknet,PlanHeuristic\& heur,Decision\& dec,int planDepth)\{\\
\>    TokenId tok;\\
\>    SlotOrder sorder;\\
\>    List$<$SlotInfo$>$ slots;\\
\>    SlotInfo curSlot;\\
\>    int numSlots;\\
\>    int i;\\
\>    tok=dec.getTokenId();\\
\>    sorder=dec.getSlotOrder();\\
\>    numSlots=toknet.getSlots(tok).getLength();\\
\>    {\bf for}(i=1;i$<=$numSlots;i++)\{ \\
\>\>        //SlotIds may have changed; get the list of slots again and\\
\>\>        //retrieve the next slot to try for insertion.\\
\>\>        slots=getSlotsFromOrder(toknet,tok,sorder);\\
\>\>        curSlot=getSlotNr(slots,i);\\  
\>\>        toknet.insertValueToken(tok,curSlot);\\
\>\>        {\bf if} (buildPlan(model,toknet,heur,planDepth)) \\
\>\> \>               {\bf return true};\\
\>\>        {\bf else} toknet.freeToken(tok);\\
\>\>    \}\\
\>    {\bf return false};\\
\}
\end{tabbing}
\newpage

\begin{tabbing}
====\====\====\====\====\====\====\====\====\====\====\kill
{\bf bool} bindVariable\\
\> \> (ModelId\& model,TokenNetwork\& toknet,PlanHeuristic\& heur,Decision\& dec,int planDepth)\{\\
\>    VarId variable;\\
\>    List$<$Value$>$ valueOrder;\\
\>    ListIterator$<$Value$>$ vit;\\
\>    Domain dom,single;\\
\>    Set$<$Value$>$ members;\\
\>    variable=dec.getVarId();\\
\>    valueOrder=dec.getValueOrder();\\
\>    vit=valueOrder;\\
\>    dom=variable$->$getDerivedDomain();\\
\>    single=variable$->$getDerivedDomain();\\
\>    members=dom.getMembers();\\
\>    {\bf while}(vit.isGood())\{\\
\>\>        {\bf if}(members.hasMember(vit.item()))\{\\
\>\>\>          members.remove(vit.item());\\
\>\>\>          single.setToSingleton(vit.item());\\
\>\>\>          toknet.setVariableDomain(variable,single);\\
\>\>\>          {\bf if}(buildPlan(model,toknet,heur,planDepth))\\
\>\>\>\>                {\bf return true};\\
\>\>\>            {\bf else} toknet.resetVariableDomain(variable);\\
\>\>        \}\\
\>\>        vit.step();\\
\>    \}\\
\>    {\bf return false};\\
\}
\end{tabbing}
\newpage

Figure \ref{interface} shows which HSTS objects are accessed by each of the 
PlanLib functions and the sample planner functions described here.

\begin{figure}[btph]
\centerline{
\scalebox{0.65}{\epsffile{planner.interface.eps}}}
\caption{\label{interface} Interface from sample planner and PlanLib
functions to rest of HSTS.}
\end{figure}
\subsubsubchapter{Notes}
As it is currently implemented, PlanLib is a {\em library} of functions which
is designed to augment and simplify the interface to the rest of HSTS 
which is provided by the TokenNetwork.  Notice that the sample planner above
still requires a reference to the TokenNetwork to perform some functions,
such as checking consistency, retrieving lists of SlotInfo structures, and
so on.  Furthermore, the PlanLib functions must be passed references to the
TokenNetwork, ModelManager and PlanHeuristic in order to access them, which
means that the sample planner must carry these references with it.

In the future, we may replace PlanLib with an interface object which contains
all of these references, and completely insulates the planner from the other
objects in the system.  Such an interface would require functions which call
TokenNetwork functions such as consistency checks, but may abstract away other
functions in a manner similar to the PlanLib functions presented here.

A note concerning unit decisions is also in order.  In backtracking algorithms,
unit decisions are usually made without consulting any other heuristic information.
Because of the cost of retrieving heuristics from the PlanHeuristic structure,
at this time no heuristic information is included in unit decisions; the assumption
being that if the designer of a planner is asking explicitly for unit decisions,
they will 1) bind one if it exists without question, and b) since it is irrelevant
what order they are bound in, there is no point in comparing them to eachother,
since all should be taken care of before anything else is done.  






\subchapter{Appendix: Constraint Library}
%==============================
%==============================


\subsubchapter{Introduction}
The HSTS system incorporates a way to add new constraint procedures to the system.
This flexibility allows users of HSTS to create a framework to do reasoning with
any constraints that they require.  This also permits users to experiment with various
ways in which to enforce those constraints, by trading computation time for power
to reduce the domains of the variables involved in the constraints.  However, the
system comes with a library of constraints which are ready to use.  This document
describes those constraints, and gives some details about the reasoning which is
done by them.  For details on creating new constraints, the reader is referred to
the documentation on Procedural Constraints.
\subsubchapter{Concepts}

\begin{description}
  \item[Constraint:] A specification of which combinations of values
are valid, for a given set of variables.  Formally described as a set
of allowable tuples.
  \item[Scope:] The set of variables to which a constraint instance
applies to.
  \item[Domain:] A set of allowed values for a variable.
  \item[Sort:] A specification of a set of values, providing also
information about the semantics of this set.
  \item[Compatibility:] A restriction on the set of valid plans.
Compatibilities include temporal constraints and parameter constraints,
both of which are broken down into primitive constraints on variables
using the constraints which are included in the library.
  \item[Constraint Network:] The constraint network consists of variables
and constraints between them.  These objects are created by the token network
when tokens are created; this process includes both temporal constraints
and other constraints between variables which are derived from the compatibilities,
and temporal constraints specified at the token network.  The constraints
between these variables are all constraints which appear in the 
constraint library.
  \end{description}


\subsubsubchapter{Summary of Constraints}
We now give a brief summary of all the constraints which are provided
with the system. The bold keyword is the name used to specify the
constraint within the system, followed by a more intuitive name, a
mathematical representation of the constraint, and a description of
the permitted sorts for the parameters of the constraint.  The sort
description {\em numeric} is meant to represent parameters which can
be either integers or reals, and {\em parameter} means that the
parameter can have any underlying sort.  Note that in some cases, constraints
can accept a mix of numeric domains, while in other cases the sorts must
be identical; in the latter case, this is indicated explicitly.

Most of the constraints listed below are arithmetic constraints, and
accept parameters with real or integer sorts.  However, due to
difficulties with open intervals in computer systems, constraints
involving $<$ are defined only over the integers; constraints with
$\leq$ are defined for both reals and integers.  The reason is that we
can't represent open intervals, and have chosen not to use a tolerance
factor.  To understand this point, consider the constraint $x<y$ and
consider reducing the domain of $y$ so that it contains no values
smaller than the minimum value of $x$.  Now the minimum of $x$ can be
represented as a real number, but to enforce $x<y$, we would have to
make the minimum value of $y$ be $\min(x)+\epsilon$ as $\epsilon
\rightarrow 0$.  This number can't be represented, so we can't reduce
the domain of $y$ without reducing it too much.  With integers, this
isn't a problem, because we know that $\min(y)$ will be the integer
$min(x)+1$.  This also isn't a problem with $x\leq y$, because now
$y$'s domain can contain the value $\min(x)$.

\begin{description}
\item[eq]{Equality constraint (2 vars of same sort)}
\item[neq]{Disequality constraint (2 vars of same sort)}
\item[adiff]{Disequality constraint ($>$ 2  vars of same sort)}
\item[asame]{Equality constraint ($>$ 2 vars of same sort)}

\item[lt]{Less-than constraint (2 integers of same sort)}
\item[addlt]{Add-less-than constraint (3 integers of same sort)}

\item[leq]{Less-than-equal constraint (2 numerics of same sort)}
\item[addeq]{Add-equal constraint (3 numerics)}
\item[addleq]{Add-less-than-equal constraint (3 numerics)}

\item[addmuleq]{Add Multiply Equals constraint $x+y*r=z$  (4 numerics)}

\item[min]{Minimun comstraint (2 numerics of same sort)}
\item[allmin]{All-minimum constraint ($>$ 2 numerics of same sort)}
%\item[fallmin]{Flexible All-minimum constraint (flexible number of numerics)}

\item[max]{Maxmimum constraint (2 numerics of same sort)}
\item[allmax]{All-Maximum constraint ($>$ 2 numerics of same sort)}
%\item[fallmax]{Flexible All-Maximum constraint (flexible number of numerics)}

\item[condeq]{Conditional equals constraint (2 vars of same sort, 1 boolean)}
\item[condneq]{Conditional disequality constraint (2 vars of same sort, 1 boolean)}
\item[condadiff]{Conditional Disequality constraint ($>$ 2 vars of same sort)}
\item[condasame]{Conditional Equality constraint ($>$ 2 vars of same sort)}

\item[condlt]{Conditional Less-than constraint (2 integers of same sort, 1 boolean)}
\item[condaddlt]{Conditional Add-less-than constraint (3 integers, 1 boolean)}

\item[condleq]{Conditional Less-than or equal constraint (2 numerics of same sort, 1 boolean)}
\item[condaddeq]{Conditional Add-equal constraint (3 numerics, 1 boolean)}
\item[condaddleq]{Conditional Add-less-than-equal constraint (3 numerics, 1 boolean)}

\item[condmin]{Conditional minimun comstraint (2 numerics of same sort, 1 boolean)}
\item[callmin]{Conditional all-minimum constraint ($>$ 2 numerics ,of same sort 1 boolean)}

\item[condmax]{Conditional maxmimum constraint (2 numerics of same sort, 1 boolean)}
\item[callmax]{Conditional all-Maximum constraint ($>$ 2 numerics of same sort, 1 boolean)}

\item[or]{Logical or constraint ($>$ 2 booleans)}

\item[for]{Logical or constraint (flexible number of booleans)}
\item[fadiff]{Disequality constraint (flexible number of vars)}
\item[fasame]{Equality constraint (flexible number of vars)}

\item[card]{Cardinality constraint $z \leq x_1 \vee x_2 \vee...$  (arbitrary number of booleans and 1 integer)}
\item[cardeq]{Cardinality Equals constraint $z = x_1 \vee x_2 \vee...$  (arbitrary number of booleans and 1 integer)}

\end{description}

\subsubchapter{Constraint Descriptions}
In this section we describe each of the constraints in more detail.
These descriptions include more information on the execution semantics
of each constraint, so that users of the constraints have an idea how
they behave under various circumstances.  In relevant cases, argument
semantics are indicates using an equation.  For instance, the constraint
condlt(x,y,b) is accompanied by the equation $x<y \Rightarrow b$; this indicates
that the last argument must be a boolean, and that should $x<y$ hold, then
$b$ must be {\em TRUE} in order for the constraint to be satisfied.
Readers interested in more
information should consult the Design Documentation on the Constraint
Network and Parameter Constraints for more information on writing
constraints, errors and so on.  In addition, there is a Design
Documentation contianing information on the implementation details
of constraints in the Constraint Library.  This document is designed
to serve more as a user's guide.


\FormulaConstraintDescr{Less Than Constraint}
    {lt(x,y)}
    {$x<y$}
    {2.  The value of the first argument is constrained to be less than the 
    value of the second argument.}
    {Only integer sorts are permitted.}
    {This constraint enforces a less-than relationship $x<y$ between two integer 
    variables.  
    The constraint sets the domains of $x$ and $y$ by restricting $x$ to contain
    only values which are $< y_{max}$ and by restricting $y$ to contain
    only values which are $> x_{min}$.}

\FormulaConstraintDescr{Less Than Equals Constraint}
    {leq(x,y)}
    {$x \leq y$}
    {2.  The value of the first argument is 
    constrained to be less than or equal to the 
    value of the second argument.}
    {Integer or real sorts are permitted, but all arguments must be of the same sort.}
    {This constraint enforces a less-than-equals relationship $x\leq y$
    between two integer or real variables.       
    The constraint sets the domains of $x$ and $y$ by restricting $x$ to contain
    only values which are $\leq y_{max}$ and by restricting $y$ to contain
    only values which are $\geq x_{min}$.}

\FormulaConstraintDescr{Conditional Less Than Constraint}
    {condlt(x,y,b)}
    {$x < y \Rightarrow b$}
    {3.  If the first argument is less than the second argument, then the last
    argument must be {\em TRUE} for the constraint to be satisfied.
    Otherwise, the last argument must be {\em FALSE} for the constraint
    to be satisfied.}
    {Only integer sorts are permitted for the first two arguments, the last argument must be
    a boolean.}
    {Enforcement of this constraint proceeds as follows: if $x$ and $y$ 
    are singletons, the constraint eliminates the appropriate value from the
    domain of $b$.  If $x_{max}<y_{min}$ then the constraint removes
    {\em FALSE} from the domain of $b$.  If $y_{max} \leq x_{min}$ then the constraint removes
    {\em TRUE} from the domain of $b$.  If $b=${\em TRUE} then 
    the constraint sets the domains of $x$ and $y$ by restricting $x$ to contain
    only values which are $< y_{max}$ and by restricting $y$ to contain
    only values which are $> x_{min}$.
    The constraint does nothing if any variable domain is empty, dynamic or enumerated.}    

\FormulaConstraintDescr{Conditional Less Than Equals Constraint}
    {condleq(x,y,b)}
    {$x \leq y \Rightarrow b$}
    {3.  If the first argument is less than or equal to the second argument, then the last
    argument must be {\em TRUE} for the constraint to be satisfied.
    Otherwise, the last argument must be {\em FALSE} for the constraint
    to be satisfied.}
    {Integer or real sorts are permitted for the first two arguments, but both must be of the
    same sort.  The last argument must be a boolean.}
    {Enforcement of this constraint proceeds as follows: if $x$ and $y$ 
    are singletons, the constraint eliminates the appropriate value from the
    domain of $b$.  If $x_{max}<y_{min}$ then the constraint removes
    {\em FALSE} from the domain of $z$.  If $y_{max} \leq x_{min}$ then 
    the constraint removes
    {\em TRUE} from the domain of $b$.  If $b=${\em TRUE} then 
    the constraint sets the domains of $x$ and $y$ by restricting $x$ to contain
    only values which are $\leq y_{max}$ and by restricting $y$ to contain
    only values which are $\geq x_{min}$.}    

    
\FormulaConstraintDescr{Add-Equals Constraint}
	{addeq(x,y,z)}
	{$x+y=z$}
	{3.  The sum of the first two arguments must equal the third argument.}
	{This procedure determines the minimum and maximum values of each input using
	the bounds on the other two, and restricts the domains of each in turn.
	The relevant formulae are:\\
	$z_{min} = \max(z_{min},x_{min}+y_{min})\\
	z_{max} = \min(z_{max},x_{max}+y_{max})\\
	x_{max} = \min(x_{max},z_{max}-y_{min})\\
	x_{min} = \max(x_{min},z_{min}-y_{max})\\
	y_{min} = \max(y_{min},z_{min}-x_{max})\\
	y_{max} = \min(y_{max},z_{max}-x_{min})$}

\FormulaConstraintDescr{Add-Multiply-Equals Constraint}
	{addmuleq(x,y,r,z)}
	{$x+y*r=z$}
	{4.  The first argument plus the product of the next two arguments must equal the fourth argument.}
	{This procedure uses a similar process to the Add-Equals-Constraint, with a separate step to determine
	the bounds for $y$ and $r$ after determining bounds for $x$ and $z$.  The temporary bounds $yr_min$ and $yr_{max}$
	are computed, using the following formulae:

	$yr_{min} = min(y_{min}*r_{min},
	y_{min}*r_{max},
	y_{max}*r_{min},
	y_{max}*r_{max})\\
	yr_{max} = min(y_{min}*r_{min},
	y_{min}*r_{max},
	y_{max}*r_{min},
	y_{max}*r_{max})$

	Next the bounds for $x$ and $z$ are computed as follows:

	$z_{min} = \max(z_{min},x_{min}+yr_{min})\\
	z_{max} = \min(z_{max},x_{max}+yr_{max})\\
	x_{max} = \min(x_{max},z_{max}-yr_{min})\\
	x_{min} = \max(x_{min},z_{min}-yr_{max})$}

	Once this is done, we compute bounds for $y$ and $r$ by dividing.  At the moment, this requires propagating
	only when all domains are strictly positive and also bounded above by a finite value.  Even so, when
	$y$ and $r$ are permitted to be reals, there may be oddities when dividing by numbers $<1$, so the
	following must be done to ensure that all bounds are computed correctly:

	$y_{min} = \max(y_{min},\frac{z_{min}-x_{max}}{r_{min}},\frac{z_{min}-x_{max}}{r_{max}})\\
	y_{max} = \min(y_{max},\frac{z_{min}-x_{max}}{r_{min}},\frac{z_{min}-x_{max}}{r_{max}})\\
	r_{min} = \max(y_{min},\frac{z_{min}-x_{max}}{y_{min}},\frac{z_{min}-x_{max}}{y_{max}})\\
	r_{max} = \min(y_{max},\frac{z_{min}-x_{max}}{y_{min}},\frac{z_{min}-x_{max}}{y_{max}})\\$

\FormulaConstraintDescr{Add Less-Than Equals Constraint}
    {addleq(x,y,z)}
    {$x+y \leq z$}
    {3.  The sum of the first two arguments must be less than or equal to the third argument.}
    {The procedure restricts $z$ to only have values $ \geq x_{min}+y_{min}$,
    and similarly restricts the sum $x+y$ to only have values $ \leq z_{max}$.
    The relevant formulae are:\\
    $z_{min} = \max(z_{min},x_{max}+y_{max})\\
    x_{max} = \min(x_{max},z_{max}-y_{min})\\
    y_{max} = \min(y_{max},z_{max}-x_{min})$}

\FormulaConstraintDescr{Add Less-Than Constraint}
    {addlt(x,y,z)}
    {$x+y<z$}
    {3.  The sum of the first two arguments must be less than the third argument.}
    {The procedure restricts $z$ to only have values $>x_{min}+y_{min}$,
    and similarly restricts the sum $x+y$ to only have values $<z_{max}$.  The relevant
    formulae are:\\
    $z_{min} = \max(z_{min},x_{min}+y_{min}+1)\\
    x_{max} = \min(x_{max},z_{max}-y_{min}-1)\\
    y_{max} = \min(y_{max},z_{max}-x_{min}-1)$}


\FormulaConstraintDescr{Conditional Add-Equals Constraint}
    {condaddeq(x,y,z,b)}
    {$x+y=z \Rightarrow b$}
    {3.  If the sum of the first and second arguments 
    is equal to the third argument, then the last
    argument must be {\em TRUE} for the constraint to be satisfied.
    Otherwise, the last argument must be {\em FALSE} for the constraint
    to be satisfied.}
    {Integer or Real sorts are permitted for first three arguments, but they  must be of the same sort.
    The last argument must be a boolean.}
    {Enforcement of this constraint proceeds as follows: if $x$,$y$ and $z$ are all 
    singletons, the constraint eliminates the appropriate value from the
    domain of $b$.
    If the bounds of $x+y$  and the bounds of 
    $z$ are disjoint, then the constraint removes the value {\em TRUE} from the domain
    of $b$.  Finally, if $b=${\em TRUE}
    the procedure determines the minimum and maximum values of each input using
    the bounds on the other two, and restricts the domains of each in turn.
    The relevant formulae are:\\
    $z_{min} = \max(z_{min},x_{min}+y_{min})\\
    z_{max} = \min(z_{max},x_{max}+y_{max})\\
    x_{max} = \min(x_{max},z_{max}-y_{min})\\
    x_{min} = \max(x_{min},z_{min}-y_{max})\\
    y_{min} = \max(y_{min},z_{min}-x_{max})\\
    y_{max} = \min(y_{max},z_{max}-x_{min})$}

\FormulaConstraintDescr{Conditional Add Less-Than Equals Constraint}
    {condaddleq(x,y,z,b)}
    {$x+y \leq z \Rightarrow b$}
    {3.  If the sum of the first and second arguments is less than or 
    equal to the third argument, then the last
    argument must be {\em TRUE} for the constraint to be satisfied.
    Otherwise, the last argument must be {\em FALSE} for the constraint
    to be satisfied.}
    {Integer or Real sorts are permitted for first three arguments, but they  must be of the same sort.
    The last argument must be a boolean.}
    {Enforcement of this constraint proceeds as follows: if $x$,$y$ and $z$ are all 
    singletons, the constraint eliminates the appropriate value from the
    domain of $b$.
    If $x_{min}+y_{min} > z_{max}$ then the constraint removes 
    the value {\em TRUE} from the domain
    of $b$.  Finally, if $b=${\em TRUE}
    the procedure restricts $z$ to only have values $ \geq x_{min}+y_{min}$,
    and similarly restricts the sum $x+y$ to only have values $ \leq z_{max}$.  
    The relevant formulae are:
    $z_{min} = \max(z_{min},x_{max}+y_{max})\\
    x_{max} = \min(x_{max},z_{max}-y_{min})\\
    y_{max} = \min(y_{max},z_{max}-x_{min})$}

\FormulaConstraintDescr{Conditional Add Less-Than Constraint}
    {condaddlt(x,y,z,b)}
    {$x+y<z \Rightarrow b$}
    {3.  If the sum of the first and second arguments 
    is less than the third argument, then the last
    argument must be {\em TRUE} for the constraint to be satisfied.
    Otherwise, the last argument must be {\em FALSE} for the constraint
    to be satisfied.}
    {Integer sorts are permitted for first three arguments. The last argument must be a boolean.}
    {Enforcement of this constraint proceeds as follows: if $x$,$y$ and $z$ are all 
    singletons, the constraint eliminates the appropriate value from the
    domain of $b$.
    If $x_{min}+y_{min}>z_{min}$ then the constraint removes the value {\em TRUE} from the domain
    of $b$.  Finally, if $b=${\em TRUE}
    the procedure restricts $z$ to only have values $>x_{min}+y_{min}$,
    and similarly restricts the sum $x+y$ to only have values $<z_{max}$.  
    The relevant formulae are:
    $z_{min} = \max(z_{min}x_{min}+y_{min}+1)\\
    x_{max} = \min(x_{max},z_{max}-y_{min}-1)\\
    y_{max} = \min(y_{max},z_{max}-x_{min}-1)$}


\FormulaConstraintDescr{All Different Constraint}
    {adiff(n1,n2,n3)}
    {$n_1 \neq n_2 \neq ...$}
    {Arbitrary number of arguments, but must be greater than 2.}
    {Parameters of any underlying sort are allowed as arguments, as long as all arguments
    are of the same sort.}
    {The constraint determines which variables, if any, are currently set to
    single values.  If any two variables are set to the same singleton value,
    then the constraint is known to be violated; otherwise, the set of distinct
    singletons is eliminated from the domain of all those variables whose
    domains are not currently singleton values.}

\FormulaConstraintDescr{All Same Constraint}
    {asame(n1,n2,n3)}
    {$n_1 = n_2 = ...$}
    {Arbitrary number of arguments, but must be greater than 2.}
    {Parameters of any underlying sort are allowed as arguments, as long as all arguments
    are of the same sort.}
    {This constraint intersects all the domains
    of all the variables, then sets all the domains to the intersection.}

\FormulaConstraintDescr{Conditional All Different Constraint}
    {condadiff(n1,n2,b)}
    {$n_1 \neq n_2 \neq ...\Rightarrow b$}
    {Arbitrary number of arguments, but must be greater than 2.  The last argument is required to be boolean.}
    {Parameters of any underlying sort are allowed as arguments, as long as all arguments
    are of the same sort.}
    {Enforcement of this constraint proceeds as follows: if all the variables $n_i$
    are singletons, the constraint eliminates the appropriate value from the
    domain of $b$.  If the domains are pairwise 
    disjoint, then {\em FALSE} is removed from the domain of $b$.
    If $b=${\em TRUE}, then
    the constraint removes the intersection of the domains of all the variables from
    each of the current domains.  Otherwise, no domain reduction is possible.}

\FormulaConstraintDescr{Conditional All Same Constraint}
    {condasame(n1,n2,b)}
    {$n_1 = n_2 = ... \Rightarrow b$}
    {Arbitrary number of arguments, but must be greater than 2.  The last argument is required to be boolean.}
    {Parameters of any underlying sort are allowed as arguments, as long as all arguments
    are of the same sort.}
    {Enforcement of this constraint proceeds as follows: if all the variables 
    are singletons, the constraint eliminates the appropriate value from the
    domain of $b$.  If the domains
    of all the variables are pairwise
    disjoint, then {\em TRUE} is removed from the domain of $b$.
    If $b=${\em TRUE}, then
    the constraint sets the domains of all the variables to be the intersection
    of their current domains.  Otherwise, no domain reduction is possible.}

\FormulaConstraintDescr{Flexible All Different Constraint}
    {fadiff(n1,n2)}
    {$n_1 \neq n_2 \neq ...$}
    {Arbitrary number of arguments.  The number of arguments
    may change over time.}
    {Parameters of any underlying sort are allowed as arguments, as long as all arguments
    are of the same sort.}
    {The constraint determines which variables, if any, are currently set to
    single values.  If two singletons are the same, then the constraint is known to
    be violated; otherwise, the set of
    distinct singletons is eliminated from the domain of all those variables whose
    domains are not currently singleton values.  Note that this constraint is
    flexibly scoped, which means that it can take an arbitrary number of variables,
    and that the constraint scope can change over the course of problem solving.
    However, this constraint requires at least 2 variables in scope to execute.}


\FormulaConstraintDescr{Flexible All Same Constraint}
    {fasame(n1,2)}
    {$n_1 = n_2 = ...$}
    {Arbitrary number of arguments.  The number of arguments
    may change over time.}
    {Parameters of any underlying sort are allowed as arguments, as long as all arguments
    are of the same sort.}
    {This constraint intersects all the domains
    of all the variables, then sets all the domains to the intersection.
    Note that this constraint is
    flexibly scoped, which means that it can take an arbitrary number of variables,
    and that the constraint scope can change over the course of problem solving.
    However, this constraint requires at least 2 variables in scope at all times.}

\FormulaConstraintDescr{Maximum Constraint}
    {max(z,x,y)}
    {$z=\max(x,y)$}
    {3.  The first argument is constrained to be the maximum of the second two
    arguments.}
    {The first argument is constrained to be
    the maximum of the second two arguments.
    The procedure constraints the bounds of $z$
    using the maximum of the bounds on $x$ and $y$.  Additionally, the upper bounds
    of $x$ and $y$ may not be greater than the upper bound of $z$.  The relevant
    formulae are:\\
    $x_{max} = z_{max}$\\
    $y_{max} = z_{max}$\\
    $z_{min} = \max(x_{min},y_{min})$\\
    $z_{max} = \max(x_{max},y_{max})$\\
    The constraint does nothing if any variable domain is empty or dynamic.}
    {This constraint intersects all the domains
    of all the variables, then sets all the domains to the intersection.}

\FormulaConstraintDescr{Minimum Constraint}
    {min(z,x,y)}
    {$z=\min(x,y)$}
    {3.  The first argument is constrained to be the minimum of the second two
    arguments.}
    {Integers or reals are allowed as arguments, as long as all arguments
    are of the same sort.}
    {This constraint
    works on three integers or reals.  The procedure constraints the bounds of $z$
    using the maximum of the bounds on $x$ and $y$.  Additionally, the upper bounds
    of $x$ and $y$ may not be greater than the upper bound of $z$.  The relevant
    formulae are:\\
    $x_{max} = z_{max}$\\
    $y_{max} = z_{max}$\\
    $z_{min} = \max(x_{min},y_{min})$\\
    $z_{max} = \max(x_{max},y_{max})$}

\FormulaConstraintDescr{All Maximum Constraint}
    {allmax(z,x1,x2,x3)}
    {$z=\max_i(x_i)$}
    {Arbitrary number of parameters are allowed, but greater than 3.  
    The first argument is constrained to be the maximum of the remaining 
    arguments.}
    {Integers or reals are allowed as arguments, as long as all arguments
    are of the same sort.}
    {The procedure constraints the bounds of $z$
    using the maximum of the bounds on $x_i$.  Additionally, the upper bounds
    of $x_i$ may not be greater than the upper bound of $z$.  The relevant
    formulae are:\\
    $x_{i_{max}} = z_{max}$\\
    $z_{min} = \max_i(x_{i_{min}})$\\
    $z_{max} = \max_i(x_{i_{max}})$}

\FormulaConstraintDescr{All Minimum Constraint}
    {allmin(z,x1,x2,x3)}
    {$z=\min_i(x_i)$}
    {Arbitrary number of parameters are allowed, but greater than 3.  
    The first argument is constrained to be the minimum of the remaining 
    arguments.}
    {Integers or reals are allowed as arguments, as long as all arguments
    are of the same sort.}
    {The procedure constraints the bounds of $z$
    using the minimum of the bounds on the $x_i$.  Additionally, the lower bounds
    of $x_i$ may not be less than the lower bound of $z$.  The relevant
    formulae are:\\
    $x_{i_{min}} = z_{min}$\\
    $z_{min} = \min_i(x_{i_{min}})$\\
    $z_{max} = \min_i(x_{i_{max}})$}

%\FormulaConstraintDescr{Flexible All Maximum Constraint}
%    {z=fallmax(x1,x2,x3)}
%    {$z=\max_i(x_i)$}
%    {Arbitrary number of parameters are allowed, but greater than 3.  The number of parameters
%    may change over time, but must remain greater than 3.}
%    {Integers or reals are allowed as arguments, as long as all arguments
%    are of the same sort.}
%    {}

%\FormulaConstraintDescr{Flexible All Minimum Constraint}
%    {z=fallmin(x1,x2,x3)}
%    {$z=\min_i(x_i)$}
%    {Arbitrary number of parameters are allowed, but greater than 3.  The number of parameters
%    may change over time, but must remain greater than 3.}
%    {Integers or reals are allowed as arguments, as long as all arguments
%    are of the same sort.}
%    {The procedure constraints the bounds of $z$
%    using the minimum of the bounds on the $x_i$.  Additionally, the lower bounds
%    of $x_i$ may not be less than the lower bound of $z$.  The relevant
%    formulae are:\\
%    $x_{i_{min}} = z_{min}$\\
%    $z_{min} = \min_i(x_{i_{min}})$\\
%    $z_{max} = \min_i(x_{i_{max}})$\\
%    Note that this constraint is
%    flexibly scoped, which means that it can take an arbitrary number of variables,
%    and that the constraint scope can change over the course of problem solving.
%    However, this constraint requires at least 3 variables in scope at all times.
%    In addition, it is an error to ret and remove the first variable in the scope,
%    as it is the minimum of all the others.}

\FormulaConstraintDescr{ConditionalMaximum Constraint}
    {condmax(z,x,y,b)}
    {$z=\max(x,y) \Rightarrow b$}
    {4.  If the first argument is the maximum of the second two arguments,
    the last argument must be {\em TRUE} in order for the constraint to be satisfied.
    Otherwise, the last argument must be {\em FALSE} in order for the constraint to 
    be satisfied.}
    {Integers or reals allowed for the first three arguments, as long as all arguments
    are of the same sort.  The last argument must be a boolean}
    {The procedure constraints the bounds of $z$
    using the maximum of the bounds on $x_i$.  Additionally, the upper bounds
    of $x_i$ may not be greater than the upper bound of $z$.  The relevant
    formulae are:\\
    $x_{i_{max}} = z_{max}$\\
    $z_{min} = \max_i(x_{i_{min}})$\\
    $z_{max} = \max_i(x_{i_{max}})$\\
    Note that this constraint is
    flexibly scoped, which means that it can take an arbitrary number of variables,
    and that the constraint scope can change over the course of problem solving.
    However, this constraint requires at least 3 variables in scope at all times.
    In addition, it is an error to ret and remove the first variable in the scope,
    as it is the maximum of all the others.}

\FormulaConstraintDescr{Conditional Minimum Constraint}
    {condmin(z,x,y,b)}
    {$\min(z,x,y,b) \Rightarrow b$}
    {4.  If the first argument is the minimum of the second two arguments,
    the last argument must be {\em TRUE} in order for the constraint to be satisfied.
    Otherwise, the last argument must be {\em FALSE} in order for the constraint to 
    be satisfied.}
    {Integers or reals are allowed for the first three arguments, as long as all arguments
    are of the same sort.  The last argument must be a boolean.}
    {If the domain of the boolean $b$ is equal to the singleton {\em TRUE}
    the procedure constraints the bounds of $z$
    using the minimum of the bounds on $x$ and $y$.  Additionally, the lower bounds
    of $x$ and $y$ may not be less than the lower bound of $z$.  The relevant
    formulae are:\\
    $x_{min} = z_{min}$\\
    $y_{min} = z_{min}$\\
    $z_{min} = \min(x_{min},y_{min})$\\
    $z_{max} = \min(x_{max},y_{max})$\\
    If $z$ is guaranteed to be the minimum of $x$ and $y$, then {\em FALSE} is
    removed from the domain of $b$, and if $z$ is guaranteed not to be the minimum
    of $x$ and $y$ then {\em TRUE} can be removed from the domain of $b$.}


\FormulaConstraintDescr{Conditional All Maximum Constraint}
    {condallmax(z,x1,x2,x3,b)}
    {$z=\max_i(x_i) \Rightarrow b$}
    {Arbitrary number of parameters are allowed, but greater than 4.
    If the first argument is the maximum of all but the last argument,
    the last argument must be {\em TRUE} in order for the constraint to be satisfied.}
    {Integers or reals are allowed as arguments, as long as all arguments
    are of the same sort.}
    {Otherwise, the last argument must be {\em FALSE} in order for the constraint to be satisfied. 
    If the domain of the boolean $b$ is equal to the singleton {\em TRUE}
    the procedure constraints the bounds of $z$
    using the maximum of the bounds on $x_i$.  Additionally, the upper bounds
    of $x_i$ may not be greater than the upper bound of $z$.  The relevant
    formulae are:\\
    $x_{i_{max}} = z_{max}$\\
    $z_{min} = \max_i(x_{i_{min}})$\\
    $z_{max} = \max_i(x_{i_{max}})$
    If $z$ is guaranteed to be the maximum of $x_i$, then {\em FALSE} is
    removed from the domain of $b$, and if $z$ is guaranteed not to be the maximum
    of $x_i$  then {\em TRUE} can be removed from the domain of $b$.}

\FormulaConstraintDescr{Conditional All Minimum Constraint}
    {condallmin(z,x1,x2,x3,b)}
    {$z=\min_i(x_i) \Rightarrow b$}
    {Arbitrary number of parameters are allowed, but greater than 4.
    If the first argument is the minimum of all but the last argument,
    the last argument must be {\em TRUE} in order for the constraint to be satisfied.}
    {Integers or reals are allowed as arguments, as long as all arguments
    are of the same sort.}
    {Otherwise, the last argument must be {\em FALSE} in order for the constraint to be satisfied. 
    If the domain of the boolean $b$ is equal to the singleton {\em TRUE}    
    the procedure constraints the bounds of $z$
    using the minimum of the bounds on the $x_i$.  Additionally, the lower bounds
    of $x_i$ may not be less than the lower bound of $z$.  The relevant
    formulae are:\\
    $x_{i_{min}} = z_{min}$\\
    $z_{min} = \min_i(x_{i_{min}})$\\
    $z_{max} = \min_i(x_{i_{max}})$\\
    If $z$ is guaranteed to be the minimum of $x_i$, then {\em FALSE} is
    removed from the domain of $b$, and if $z$ is guaranteed not to be the minimum
    of $x_i$ then {\em TRUE} can be removed from the domain of $b$.}


\FormulaConstraintDescr{Equality Constraint}
    {eq(x,y)}
    {$x=y$}
    {2.}
    {Parameters of any underlying sort are allowed as arguments, as long as all arguments
    are of the same sort.}
    {This constraint eliminates
    any elements of either domain which will fail to satisfy the constraint;
    this is done by restricting the domains of the variables to their intersection.}

\FormulaConstraintDescr{Disequality Constraint}
    {neq(x,y)}
    {$x \neq y$}
    {2.}
    {Parameters of any underlying sort are allowed as arguments, as long as all arguments
    are of the same sort.}
    {The constraint is enforced by checking to see if one of the domains is a
    singleton, and if so, removing that value from the other domain.}

\FormulaConstraintDescr{Conditional Equality Constraint}
    {condeq(x,y,b)}
    {$x=y \Rightarrow b$}
    {3.  The last argument must be a boolean.}
    {Parameters of any underlying sort are allowed as arguments, as long as the first two arguments
    are of the same sort.  The last argument must be a boolean.}
    {Enforcement of this constraint proceeds as follows: if both $x$ and $y$
    are singletons, the constraint eliminates the appropriate value from the
    domain of $z$.  If the domains
    of $x$ and $y$ are disjoint, then {\em TRUE} is removed from the domain of $z$.
    If $z=${\em TRUE}, then
    the constraint sets the domains of $x$ and $y$ to be the intersection
    of their current domains.  Otherwise, no domain reduction is possible.}

\FormulaConstraintDescr{Conditional Disequality Constraint}
    {condneq(x,y,b)}
    {$x \neq y \Rightarrow b$}
    {3}
    {Parameters of any underlying sort are allowed as arguments, as long as the first two arguments
    are of the same sort.  The last argument must be a boolean.}
    {The last argument must be a boolean.  
    Enforcement of this constraint proceeds as follows: if both $x$ and $y$
    are singletons, the constraint eliminates the appropriate value from the
    domain of $z$.  If the domains
    of $x$ and $y$ are disjoint, then {\em FALSE} is removed from the domain of $z$.
    If $z=${\em TRUE}, then
    the constraint removes the intersection of the domains of $x$ and $y$ from
    each of the current domains.  Otherwise, no domain reduction is possible.}

\FormulaConstraintDescr{Or Constraint}
    {or(x,y)}
    {$x \wedge y \wedge ...$}
    {Arbitrary number of parameters are allowed, but greater than 1.}
    {Boolean sorts only are allowed as parameters.}
    {The constraint language does not permit
    unary negation constraints or "cascading" constraints, so there is
    no way to specify a logical or on literals, as is done in Boolean Algebra;
    all boolean variables are assumed to be strictly positive literals.
    The constraint works by checking the domains of variables for
    true assignments.  If only one variable with a non-singleton value can
    be assigned to satisfy this constraint, its domain is reduced to the 
    singleton {\em TRUE.}}

\FormulaConstraintDescr{Flexible Or Constraint}
	{for(x,y)}
	{$x \wedge y \wedge ...$}
	{Arbitrary number of parameters are allowed.  The number of parameters
	can change over time.}
	{Boolean sorts only are allowed as parameters.}
	{The constraint language does not permit
	unary negation constraints or "cascading" constraints, so there is
	no way to specify a logical or on literals, as is done in Boolean Algebra;
	all boolean variables are assumed to be strictly positive literals.
	The constraint works by checking the domains of variables for
	true assignments.  If only one variable with a non-singleton value can
	be assigned to satisfy this constraint, its domain is reduced to the 
	singleton {\em TRUE}.}


\FormulaConstraintDescr{Cardinality Constraint}
	{card(x,y,z)}
	{$z \leq x_1 \vee x_2 \vee...$}
	{Arbitrary number of parameters are allowed.}
	{The first parameter must have integer sort, the remaining parameters must have bool sort.}
	{This constraint enforces the requirement that $z$'s value indicates an upper bound on the
	number of the boolean variables which can be true.  To enforce this, we first check whether
	$z$ is a singleton.  If so, then if exactly the correct number of boolean variables are
	already true, any booleans which are unspecified can be forced to false.}

\FormulaConstraintDescr{Cardinality Equivalence Constraint}
	{cardeq(x,y,z)}
	{$z = x_1 \vee x_2 \vee...$}
	{Arbitrary number of parameters are allowed.}
	{The first parameter must have integer sort, the remaining parameters must have bool sort.}
	{This constraint enforces the requirement that $z$'s value indicates the
	number of the boolean variables which can be true.  To enforce this, we first check whether
	$z$ is a singleton.  If so, then if exactly the correct number of boolean variables are
	already true, any booleans which are unspecified can be forced to false.  Otherwise, if not enough
	booleans are true and all the rest of the booleans must be true to satisfy the constraint, then
	all remaining unspecified booleans can be forced to be true.  If $z$ is not a singleton, we then
	count the number of true booleans $t$ and the number of false booleans $f$.  If the total number
	of boolean variables is $v$, then the new lower bound on $z$ is $v-f$ and the new upper bound on $z$ is $t$.}

\end{document}