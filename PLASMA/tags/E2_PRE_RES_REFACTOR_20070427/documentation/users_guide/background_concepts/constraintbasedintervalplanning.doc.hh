/** * @page constraintbasedintervalplanning Introduction to Constraint-Based Interval Planning *  * EUROPA2 follows the Constraint Based Interval Planning paradigm with timelines as originally developed by Nicola Muscettola for NASA Remote Agent  * experiment and further * developed and formalized by David Smith, Jeremy Frank, and Ari Jonsson. Pointers to the academic papers describing this work are included in the * general references section of the Users' Guide. This section is designed to be a self-contained introduction where we * describe each of the concepts in turn to provide you with the background knowledge needed to understand the example applications in the  * remainder of this tutorial. * * EUROPA2 was designed to support planning for complex systems, such as spacecraft and rovers. We will explain why it differs from classical approaches  * as we proceed.  * * @section domainindependentplanning Motivation * * The EUROPA2 planner, as its predecessors, uses declarative descriptions of models, plans, and goals. This means that the same planner can be applied  * to different systems and problems, simply by providing different models and goals. For such declarative planners (as opposed to special-purpose planners)  * the expressiveness of the languages for models, goals and plans is of great importance.  * * In traditional planning, models are described in terms of a set of Boolean state indicators (called fluents) and a set of actions that can modify the  * fluents. Goals are given in terms of an initial specification of which fluents are true and which are false, and a set of different fluents values to  * achieve. A plan is then a sequence of actions that modifies the initial state to get the desired values.  * * This basic traditional approach is too simplistic for real-world applications. Consider a complex system like a spacecraft. It consists of multiple  * interacting subsystems, such as navigation, attitude control, camera, and main engine. Multiple subsystems may be active at the same time, each performing *  a different activity. There are also interactions among the subsystems, whether or not one or both are active. The camera, for example, cannot be taking *  a picture while the main engine is running. Finally, the classical assumptions concerning the relations between activities and states do not hold in *  many cases. For one, the states are often considered inactive, such as pointing at a target, are in fact activities. To plan for such complex systems,  * the expressiveness of model, plan, and goal descriptions must be increased significantly.  * * @section approach EUROPA2's Approach * * EUROPA2's approach is based on two key insights: the use of intervals to describe the temporal extent of activities and states, and the use of timelines  * to describe concurrent behavior over time. Intervals have long been used in temporal planning to specify activities and states with durations. *  Since there are invariable limits on how intervals can interact, the approach is referred to as Constraint-Based Interval Planning. The use of *  timelines is an extension of basic constraint-based planning. The main purpose of timelines is twofold; they provide a natural way to describe * concurrent processes and the interactions between them, and they provide a natural representation of system states changing over time.  *  *@subsection activitesandstates Activities and States  * To generate plans for a given system, a <i>model</i> of the system must * be available to the planner.  This model provides information on the * activities that can take place, on the possible states that the system * (and its subsystems) can be in, and rules and limitations on how * activities and states relate.  Let us start by looking at activities * and states. * In this planner, the same constructs are used to describe both states * and activities.  These are typically referred to as predicates, * although sometimes the term procedure is also used.  Formally, a  * <i>predicate</i> is a function that returns a Boolean value, used to specify * what is true and what is false.  Informally, predicates are simply * statements about what is true.  The reason is that if <i>p : {1,2,3,4} * -> {T,F}</i> is a predicate, then <i>p(1)</i> can be read as <i>p(1)= T</i>, *  and taken to mean that <i>p(1)</i> is true. *  * As an example, consider a simple rover that can move among a number of * specified locations.  A predicate can be used to describe where the * rover is, by mapping the possible locations to true or false.  Let us * call this predicate <i> at</i>.  If one of the locations is a <i>rock</i>,  * then <i>at(rock)</i> indicates that the rover is at the rock. * As another example, a predicate can also be used to describe between * what places the rover is traveling.  Let us call this predicate <i> * going</i>, and have it take two locations as arguments.  Then the * statement <i>going(lander,rock)</i> means that the rover is traveling * from the lander to the rock. * * The rover example demonstrates that the same construct can be used to * describe states and activities. One reason for doing so is * simplicity; there is no need to make an arbitrary syntactic * distinction between activities and states. Another reason is that in * many systems, the distinction between activities and states becomes  * blurred at higher levels of abstractions. Let us assume that our * rover has an arm capable of picking up rock samples. The arm can be * moved to different spots around each location, to take samples. In * order to take a sample, the arm must be at a fixed spot. This can be * modeled in terms of two predicates <i>moveArm</i> and <i>armAt</i>.  At * a first glance, one might think of the move as an activity and the arm * placement as a state.  However, maintaining the placement of the arm, * as the rock is grabbed, is actually an activity. * * The uniform description of activities and states in terms of * predicates allows us to avoid any confusion about what are states and * what are activities.  Furthermore, since many systems are in fact * active at all times, a uniform description of the activity in terms of * predicates is very useful. * * @subsection temporalintervalsvariablesotkens Temporal Intervals, Variables, and Tokens * * Planning is inherently based on time.  Therefore, a statement of the * form <i>at(rock)</i> is invariably qualified with temporal information * about when it holds.  There are a number of different ways to specify * such temporal information.  One extreme is to specify a single * time for each predicate. This approach is depicted in the figure below. * * @image html point-rep.jpg Activities associated with single timepoints. * * Another extreme is to qualify the statement with all points at which  * the predicate is true.  * * @image html list-rep.jpg Activities associated with a list of all timepoints at which it holds * * Regardless of which of these extreme approaches is used, time must be * specified with discrete time values.  In other words, time will be * measured with integer timesteps.  In the first case, a finite set of * timesteps is necessary to limit the enumeration of states while in the * second approach it limits the enumeration of timepoints for each * state. * * In EUROPA2, intervals are used to qualify statements.  Therefore, each  * basic statement consists of a start time, a predicate and an end time.  For example, the figure below  * shows the rover being at the rock between * timepoints 3 and 7.  To maintain the effectiveness of the interval * representation, it is assumed that the interval is always maximal.  In * our example, this would mean that the rover was not at the rock at * time 2, and not at the rock at time 8. * * @image html interval-rep.jpg Activities and states associated with temporal intervals * * It should be noted that although the current EUROPA2 representation  * uses integral time quanta, this interval representation permits  * real-valued timepoints.  Furthermore, it is easy to adapt the planner  * to that representation. * Specifying fixed times is not always feasible, and it is not always * the most effective way to build plans.  As a result, the planner allows * the start and end timepoints of such intervals to be represented by * variables.  For example, one can specify <i>at(rock) [?s,?e]</i>, * where <i>s</i> and <i>e</i> are variables.  If the variables values are * limited to <i>s in [3,5]</i> and <i>e in [4,7]</i>, as an example, then * <i> at(rock) [?s,?e]</i> specifies that the rover will arrive at * the rock between times 3 and 5 (inclusive) and stay until between * times 4 and 7 (inclusive).  This is shown in the figure below, * which shows how the flexible start and end times correspond to a set * of possible scenarios for the interval. * * @image html flexible-rep.jpg Intervals *  * There are two main reasons for permitting such flexibility.  One is * that it is often more effective to build plans by limiting unnecessary * commitment, which cannot be done if the underlying planning approach * requires complete commitment.  The other reason is that flexibility is * useful for many real-world situations.  Consider the rover moving from * the hill to the rock.  The navigation calculations may estimate the * traveling time to be 18 time units, but wheel slippage may increase * that time by up to 50%.  Rather than breaking the plan if the travel * time goes beyond 18 time units, or forcing the activity to use all of * the worst-case estimate duration of 27, the planner approach allows the * travel time to be specified as being between 18 and 27 time units.  A * smart agent can take advantage of such flexibility during the plan * execution. *  * To specify permitted ranges for activity intervals, <i>constraints</i> * on the interval durations can be specified.  In general, constraints * specify a set of valid assignments to a set of variables.  The set of * variables is fixed for each constraint, and is called the <i>scope</i> * of the constraint.  As an example of how duration constraints may be * specified, consider the last rover example.  The bound on the * traveling time restricts the duration of <i>going(hill,rock)</i> to the * interval [18,27].  In general, bounding the duration of an interval * corresponds to a simple arithmetic constraint.  To enforce that the * duration of an interval <i>state [?s,?e]</i> is within the bounds * <i>[d,D]</i>, we simply specify a constraint:<br><br> * <center><i>d @f$\leq@f$  ?e - ?s @f$\leq@f$ D</i>.</center><br><br> * The scope of this constraint is <i>{?s}, {?e}</i>. * * The use of fixed duration constraints is convenient and effective. * However, interval durations may be affected by other constraints, and * it quickly gets cumbersome to express all such relations in terms of * the start and end times.  For example, the bound on the rover's travel * time might depend on the amount of power available.  To support * reasoning directly about such interactions, a variable is used to * describe the duration of an interval.  As a result, any interval is * subject to the constraint<br><br> * <center><i>?s + ?d = ?e</i></center><br><br> * where <i>?s</i> and <i>?e</i> are variables representing the start and * end times, and <i>?d</i> is a variable representing the duration. *  * The use of variables to support flexibility extends beyond the  * temporal aspects of an interval.  Consider the goal that the rover be  * at the rock.  In order for the rover to be at the rock, the rover must  * get there, which is typically accomplished with some movement  * activity, like <i>going(lander,rock)</i>.  But, if the rover turns out  * to not to have been at the lander before going to the rock, selecting  * this particular movement would result in an unnecessary detour to the  * lander.  Therefore, we allow variables in the arguments to predicates,  * e.g., <i>going(?from,rock)</i>. *  * Taking all of this together, we get a construct that describes sets of * states and activities over temporal intervals.  Such constructs are * called <i>tokens</i>.  For now, we will assume that each token refers * to a single statement, i.e., that it describes a possible state or * action that persists throughout the duration of the interval.  Such * single-valued tokens are called <i>value tokens</i>, and unless we * explicitly say otherwise, any reference to a token should be taken to * mean a value token.  * * A token has a predicate name (such as <i> at</i>), a pair of timepoint * variables for the start and the end  <i>s</i> and <i>e</i>, a duration * variable <i>d</i> and a set of argument variables, one for each argument * to the predicate in question (say <i>l</i> for the location). Note: each * token has one more variable, an object variable, which we will get to * soon. To represent a token as a formula, we will, for now, use a * convention that will later lead to a language for specifying tokens. * The basic notation is:<br><br> * <center><i>s pred d (x<sub>1</sub>, ..., x<sub>k</sub>) e</i></center><br><br> * where <i>s</i>, <i>d</i> and <i>e</i> specify the start time, duration and end time * respectively, <i>pred</i> is the predicate name, and <i>x<sub>1</sub></i> through * <i>x<sub>k</sub></i> specify the parameters.  Each of the <i>s, d, e, x<sub>i</sub></i> may be * specified either by providing a variable name, e.g., <i>?s</i>, or by * providing the set of possible values for that variable.  The value set * can be a singleton, e.g., <i>7</i>, a set of values, e.g., <i>{1,7,9}</i> or * an interval, e.g., <i>[0,10]</i>.  Using this representation for tokens, we * can now specify a simple plan. In this notation, the temporal variables  * <i>s</i>, <i>d</i> and <i>e</i> are * optional; the default value set for each of them is <i>[0,  @f$\infty@f$]</i>. We * can therefore use <i>at(rock)</i> as a shortcut for <i>[0,  @f$\infty@f$] * at [0,  @f$\infty@f$.] (rock) [0,  @f$\infty@f$]</i>. * * @image html simple-plan.jpg A simple plan showing temporal intervals * * Finally, let us note that not all instantiations of token variables * are valid.  For example, the duration bound of a <i>going(?org, * ?dest)</i> state will likely depend on the origin and destination of the * movement.  In other words, if <i>?d</i> represents the duration * variable, there is a constraint on the valid combinations of values * for <i>?org</i>, <i>?dest</i>, and <i>?d</i>.  Such limitations are * enforced by constraints on the variables appearing in a token.  * Consequently, tokens typically have a set of constraints associated * with them; the scope of each constraint is a subset of the variables * of that token. * * @subsection attributesandtimelines Attributes and Timelines * * Complex systems, like rovers, invariably have a number of interacting * states and activities.  A natural approach to describing such systems * is in terms of <i>attributes</i>.  Typically, an attribute will * describe the state of a component or subsystem, ongoing system * activity, or other things that concern the system or a subsystem. * Since the state or activity of a component will change over time, an * attribute describes a state variable that changes values over time. * The rover, for example, might have a number of different attributes, * describing the different subsystems and other aspects of it.  Let's * assume the rover has an arm and two sample storage containers.  The * rover could then be modelled as having a location attribute, an arm * activity attribute, and an attribute describing the state of each * storage area. * * Each attribute has a set of predicates that are used to describe the * state or activity in question.  In terms of an attribute being a state * variable, the predicates define the possible values.  For example, the * location attribute of the rover has the <i>at</i> and <i>going</i> * predicates. * * Typically, for any given attribute, there are restrictions on how the * its state can change over time.  For example, the rover cannot * transition from <i>at(rock)</i> directly to <i> at(hill)</i>.  If we * consider the set of all instantiations of all predicates associated * with a given attribute as nodes in a graph, valid transitions can be * specified as directed arcs in this graph.  The result is a state * transition diagram that defines the set of possible evolutions of a * given attribute.  The figure below shows a simple state * transition diagram for the rover location attribute. *  * @image html rover-state-transition.jpg state transition diagram describing the set of legal transitions (and thus evolutions) of the location attribute * * A <i>timeline</i> is a logical structure used to represent and reason * about the development of an attribute over a period of time.  As * certain aspects of the description may not be fully specified, e.g., * token variables may not have been assigned single values, a timeline * can represent a set of possible evolutions.  In its simplest form, a  * timeline is a sequence of tokens, each describing an activity or a * state over some period of time.  Two adjacent tokens may have a * <i>slot</i> between them, i.e., room where additional tokens may possible be * added.  For an example, consider the simplified picture of a timeline * in the figure below. * * @image html empty-slot-timeline.jpg Empty slot on a timeline * * Timelines describe attribute histories over periods of time.  When * planning, all timelines describe the same period.  This period is * called the <i> planning horizon</i> (or simply the <i>horizon</i>).  All * planning activity goes on within this time period\footnote{Having a * planning horizon does not force the planner to generate only plans * that completely fill the horizon.  It does, however, limit planning to * be within that horizon. * * @subsection classandobject Classes and Objects * * An entity like the rover has multiple attributes.  In addition, there * may be multiple rovers involved in the planned operations.  To group * related attributes together and to support multiple instantiations, we * consider the rover as an object.  A class hierarchy is then used to * describe the types of objects in the world.  A <i>class</i> is formally * defined as a set of attributes.  The attributes can either stem from * being specified for a class, or by inheritance.  For example, we could * define a class of rovers, say <i>class SimpleRover</i>, that only has a * location attribute.  Rovers with a single arm could constitute a * subclass <i>class RoverWithArm</i> that also has an arm state * attribute.  Finally, we could define a class of specific rovers,  * <i>class SampleRover</i>, that also has two sample container attributes. * * An <i>object</i> is an instance of a class.  Our example rover would be * an object of class <i>SampleRover</i>. While classes have attribute * specifications, those attributes are instantiated in an object of that * class.  As a result, we typically use timelines to describe the * attributes of instantiated objects. * * The notion of objects leads to one additional variable for each token, * namely the object to which the token applies.  Consider an operation * involving multiple rovers.  One of the goals may be to have a rover at * the rock for a given time period, but any rover will do.  In terms of * a token describing this situation, there is an open decision about the * timeline on which to put the token.  To represent such flexibility in * where tokens go, each token has a variable representing the set of * possible objects it may apply to.  This variable is called the <i> * object variable</i>. * * @subsection planningdomainaxioms Planning Domain Axioms * * The world is filled with rules and limitations, both universal and * manmade.  As a result, many candidate plans are impossible, * unsafe or invalid.  We have already seen examples of constraints on * valid token variable instantiations, in addition to limits on valid * attribute evolutions, enforced by state transition graphs.  So far, * these rules have been limited to single tokens and single attributes. * We now turn our attention to the much more general class of limits on * valid interactions between different attributes and objects.   *  * To demonstrate possible interactions between different attributes, let * us assumed that our rover has a simple arm, and that the state of the * arm is described by an <i>armState</i> attribute.  Noting that this is * only a very simple example, not a proposed mission, let us assume that * the arm can be in only two states: <i>off</i> and <i>waving</i>. * * In the EUROPA2 planning paradigm, a uniform representation is * used to specify all rules and limitations of a planning domain.  These * are called <i>planning domain axioms</i>.  The planning domain axioms * are used to represent everything from simple instantiation constraints * to complex interaction rules.  Nonetheless, planning domain axioms can * be distilled into two parts: * <ul> * <li>Token constraints:  Specify which combinations of token * variable instantiations result in a valid token. * <li> Configuration rules: Specify the context in which a token can * appear in plan. *</ul> * The duration and instantiation constraints discussed above are * examples of token constraints, while the rules implied by the state * transition graphs are examples of configuration rules. * * The EUROPA system supports arbitrary token constraints, but, like * other planning systems, it limits configuration rules to a certain * structure. In classical planning, for example, the configuration * rules for actions are limited to: * <ul> * <li> Preconditions: Rules about states that must hold when the * action is executed. * <li> Effects: Rules about how the state of the world changes, as a * result of executing an action. *</ul> *  The structure used in the Remote Agent planning paradigm * significantly extends the structure of traditional classical planning * rules.  It is also more expressive than the structure used by most * other constraint-based planning systems. * * In the EUROPA2 planning paradigm the planning domain axioms are * specified in terms of <i>compatibilities</i> or <i>compats</i> for * short.  The basic idea is that a compatibility will specify the set of * plan elements that are necessary for having a given token in the plan.  * Consider a state like <i>going(x,y)</i> for our sample rover.  The * planning domain axioms for this state must enforce the following: * <ul> * <li>The duration is limited to the appropriate bound on travel * time for going from the origin to the destination. * <li> The location of the rover must have been at the origin * immediately prior to this. * <li> The location of the rover will be at the destination * immediately following this. * <li>  The arm must be off during this. *</ul> * * To describe such restrictions, compatibilities specify rules that * apply to specific token instantiations.  There are many equivalent  * ways in which compatibilities can be described, as we shall see  * later.  In this guide, we will focus on the simplest approach that is  * sufficient to represent all possible compatibility rules.  In this  * approach, a compatibility consists of: * <ul>  * <li> A header that specifies the token and its variables * <li> A set of constraints specifying when the compatibility applies * <li> A set of token constraints that restrict possible  *  token instantiations * <li> A set of configuration rules specifying other tokens that  *  must exist in the plan *</ul> * * The <i>rule header</i> describes a token and names the associated * variables.  In the case of providing a rule for the <i>going</i> token, * this header names the temporal, duration, object and parameter * variables that come with each such token.  The role of the header is * simply to specify the context (i.e., the predicate and the variables). * The <i>guard conditions</i> specify constraints on some of the token * variables.  These conditions determine when the rule is applicable.   * The <i>configuration rules</i> and the <i>token constraints</i> are the  * consequences of the rule being applicable.  The token constraints  * limit the possible combinations of values for token variables, while  * the configuration rules limit the set of valid plans by requiring  * certain states and activities to appear with specific relations to the  * token to which the rule applies. *   * To formalize this notion, each compatibility can be described as a * rule of the form:<br><br> *  <center><i>x<sub>s</sub> P<sub>x0</sub>x<sub>d</sub>(x1,@f$\ldots@f$,x<sub>k</sub>)  *  x<sub>e</sub>; G<sub>1</sub>(x1), @f$\ldots@f$, G<sub>k</sub>(x<sub>k</sub>) @f$\rightarrow@f$ *  C<sub>1</sub>(Y<sub>1</sub>), @f$\ldots@f$, C<sub>m</sub>(Y<sub>m</sub>); @f$\tau_1@f$ S<sub>1</sub> *  (Z<sub>1</sub>),@f$\ldots \tau_n@f$ S<sub>n</sub>(Z<sub>n</sub>)</i></center><br><br> * *  where <i>{x<sub>1</sub>@f$\ldots@f$ x<sub>k</sub>, x<sub>s</sub>, x<sub>d</sub> X<sub>e</sub>, x<sub>0</sub>}</i> is the full set of * variables for the token, parameter variables, then start time, * duration, end time and object variables respectively, and * <ul> * <li>each <i>Y<sub>i</sub></i>, and <i>Z<sub>i</sub></i> is a subset of these variables, * <li>each <i>G(x<sub>i</sub>)</i> is a guard constraint of the form <i>x<sub>i</sub>@f$\in@f$D<sub>i</sub></i> * where <i>D<sub>i</sub></i> is a set of values for <i>x<sub>i</sub></i>, * <li> each <i>C<sub>i</sub>(Y<sub>i</sub>)</i> is a constraint on the values of the variables * in <i>Y<sub>i</sub></i> * <li>each <i>@f$tau_i@f$</i> is quantitative temporal relation between two * intervals (the set of all possible relations will be given later) * <li> each <i>S<sub>i</sub>(Z<sub>i</sub>)</i> is a specification of a token * </ul> * This form of compatibilities is called a <i>conditional * compatibility</i>, since the application is conditional on the guarding * constraints <i>G<sub>i</sub></i> being satisfied. * *This rule is actually a shortcut for a well-defined logical rule which *essentially states that for any token <i>T<sub>p</sub></i>, with the predicate <i>P</i>, *such that the parameter variables satisfy the guard unary constraints *<i>G<sub>i</sub></i>, the token variables must satisfy each of the constraints <i>C<sub>i</sub></i>, *and for each <i>@f$\tau_i@f$S<sub>i</sub>(Z<sub>i</sub>)</i> there must exist another token <i>T<sub>i</sub></i> in *the plan, such that <i>T<sub>i</sub> @f$\subseteq@f$ S<sub>i</sub>(Z<sub>i</sub>)</i> and the temporal relation *<i>T<sub>p</sub>@f$\tau@f$T<sub>i</sub></i>.**The compatibility structure may look involved, but it is fairly simple*in practical use.  In terms of a compatibility, the above-mentioned*restrictions on {\tt going} can be specified as follows:<br><br>* <center><i>* going<sub>o</sub>d(x,y); * @f$\rightarrow @f$ * d = calcTravelTime(x,y);<br>* metBy at<sub>o</sub>(x),<br>* meets at<sub>o</sub>(y),<br>* containedBy  off<sub>o</sub>() *</center></i><br><br>*</center>*The configuration rules can easily be represented graphically, with*arrows noting the temporal relations, and nodes describing the tokens*involved.  The <i>going(x,y)</i> configuration rule is shown in*the following figure..**@image html example-compat.jpg A simple compatibility for going(x,y)**In the above example, there is only one configuration that supports*the <i>going(x,y)</i> activity.  In many cases, however, different*configurations may support a given state or activity.  We could, for*example, imagine that the rover could also move from one place to*another, while waving, as long as the duration of the <i>going</i>*activity is limited to 10 time units.  Such planning domain axioms can*be represented by <i>disjunctive compatibilities</i>.    Disjunctive *compatibilities are well-defined concepts, but the formal description *is significantly more involved than the simple conditional rule.**However, we note that any disjunctive compatibility can just as well*be represented by a set of conditional compatibilities, provided that*additional parameters are used to distinguish between the available*options.  In the case of <i>going</i>, we can add a third parameter,*which takes on the value <i>true</i> if the rover will be waving and*<i>false</i> otherwise.  The conditional compatibilities can then be*specified as follows:* <br><br><center><i>* going<sub>o</sub> d (x,y,w); w = true * @f$\rightarrow@f$ *  d = calcTravelTime(x,y);<br>*  metBy at<sub>o</sub>(x), <br>*  meets at<sub>o</sub>(y), <br>*  containedBy off<sub>o</sub>() * </i></center><br><br>*  and*  <br><br><center><i>*  going<sub>o</sub> d (x,y);  w = false}  @f$\rightarrow@f$ *  d = calcTravelTime}(x,y), <br>*  d @f$\leq@f$ 20 ;  <br>*  metBy at<sub>o</sub>(x), <br>*  meets at<sub>o</sub>(y), <br>*  containedBy waving<sub>o</sub>()* </i></center><br><br>* Looking at these conditional compatibilities, it is easy to see that* certain aspects of the two configurations are the same.  Since there* is no reason that two or more conditional compatibilities cannot apply* to the same token, we can separate out the common elements and put* them together in a third compatibility.  This gives us the following* <br><br><center><i>* going<sub>o</sub> d (x,y,w); @f$\rightarrow@f$*  d = calcTravelTime}(x,y), <br>*  metBy at_o(x), <br>*  meets at_<sub>o</sub>(y), *  </i></center><br><br>*  and *  <br><br><center><i>*  going<sub>o</sub> d (x,y,w); w = true*  @f$\rightarrow@f$*  containedBy off<sub>o</sub>*  </i></center><br><br>*  and*  <br><br><center><i> *  going<sub>o</sub> d (x,y,w);  w = false*  @f$\rightarrow @f$*   d @f$\leq 20@f$; <br>*   containedBy waving<sub>o</sub>() * </i></center><br><br>* This representation makes it easy to specify smaller and simpler* rules that together define the same limitations as larger disjunctive* compatibilities.** Each configuration rule gives rise to a set of pairs, each of which is* of the form <i>@f$\tau@f$S(Z)</i>, where @f$\tau@f$ is a quantitative temporal* relation and <i>S(Z)</i> is a token specification using <i>Z</i>, a subset of* the given token variables <i>X</i>.  Each such pair is commonly referred to* as a <i>subgoal</i>.  Disregarding the complication that the rover may* be able to wave enroute, consider <i>going(rock,hill)</i> as a goal* that is to be achieved by the rover.  In order to do this, the rover* must also satisfy other conditions, namely to be at the <i>rock</i>* before commencing the <i>going</i> action, to be at the <i>hill</i>* immediately following it, and to keep the arm <i>off</i> during the* travel.  The term subgoals stems from the common notion that such* conditions can be viewed as additional goals to be achieved by the* rover.** At a first glance, it may seem odd to view being at the hill after the* <i>going</i> activity as a goal.  After all, being on the hill is what* the going activity is meant to achieve.  The reason for viewing such* an ``effect'' as a subgoal is that compatibilities are deliberately* non-directional as far as time is concerned.  This makes it possible* to use the same method for planning, regardless of whether it is done* temporally backwards, forwards or even sideways.  This is in stark* contrast to traditional STRIPS planning where a different technique* (goal regression) is defined for planning backwards in time than for* planning forwards in time.* *NOTE: The point here is not of heuristic choice but of different*algorithms - this is orthogonal to search control issues** @subsection plansandcandidateplans Plans and Candidate Plans**Let us assume that a planning domain has been specified, in terms of*classes, attributes, predicates and domain axioms, as described here*above.  At a high level, this domain describes the kinds of objects we*can have, the attributes they have, and how the various states and*activities can interact.  Given such a domain, the goal of a planner*is to generate a valid plan, i.e., an evolution of object attribute*states and activities, such that a given specification of the goals is*achieved.  The issues we now need to address are: What constitutes a*valid plan, how are goals specified, and how can the planner reason*its way from goals to a plan.  The construct that ties all these* concepts together is that of a <i>candidate plan</i>, which consists of* the following:* <ul>* <li> horizon, specifying the time frame for which we are planning;* <li>a set of objects, i.e., instances of the domain classes;* <li> a timeline for each attribute of each object, each of which is* a sequence of one or more tokens that belong on that timeline;* <li> a set of tokens currently not associated with timelines (free*  tokens);* <li> a set of constraints on the variables of the tokens; these* include the temporal ordering constraints that are implicit in the*sequence of tokens on timelines.* </ul>** The horizon and the set of objects are typically viewed as fixed* members of candidate plans, i.e., they are not changed by the planning* process. Note: the system supports the addition of new objects* during the planning process, but we will only cover that functionality* in an appendix on advanced topics.  The sequence of tokens on the* timeline for each object attribute describes a set of possible* evolutions of that attribute over the planning horizon.  For an* example, consider a timeline for the rover location:* <br><br><center>* <i>at(lander) ... at(hill) ... at(lander)</i>.* </center><br><br>* This timeline describes a set of possible evolutions of the rover* locations, namely those in which the rover is at the lander twice, and* visits the hill in between.  Recall that between tokens on timelines* there are slots into which additional tokens can be put.  A result,* a given timeline does not specify a necessary evolution, it describes* a set of possible evolutions.** In a candidate plan, some tokens may not have been assigned inserted* into timelines yet.  Those are called <i>free tokens</i>.  Free tokens* differ from timeline tokens in two ways.  First, they have not been* scheduled on a timeline, i.e., the sequencing relation to other tokens* has not been decided.  For example, if <i>at(rock)</i> was a free token* that was to be inserted into the above sample timeline, then the* available options might be to put it before the first tt* <i>at(lander)</i>, between that token and <i>at(hill)</i>, and so forth.  The* second distinction is that a free token may not have been assigned to* a particular object, and is therefore not associated with a particular* timeline. Consider having two rovers with equal capabilities.  The* free token <i>at(rock)</i> could be accomplished by either of them. * This would be represented by the object variable of this token having* two possible values.* * The final element in the candidate plan is a set of constraints on* token variable instantiations.  Typically, these are constraints that* arise from planning domain axioms.** The planning process maps one candidate plan to another, with the goal* of generating a valid plan.  The operations available to the planning * process  are the following:*<ul>*<li>Modify the set of values for a variable*<li>Insert a token into a timeline*<li>Free a token from a timeline*</ul>* A <i>search engine</i> controls the application of these operations.* The candidate plan will be automatically updated, in response to these* operations, so as to enforce the constraints and rules specified in* the planning domain axioms.  Most of this automatic updating is in* terms of adding or removing subgoals, along with the applicable* constraints.  Let us therefore start by looking at the concept of* subgoaling.** Recall that one can express configuration rules as conditional* compatibilities, each of which maps a set of possible instantiations* of a predicate into a set of constraints and subgoals.  Given a* particular token, say <i>p([3,7],a,b,c)</i>, the conditional* compatibilities determine a set of applicable subgoals and* constraints.  If the value sets of the variables are modified, then* the set of applicable subgoals may change.  The changes are monotonic* in the sense that if the variable value sets are reduced, then more* subgoals and constraints may be added.  Similarly, if the value sets* are extended, subgoals and constraints may be removed.  Due to this* property, we will view the reduction and the extension of variable* value sets as separate operations.** To satisfy all applicable subgoals, any candidate plan is* automatically updated to include tokens that satisfy applicable* subgoals.  The applicable subgoals are directly determined by the* domain axioms, with one exception.  On each timeline, the first and* last tokens (which may be the same token) have a special status. * Consider the first token on a timeline, and any subgoal rules of the* form <i>met_by token</i>.  Since any token used to satisfy* this subgoal will be considered outside of the planning horizon, this* subgoal is in fact not applicable.  Similarly, subgoals of the form* <i>meets token</i> are not applicable to the last token on a* timeline.* * To see an example of how this all comes together, let us assume we* have a candidate plan for our rover, with a timeline that contains two* tokens:*<br><br><center><i>* at(rock) @f$\ldots@f$ at(hill)*</i></center><br><br>* The compatibilities for the <i>at</i> state are as follows:*<br><br><center><i>*at<sub>o</sub>(x); *  @f$\rightarrow@f$ *  metBy going<sub>o</sub>(?,x),<br>*  meets going<sub>o</sub>(x,?)*</i></center><br><br>*   Looking at <i>at(rock)</i>, we see that we get one applicable* subgoal, since the <i>metBy</i> subgoal is inapplicable.  Similarly,* for the <i>at(hill)</i>, we get another applicable subgoal.  To satisfy* these subgoals, two new free tokens are added to the candidate plan:* <i>going(rock,?)</i> and <i>going(?,hill)</i>, along with the* appropriate temporal constraints, namely that <i>going(rock,?)</i>* starts as soon as <i>at(rock)</i> ends, and that <i>going(?,hill)</i>* comes immediately before <i>at(hill)</i>.  If one of the <i>at</i> * tokens is later removed from the timeline (or the candidate plan* altogether), the corresponding subgoal is also removed.** In EUROPA2, the candidate plans all satisfy a simple invariant: All* applicable subgoals are satisfied for all tokens on timelines.  The* automatic updating enforces this invariant, based on subgoaling.  This* is done as follows:*<ul>*<li>Restrict a variable value set: If the token is on a timeline,*add free tokens to satisfy any subgoals that become applicable as a*result of the restriction.*<li>Extend a variable value set: If the token is on a timeline,*delete any tokens generated to satisfy subgoals that are no longer*applicable, due to the change in the value set.*<li>Insert a token on a timeline: Add new free tokens to satisfy*all applicable subgoals for the inserted token.*<li>Remove a token from a timeline: Delete all tokens that were*added to satisfy subgoals for this token.*</ul>** The goal of the planning process, which is driven by a <i>search* engine</i>, is to apply these operations, mapping one candidate plan to* another, until a valid plan is found.  Formally, the definition of a* valid plan is in terms of the executive that executes the plan.  This* is because different executive have different capabilities.  We will* return to this issue later; until then, a <i>valid plan</i> (or simply* a <i>plan</i> is a plan candidate that satisfies the following*conditions:* <ul>* <li>There are no free tokens* <li>All parameter variables have been assigned single values* </ul>**@subsection summarycbi Summary** In this section, we have given a brief overview of the EUROPA2* planning paradigm. With these concepts in place, we can now turn our attention to the* planning system itself, how it can be used, and how it works. The remaining two sections* of this tutorial step through two example applications to achieve this. */