#summary Tristan's attempt to

I have divided this approach into two pieces:
 1.  Calculating profiles.  They're not really profiles anymore, but it's similar, at least philosophically, to resource profile calculations.
 1.  Using profiles to calculate flaws and violations.

At Jeremy's suggestion, I have tried to get everything working without too much concern for efficiency.  For example, the above separation may make it harder to do things efficiently, but the two pieces can be mixed without messing up the approach, I believe.

For notation, I use:
 * SET(es) and SET(ls) for the earliest and latest starts for the SET transaction.
 * REQ(es), REQ(ls), for the earliest and latest times for the REQ to begin.
 * -REQ(es), and -REQ(ls) for the earliest and latest times for the REQ to end.

= Calculating profiles =

As we pass through time, we update 3 sets whenever we hit one of the above six classes of time points:
 * *A:*  The set of possible SET instances that could be valid at this time.
 * *B:*  The set of REQ tokens that _might_ occur at this time.
 * *C:*  The set of REQ tokens that _must_ occur at this time.

=== Building A ===

To build A, we start with the empty set for simplicity (having an initial state, or set of states is no different).  Then:
 * If we reach a SET(es), we add SET to A
 * If we reach a SET(ls), we can remove any SET' for which SET'(ls) < SET(es)  (Mike, this is equivalent to the bar we talked about)

=== Building B ===

To build B, we start with the empty set.  Then:
 * If we reach REQ(es), we add REQ
 * If we reach -REQ(ls), we remove REQ

=== Building C ===

To build C, we start with the empty set.  Then:
 * If we reach REQ(ls), we add REQ
 * If we reach -REQ(es), we remove REQ

Note that C is a subset of B.

= Detection flaws and violations =

This can be broken into a number of cases:

 1.  *FV detection just within A:*  For any pair SET and SET' in A:
   1.  It is a violation if they both _must_ start at the same time and _must_ set the state to different values (assuming for now that the state can be set to the same thing  by multiple SETs at the same time).
   1.  The same thing with _might_ and _must_ is a flaw:  It is a violation if they both _might_ start at the same time and _must_ set the state to different values (assuming for now that the state can be set to the same thing  by multiple SETs at the same time).
   1.  The same thing with _must_ and _might_ is a flaw.
   1.  The same things with _might_ and _might_ is a flaw.
 1.  *FV detection within B and C:*
   1.  If C contains REQ1 and REQ2, and their values _must_ not intersect, it is a violation.
   1.  If B contains REQ1 and REQ2, and their values _might_ not intersect, it is a flaw
 1.  *FV detection between A and B,C:*
   1.  If C contains REQ, and there is no SET in A whose value might match that of REQ, it is a violation.
   1.  If B contains REQ, and there is no SET in A whose value might match that of REQ, it is a flaw.
   1.  If B contains REQ, and there is any SET in A whose value might not match that of REQ, it is a flaw.


= Adding temporal constraints =

Most of the above ingores the fact that fewer flaws (and possibly more violations?) could be detecting by being aware of necessary (implicit or explicit) temporal constraints between SET, REQ, and -REQ.

Although some of this could be handled when the A,B,C are calculated (in fact, notice that we've used one implicit temporal constraint to decide when a SET is removed from A), not all of it can be (eg:  even if there is an SET->SET' constraint, the domains for SET and SET' can overlap).  Therefore, I propose:

 * Timetable-style FV detection does the above.
 * Flow-profile-style FV detection that augments the above with 
    * A precomputed all-pairs temporal constraint network (ie be able to quickly look up whether X is temporally constrained to be before Y)
    * Update the above flaw/violation rules slightly.

For example, consider the flaws/violations within B and C:

   1.  If C contains REQ1 and REQ2, and their values _must_ not intersect, it is a violation (no change here because if we're in C, there must not be a temporal constraint between REQ1 and REQ2)
   1.  If B contains REQ1 and REQ2, and their values _might_ not intersect *and there is no precedence constraint between them*, it is a flaw

= Resolving flaws and violations =

Haven't thought about this! :)  However, it feels like there will be some pretty good heuristics that will tend to guide search in the right direction.

